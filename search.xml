<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>AcWing 算法基础课</title>
    <url>/2022/03/20/AcWing/Algorithm_Basic/</url>
    <content><![CDATA[<h2 id="学习平台"><a href="#学习平台" class="headerlink" title="学习平台"></a>学习平台</h2><p><strong><a href="https://www.acwing.com/activity/content/11/">AcWing 算法基础课 </a></strong> </p>
<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><strong>算法思想</strong> <kbd>分治</kbd></p>
<p>分支算法可分为三步：</p>
<ul>
<li>分成子问题</li>
<li>递归处理子问题</li>
<li>子问题合并</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序：先排序后分治</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quick_sort</span><span class="params">(<span class="type">int</span> p[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;  <span class="comment">// 边界问题</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = p[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;  <span class="comment">// 分界点(哨兵)取中间值</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++ ;<span class="keyword">while</span>(p[i] &lt; x);  <span class="comment">// 在左边找到第一个比哨兵大的数</span></span><br><span class="line">        <span class="keyword">do</span> j-- ;<span class="keyword">while</span>(p[j] &gt; x);  <span class="comment">// 在右边找到第一个比哨兵小的数</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(p[i],p[j]);  <span class="comment">// 交换左右两边的两个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Quick_sort</span>(p, l, j);  <span class="comment">// 递归排序左边界</span></span><br><span class="line">    <span class="built_in">Quick_sort</span>(p, j + <span class="number">1</span>, r);  <span class="comment">// 递归排序有边界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><strong>算法思想</strong> <kbd>分治</kbd></p>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序：线分治后排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="type">int</span> p[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的中间值不能取(l+r+1)/2</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Merge_sort</span>(p,l,mid);</span><br><span class="line">    <span class="built_in">Merge_sort</span>(p,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个有序数组，</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i = l,j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(p[i] &lt;= p[j]) tmp[k ++] = p[i ++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++] = p[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++]=p[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k ++]=p[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>;i &lt;= r; i ++, j ++) p[i]=tmp[j];</span><br><span class="line">    <span class="comment">//i=l是因为l永远是分组的左边界，不能写成i=0,同理r也永远是分组的右边界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p><strong>算法思想</strong> <kbd>二分</kbd></p>
<p><strong>实现思想</strong> 假定目标值在区间<kbd>[l, r]</kbd> 中，每次将区间长度缩小一半，当<kbd>l = r</kbd> 时，则可以取到目标值。</p>
<p>整数二分查找存在两个模板，取决于中间值的取值方法：</p>
<ul>
<li>当<kbd>mid = l + r >> 1</kbd> 时：</li>
</ul>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当<kbd>mid = l + r + 1 >> 1</kbd> 时：</li>
</ul>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p><strong>算法思想</strong> <kbd>大数加法</kbd> ；</p>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B.<span class="built_in">size</span>() &gt; A.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B,A);  <span class="comment">// 让两个大数中长度相对较短的做B，相对较长的做A</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;  <span class="comment">// 用于存放结果</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 存放进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i]; <span class="comment">//如果B还没有遍历完，需要加上对应位置，若遍历完，则不需要加上了。</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>); <span class="comment">// 若有进位，则只存放个位数字</span></span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">//将进位保存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(t); <span class="comment">//最后有进位的话（进位一定是个位数），将进位加入C</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p><strong>算法思想</strong> <kbd>大数减法</kbd> ；</p>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A - B;需要首先使用bmp函数判断A是否大于B；若A大于B，则结果为正数并sub(A, B)；若A小于B，则结果为负数，需要先输出&#x27;-&#x27;并sub(B, A)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断A是否大于B，若是则返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)  <span class="comment">// 长度相同时，从后往前遍历比较大小</span></span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度减法</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">// 若之前有借位，则需要先减去借位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;<span class="comment">// t &lt; 0 证明有借位</span></span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个判断是为了确保结果不是0，若结果是0，则最后一个0不需要去掉</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">//取出前导0  若结果为003，则需要去掉00</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h3><p><strong>算法思想</strong> <code>大数乘法</code></p>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h3><p><strong>算法思想</strong> <code>大数除法</code> </p>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p><strong>什么是前缀和</strong></p>
<p>原数组：<kbd>a[1], a[2], a[3], a[4], a[5], …, a[n]</kbd><br>前缀和：<kbd>S[i]</kbd>为数组的前 i项和<br>前缀和：<kbd>S[i] = a[1] + a[2] + a[3] + … + a[i]</kbd> </p>
<p>为方便求解，以及后续方便计算，通常令<kbd>S[0] = 0</kbd> ,<kbd>原数组</kbd> 以及<kbd>前缀和数组</kbd> 的下标从1开始。 </p>
<p><strong>前缀和的作用</strong>  </p>
<p>快速求出元素组中某段区间的和。</p>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pSum</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum[N];  <span class="comment">// 存放数组的前缀和</span></span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        sum[i] = arr[i] + sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二维数组求解前缀和</strong> </p>
<p><strong>计算过程</strong> <kbd>s[i, j] = s[i - 1, j] + s[i, j - 1] + s[i - 1, j - 1] + a[i, j]</kbd></p>
<p><img src="/../../img/AcWing/Basic/%E5%89%8D%E7%BC%80%E5%92%8C.png" alt="前缀和"></p>
<p>同样的为了方便计算，二维数组下标也需要从 1 开始</p>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            s[i][j] = s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]; <span class="comment">// 求前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="comment">// 算子矩阵的和</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x2][y1 - <span class="number">1</span>] - s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p><code>差分</code> 和 <code>前缀和</code> 是一对互逆运算</p>
<p><strong>定义</strong> 对于一个给定的数列A，他的差分序列B定义为：</p>
<p><code>B[1] = A[1], B[i] = A[i] - A[i - 1](2 &lt;= i &lt;= n)</code> </p>
<hr>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>这里采用<strong>数组模拟</strong>链表，因为采用new Node()的过程是比较慢的；</p>
<ul>
<li>单链表：可以用于实现邻接表(存储树或图)</li>
<li>双链表：优化某些问题</li>
</ul>
<p><strong>实现方法</strong> 单链表使用数组模拟的方法：使用两个数组<kbd>e[n]</kbd>; <kbd>ne[n]</kbd> 其中<kbd>e[i]</kbd>存放第i个元素的值，<kbd>ne[i]</kbd>存放第i个元素的后继下标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//head 表示头节点的下标</span></span><br><span class="line"><span class="comment">//e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">//ne[n] 表示节点i的next的值</span></span><br><span class="line"><span class="comment">//idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头节点之前</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx ++；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 下标是k的 后面的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];  <span class="comment">// 相当于 p-&gt;next = p-&gt;next-&gt;next</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标为k的节点后插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="built_in">init</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>同样使用数组模拟双链表，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下标是k的节点右边插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;  <span class="comment">//在k的左边插入的话，直接调用 add(l[k], x)</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    l[r[idx]] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除下标为k的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>采用<strong>数组模拟栈</strong></p>
<p><strong>实现方法</strong> <kbd>top</kbd>栈顶指针，当<kbd>top == 0</kbd>时栈空，<kbd>stk[N]</kbd>存放元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> top, stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)&#123;  <span class="comment">//入栈</span></span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            stk[++ top] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>) top --;  <span class="comment">// 出栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>) cout &lt;&lt; stk[top] &lt;&lt;endl;  <span class="comment">//输出栈顶元素</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; (top ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl; <span class="comment">// 判断栈是否为空，top为0 则栈空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>采用<strong>数组模拟队列</strong></p>
<p><strong>实现方法</strong> <kbd>tail</kbd>队尾指针，<kbd>head</kbd>队头指针，当<kbd>head == 0 || head > tail</kbd>时队空，<kbd>que[N]</kbd>存放元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head, que[N], tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            que[++tail] = x;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="number">0</span>) head++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>) head ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>) cout &lt;&lt; que[head] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="number">0</span> || tail &lt; head) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p><strong>定义</strong> 是一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低，</p>
<p><strong>算法习惯</strong> 下标从1开始；存在一个<code>模式串</code>、一个<code>模板串</code></p>
<p><strong>算法精讲</strong> </p>
<p><a href="https://www.acwing.com/solution/content/14666/"> KMP字符串 </a></p>
<p><strong>算法思路</strong> </p>
<ul>
<li><code>s[n]</code>模式串：即比较长的字符串</li>
<li><code>p[m]</code>模板串：即比较短的字符串</li>
<li><code>ne[m]</code>部分匹配值表：存储的是每一个下标对应的部分匹配值</li>
</ul>
<p><kbd>p[1, j] == p[i - ne[j] + 1, i]</kbd></p>
<p><img src="/../../img/AcWing/Basic/KMP.png" alt="KMP"></p>
<ul>
<li>核心思想：在每次匹配失败后，不是把p串向后移动一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找<code>ne[ ]</code>数组确定的。</li>
</ul>
<p><strong>匹配思路和实现代码</strong> </p>
<p>KMP主要分为两步：<kbd>求解ne数组</kbd> ；<kbd>匹配字符串</kbd></p>
<p><code>s[n]</code>和<code>p[m]</code>都是从1开始的，</p>
<ul>
<li><strong>求解ne数组</strong></li>
</ul>
<p>因为<code>p[m]</code>下标从1开始，所以<code>ne[1] = 0</code>，求解<code>ne[]</code>时直接从下标为2开始遍历，i 。j表示当前前面最多匹配了j个字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动模拟一遍更清楚。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) <span class="comment">// ne[1]默认为0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j]; <span class="comment">//若已经匹配了字符，但是当前又不匹配了，则j需要返回起点。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line"></span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>匹配字符串</strong></li>
</ul>
<p>i 从1开始遍历s数组，j 从0开始遍历p数组。每次将<code>s[i]</code>和<code>p[j + 1]</code>进行比较。若相等，则匹配；若碰到第i个字符不匹配，则直接将<kbd>j = ne[j]</kbd>，i 不变。<strong>通过将遍历p的指针前移来达到p后移的效果。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span></span><br><span class="line">    <span class="comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//当前元素匹配，j移向p串下一位</span></span><br><span class="line">    <span class="keyword">if</span>(j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配成功，进行相关操作</span></span><br><span class="line">        j = next[j];  <span class="comment">//继续匹配下一个子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><p><strong>算法定义</strong> 用于快速存储和查找字符串集合的树。</p>
<p><strong>实现思想</strong> </p>
<ul>
<li><code>son[N][26]</code> 存放小写字母，因此每个节点最多可以扩展出26边，每代表一个点，每列代表该节点扩展出一条边。</li>
<li><code>cnt[i]</code> 以当前第i个结尾的有单词则为1，否则为0。</li>
<li><code>idx</code> 下标，idx为0时，即代表根节点，又是空节点。</li>
</ul>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组模拟的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">//son[N][26]: 存放小写字母，因此每个节点最多可以扩展出26条边</span></span><br><span class="line"><span class="comment">//cnt[N]: 以当前节点扩展的节点有多少个。</span></span><br><span class="line"><span class="comment">//idx: 下标，idx为0是既代表根节点，又是空节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">   	<span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">// 每个单词都是从第一行开始，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">       	<span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 将小写字母转换为0~25的数字</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;  <span class="comment">//如果p这个节点不存在u这个子节点</span></span><br><span class="line">        p = son[p][u];  <span class="comment">//跳转到p行</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;  <span class="comment">// </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//查询函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果p后没有u节点，则直接输出0</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p><strong>目的：</strong>在近乎<code>O(1)</code>的时间复杂度内支持下面两个操作</p>
<p>​        1.将两个集合合并；</p>
<p>​        2.询问两个元素是否在一个集合中；</p>
<p><strong>原理：</strong>每个集合用一颗树表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，<code>p[x]</code>表示x的父节点。若<code>p[x] == x</code>，则x为根节点</p>
<p><strong>问题1：</strong>如何判断树根节点： <kbd>if(p[x] == x)</kbd></p>
<p><strong>问题2：</strong>如何求x的集合编号：<kbd>while(p[x] != x) x = p[x]</kbd> ；</p>
<p><strong>问题3：</strong>如何合并两个集合： <code>p[x]</code>是x的集合编号，<code>p[y]</code>是y的集合编号，则<kbd>p[x] = y</kbd> ；</p>
<p><strong>优化：路径压缩：</strong>当查询过一遍后，将路径上所有的节点直接指向根节点。</p>
<h3 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存放每个节点的父节点，第i个节点的父节点为p[i]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径压缩（优化）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) <span class="comment">// 如果不是根节点</span></span><br><span class="line">        p[x] = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;                                                                                                                                           </span><br><span class="line"><span class="comment">// 合并x，y所在的两个集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);  <span class="comment">//将x的祖宗节点的父节点设置为 y的祖宗节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断x，y是否在同一集合中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Judge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y))	<span class="comment">//祖宗节点是同一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>作用</strong> 维护一个数据集合；</p>
<p><strong>需要实现的操作</strong> </p>
<ul>
<li>插入一个数；<kbd>heap[++size] = x; up(size)</kbd></li>
<li>求集合当中的最小值；<kbd>heap[1];</kbd></li>
<li>删除最小值；<kbd>heap[1] = heap[size]; size--; down(1);</kbd></li>
<li>删除任意元素；<kbd>heap[k] = heap[size]; size--; down(k); up(k);</kbd></li>
<li>修改任意元素；<kbd>heap[k] = x; down(size); up(size);</kbd></li>
</ul>
<p><strong>基本结构</strong> 是一颗<code>完全二叉树</code>（除了最后一层节点之外，上层节点都是非空，最后一层节点是从左到右依次排布）</p>
<ul>
<li>小根堆：每个节点都满足小于等于左右两边的节点。</li>
</ul>
<p><strong>存储数据结构</strong> 使用数组存储，1号节点是根节点（下标从1开始），左儿子是<code>2x</code> ；右儿子是<code>2x+1</code> </p>
<ul>
<li><code>h[N]</code>存储堆中的值, h[1]是堆顶，x的左儿子是<code>2x</code>, 右儿子是<code>2x + 1</code></li>
<li><code>ph[k]</code>存储第k个插入的点在堆中的位置</li>
<li><code>hp[k]</code>存储堆中下标是k的点是第几个插入的</li>
<li><code>size</code> 堆中元素的个数</li>
</ul>
<p><strong>需要的操作</strong> </p>
<ul>
<li><code>down(x)</code> 将x节点往下移</li>
<li><code>up(x)</code> 将x节点往上移</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;  <span class="comment">// 存在左孩子并且左孩子比较小</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 存在右孩子并且有孩子比较小</span></span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t); <span class="comment">// 交换父亲节点 和 相对较小的子节点 </span></span><br><span class="line">        <span class="built_in">down</span>(t);  <span class="comment">//递归遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="STL简介"><a href="#STL简介" class="headerlink" title="STL简介"></a>STL简介</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h2><h3 id="DFS与BFS"><a href="#DFS与BFS" class="headerlink" title="DFS与BFS"></a>DFS与BFS</h3><p><strong>对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>数据结构</th>
<th>空间</th>
<th>性质</th>
</tr>
</thead>
<tbody><tr>
<td>DFS</td>
<td>stack</td>
<td>O(h)</td>
<td>不具有最短性</td>
</tr>
<tr>
<td>BFS</td>
<td>queue</td>
<td>O(2^h^)</td>
<td>“最短路”</td>
</tr>
</tbody></table>
<h4 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索 DFS"></a>深度优先搜索 DFS</h4><p><strong>算法：</strong> <code>回溯</code>、<code>剪枝</code></p>
<h4 id="宽度优先搜索-BFS"><a href="#宽度优先搜索-BFS" class="headerlink" title="宽度优先搜索 BFS"></a>宽度优先搜索 BFS</h4><p>类似于层序遍历</p>
<h3 id="树与图的遍历：拓扑排序"><a href="#树与图的遍历：拓扑排序" class="headerlink" title="树与图的遍历：拓扑排序"></a>树与图的遍历：拓扑排序</h3><p>树是一种特殊的图</p>
<h4 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h4><ul>
<li>有向图<ul>
<li>邻接矩阵：二维数组，适用于稠密图，<code>T(n) = O(n ^ 2)</code></li>
<li>邻接表：n个节点对应n个单链表，适用于稀疏图。</li>
</ul>
</li>
</ul>
<p><strong>邻接表</strong></p>
<ul>
<li><code>h[N]</code>：所有头节点的集合</li>
<li><code>e[N]</code>：存每个节点的值</li>
<li><code>ne[N]</code>：存每个节点的next值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; <span class="comment">// 头插</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure>

<h4 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h4><p>只考虑有向图即可。</p>
<ul>
<li>时间复杂度：<code>O(n + m)</code>，n表示点数，m表示边数</li>
</ul>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树与图的宽度优先遍历"><a href="#树与图的宽度优先遍历" class="headerlink" title="树与图的宽度优先遍历"></a>树与图的宽度优先遍历</h4><ul>
<li>需要使用到队列，在对二叉树使用宽度有点遍历时，其实就是对二叉树进行层序遍历。</li>
</ul>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><ul>
<li>时间复杂度：<code>O(n + m)</code>，n表示点数，m表示边数</li>
</ul>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><p><font color='orange'>常见的<code>最短路径</code>问题</font> ：n点的数量，m边的数量。</p>
<ul>
<li><code>单源最短路径</code> <ul>
<li>所有边权都是正数<ul>
<li>朴素<code>Dijkstra</code>算法 ：<code>O(n^2)</code> 适用于稠密图</li>
<li>堆优化版的<code>Dijkstra</code>算法：<code>O(m * logn)</code> 适用于稀疏图</li>
</ul>
</li>
<li>存在负权边<ul>
<li><code>Bellman-Ford </code> ： <code>O(nm)</code></li>
<li><code>SPFA</code> :  一般是<code>O(m)</code>，最坏是<code>O(nm)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>多源汇最短路径</code> ：<ul>
<li><code>Floyd</code>算法：<code>O(n^3)</code></li>
</ul>
</li>
</ul>
<p><img src="/../../img/AcWing/Basic/shortLoad.png" alt="shortLoad"></p>
<h4 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素<code>Dijkstra</code></h4><ul>
<li>使用<code>邻接矩阵</code>存储，有向图：无向图是一种特殊的有向图。</li>
<li><code>s[i]</code> ：当前已确定最短路径的点。</li>
<li><code>dist[i]</code> ：第<code>i</code>个节点距离起点(1号点)的距离。初始化<code>dist[1] = 0</code>、<code>disst[i] = +Max</code></li>
<li><code>g[N][N]</code> ：存储每条边，下标从1开始</li>
</ul>
<p><img src="/../../img/AcWing/Basic/Dijkstra.png" alt="Dijkstra"></p>
<p><strong>代码模板</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定，false:未确定，true：已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 初始化dist数组，将每个元素初始化为正无穷大。</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) <span class="comment">// 循环前n-1个节点即可，最后一个节点不用判断。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) <span class="comment">//在所有st[j] == false 中找到dist最下的点。</span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 第一个节点和n不连通</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆优化版的Dijkstra"><a href="#堆优化版的Dijkstra" class="headerlink" title="堆优化版的Dijkstra"></a>堆优化版的<code>Dijkstra</code></h4><ul>
<li>使用堆对朴素<code>Dijkstra</code>算法进行优化</li>
<li>堆：使用c++里面的优先队列。</li>
<li>数据结构：因为针对稀疏图，所以采用<code>邻接表</code>的方式存储。</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="comment">// 定义优先队列代替堆，这样定义是小根堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h2><h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><h4 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h4><p><strong>Def</strong> 在大于1的整数中，如果只包含1和整数这两个约数，就被称为质数，或者素数。</p>
<p><strong>质数的判定—试除法</strong> </p>
<p>实现思想 ：i 从 2 枚举到 $\sqrt{n}$ 会缩减循环，但是<code>sqrt(n)</code>执行较慢，所以不使用。<code>O(sqrt(n))</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分解质因数—试除法</strong> </p>
<p>实现思想：从小到大枚举所有数，<code>O(sqrt(n))</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// i 一定是质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>朴素筛法求素数—埃氏筛法</strong> </p>
<p>实现思想：从2遍历到n，遍历到第i个数的时候，若该数没有被删除，则加入质数数组，然后删除该数的所有倍数。<code>O(n * loglogn)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>; <span class="comment">//如果第i个数已经被删掉，跳过</span></span><br><span class="line">        primes[cnt ++ ] = i; <span class="comment">// 如果第i个数还没有被删掉，则说明从2~i-1没有值是i的因子</span></span><br><span class="line">        <span class="comment">// 删除 质数i 的所有倍数，这里仅删除质数的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>线性筛法求素数</strong> </p>
<p><img src="/../../img/AcWing/Basic/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0.png" alt="线性筛法求素数"> </p>
<p>相较于<code>埃氏筛法</code>快将近一倍。</p>
<p>实现思想：n只会被它的最小质因子筛掉。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i; <span class="comment">// 如果是质数，加入至质数数组</span></span><br><span class="line">        <span class="comment">// 从小到大枚举所有的质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j] 一定是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h4><p><strong>试除法求所有约数</strong></p>
<p>实现思想类似于试除法求质数。<code>O(sqrt(n))</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//使用vector数组存放所有约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>约数个数</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">如果 N = p1<span class="built_in">^</span>c1 * p2<span class="built_in">^</span>c2 * ... *pk<span class="built_in">^</span>ck</span><br><span class="line">约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span><br><span class="line">约数之和： (p1<span class="built_in">^</span>0 + p1<span class="built_in">^</span>1 + ... + p1<span class="built_in">^</span>c1) * ... * (pk<span class="built_in">^</span>0 + pk<span class="built_in">^</span>1 + ... + pk<span class="built_in">^</span>ck)</span><br></pre></td></tr></table></figure>



<h3 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h3><h3 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h3><h3 id="简单博弈论"><a href="#简单博弈论" class="headerlink" title="简单博弈论"></a>简单博弈论</h3>]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>AcWing</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing LeetCode究极班 Week1</title>
    <url>/2022/03/22/AcWing/LeetCode_Week1/</url>
    <content><![CDATA[<h2 id="学习平台"><a href="#学习平台" class="headerlink" title="学习平台"></a>学习平台</h2><p><strong><a href="https://www.acwing.com/activity/content/31/"> AcWing LeetCode究极班 </a></strong> </p>
<p><strong><a href="https://leetcode-cn.com/"> LeetCode </a></strong> </p>
<h2 id="Let-1：两数之和"><a href="#Let-1：两数之和" class="headerlink" title="Let 1：两数之和"></a>Let 1：两数之和</h2><p>给定一个整数数组<code>nums</code>和一个整数目标值<code>target</code>，请你在该数组中找出<strong>和为目标值</strong><code>target</code>的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n^2)</code> 的算法吗？</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j&lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    arr.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    arr.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-2：两数相加"><a href="#Let-2：两数相加" class="headerlink" title="Let 2：两数相加"></a>Let 2：两数相加</h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">// 生成一个新的头节点，指向结果</span></span><br><span class="line">        <span class="keyword">auto</span> cur = dummy; <span class="comment">// 一个指针，指向结果链表的尾节点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//用来保存进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1) t += l1 -&gt; val, l1 = l1 -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(l2) t += l2 -&gt; val, l2 = l2 -&gt; next;</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>); <span class="comment">// 取出个位加入生成新节点</span></span><br><span class="line">            cur = cur -&gt; next; <span class="comment">// 更新尾指针</span></span><br><span class="line">            t /= <span class="number">10</span>;  <span class="comment">// 去除进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-3：无重复字符的最长子串"><a href="#Let-3：无重复字符的最长子串" class="headerlink" title="Let 3：无重复字符的最长子串"></a>Let 3：无重复字符的最长子串</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code>由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; head; <span class="comment">// hash map</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)&#123;</span><br><span class="line">            head[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(head[s[i]] &gt; <span class="number">1</span>) head[s[j++]]--;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-4：寻找两个正序数组的中位数"><a href="#Let-4：寻找两个正序数组的中位数" class="headerlink" title="Let 4：寻找两个正序数组的中位数"></a>Let 4：寻找两个正序数组的中位数</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; arr; <span class="comment">// 将两个数组合并后的数组</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])</span><br><span class="line">                arr.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arr.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.<span class="built_in">size</span>()) arr.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.<span class="built_in">size</span>()) arr.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; arr.<span class="built_in">size</span>(); k++) cout &lt;&lt; arr[k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(len % <span class="number">2</span> != <span class="number">0</span>)&#123; <span class="comment">// 合并后的数组长度是奇数</span></span><br><span class="line">            <span class="keyword">return</span> arr[len / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 合并后的数组长度是偶数</span></span><br><span class="line">            <span class="built_in">return</span> (arr[len / <span class="number">2</span>] + arr[len / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-5：最长回文子串"><a href="#Let-5：最长回文子串" class="headerlink" title="Let 5：最长回文子串 *"></a>Let 5：最长回文子串 *</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li>s 仅由数字和英文字母组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;<span class="comment">//回文串为偶数个的情况</span></span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() &lt; r - l - <span class="number">1</span>) res = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            l = i, r = i + <span class="number">1</span>; <span class="comment">//回文串为奇数个的情况</span></span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() &lt; r - l <span class="number">-1</span>) res = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-6：Z-字形变换"><a href="#Let-6：Z-字形变换" class="headerlink" title="Let 6：Z 字形变换"></a>Let 6：Z 字形变换</h2><p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>

<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>

<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由英文字母（小写和大写）、<code>&#39;,&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
<li><code>1 &lt;= numRows &lt;= 1000</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>)</span><br><span class="line">                    res += s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - i; j &lt; s.<span class="built_in">size</span>() || k &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; s.<span class="built_in">size</span>()) res += s[j];</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) res += s[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-7：整数反转"><a href="#Let-7：整数反转" class="headerlink" title="Let 7：整数反转"></a>Let 7：整数反转</h2><p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231,  231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">-9</span> &amp;&amp; x &lt;= <span class="number">9</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans &lt; <span class="number">-2147483648</span> || ans &gt; <span class="number">2147483647</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-8：字符串转换整数-atoi"><a href="#Let-8：字符串转换整数-atoi" class="headerlink" title="Let 8：字符串转换整数(atoi) *"></a>Let 8：字符串转换整数(atoi) *</h2><p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C&#x2F;C++ 中的 <code>atoi</code> 函数）。</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为<code> 0</code> 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 <code>[−231,  231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code>，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符<code> &#39; &#39;</code> 。</li>
<li>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         <span class="built_in">^</span></span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         <span class="built_in">^</span></span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           <span class="built_in">^</span></span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            <span class="built_in">^</span></span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             <span class="built_in">^</span></span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               <span class="built_in">^</span></span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         <span class="built_in">^</span></span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         <span class="built_in">^</span></span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             <span class="built_in">^</span></span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字<code>（0-9）</code>、<code>&#39; &#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code> 和 <code>&#39;.&#39;</code> 组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k++; <span class="comment">//去掉前导空格</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> minus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[k] == <span class="string">&#x27;-&#x27;</span>) minus = <span class="number">-1</span>, k++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[k] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = s[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(minus &gt; <span class="number">0</span> &amp;&amp; res &gt; (INT_MAX - x) / <span class="number">10</span>) <span class="keyword">return</span> INT_MAX; <span class="comment">//加上x后会超出上界</span></span><br><span class="line">            <span class="keyword">if</span>(minus &lt; <span class="number">0</span> &amp;&amp; -res &lt; (INT_MIN + x) / <span class="number">10</span>) <span class="keyword">return</span> INT_MIN; <span class="comment">//加上x后会超出下界</span></span><br><span class="line">            <span class="keyword">if</span> (-res * <span class="number">10</span> - x == INT_MIN) <span class="keyword">return</span> INT_MIN; <span class="comment">//加上x刚好等于下界</span></span><br><span class="line">            res = res * <span class="number">10</span> + x;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= minus;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-9：回文数"><a href="#Let-9：回文数" class="headerlink" title="Let 9：回文数"></a>Let 9：回文数</h2><p>给你一个整数 <code>x</code> ，如果 <code>x </code>是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>


<p>提示：</p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p><strong>代码实现</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = x;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + m % <span class="number">10</span>;</span><br><span class="line">            m /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-10：正则表达式匹配"><a href="#Let-10：正则表达式匹配" class="headerlink" title="Let 10：正则表达式匹配 *"></a>Let 10：正则表达式匹配 *</h2><p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持<code>&#39;.&#39;</code>和<code> &#39;*&#39;</code> 的正则表达式匹配。</p>
<ul>
<li><code>&#39;.&#39;</code>匹配任意单个字符</li>
<li><code>&#39;*&#39;</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab&quot;, p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= p.length &lt;= 30</code></li>
<li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>. </code>和<code>*</code>。</li>
<li>保证每次出现字符<code>*</code>时，前面都匹配到有效的字符</li>
</ul>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>AcWing</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing LeetCode究极班 Week2</title>
    <url>/2022/03/24/AcWing/LeetCode_Week2/</url>
    <content><![CDATA[<h2 id="学习平台"><a href="#学习平台" class="headerlink" title="学习平台"></a>学习平台</h2><p><strong><a href="https://www.acwing.com/activity/content/31/"> AcWing LeetCode究极班 </a></strong> </p>
<p><strong><a href="https://leetcode-cn.com/"> LeetCode </a></strong> </p>
<h2 id="Let-11：盛水最多的容器"><a href="#Let-11：盛水最多的容器" class="headerlink" title="Let 11：盛水最多的容器 *"></a>Let 11：盛水最多的容器 *</h2><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p><strong>说明：</strong>你不能倾斜容器。</p>
<p><strong>标签：</strong> <code>贪心</code>、<code>数组</code>、<code>双指针</code></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; i &lt; j;)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j]) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-12：整数转罗马数字"><a href="#Let-12：整数转罗马数字" class="headerlink" title="Let 12：整数转罗马数字"></a>Let 12：整数转罗马数字</h2><p>罗马数字包含以下七种字符： <code>I</code>，<code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code>+ <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p> 给你一个整数，将其转为罗马数字。</p>
<p><strong>标签：</strong> <code>哈希表</code>  <code>数学</code>  <code>字符串</code></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 3999</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">while</span>(a--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;M&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">900</span> &amp;&amp; num &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;CM&quot;</span>;</span><br><span class="line">                num %= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;=<span class="number">500</span> &amp;&amp; num &lt; <span class="number">900</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">100</span>;</span><br><span class="line">                res += <span class="string">&quot;D&quot;</span>;</span><br><span class="line">                <span class="type">int</span> sum = a - <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">while</span>(sum--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;C&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">400</span> &amp;&amp; num &lt; <span class="number">500</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;CD&quot;</span>;</span><br><span class="line">                num %= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">100</span> &amp;&amp; num &lt; <span class="number">400</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">while</span>(a--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;C&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">90</span> &amp;&amp; num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;XC&quot;</span>;</span><br><span class="line">                num %= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">50</span> &amp;&amp; num &lt; <span class="number">90</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">10</span>;</span><br><span class="line">                res += <span class="string">&quot;L&quot;</span>;</span><br><span class="line">                <span class="type">int</span> sum = a<span class="number">-5</span>;</span><br><span class="line">                <span class="keyword">while</span>(sum--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;X&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">40</span> &amp;&amp; num &lt; <span class="number">50</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;XL&quot;</span>;</span><br><span class="line">                num %= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt; <span class="number">40</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">while</span>(a--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;X&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(num &gt;= <span class="number">9</span> &amp;&amp; num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;IX&quot;</span>;</span><br><span class="line">                num %= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">5</span> &amp;&amp; num &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">1</span>;</span><br><span class="line">                res += <span class="string">&quot;V&quot;</span>;</span><br><span class="line">                <span class="type">int</span> sum = a<span class="number">-5</span>;</span><br><span class="line">                <span class="keyword">while</span>(sum--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;I&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">4</span> &amp;&amp; num &lt; <span class="number">5</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;IV&quot;</span>;</span><br><span class="line">                num %= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">1</span> &amp;&amp; num &lt; <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(a--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;I&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-13：罗马数字转整数"><a href="#Let-13：罗马数字转整数" class="headerlink" title="Let 13：罗马数字转整数"></a>Let 13：罗马数字转整数</h2><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>

<p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code>+ <code>II</code> 。 <code>27</code> 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code>+ <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。</p>
<p><strong>标签：</strong> <code>哈希表</code>  <code>数学</code>  <code>字符串</code></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>

<p><strong>示例 4:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>

<p><strong>示例 5:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 15</code></li>
<li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li>
<li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> value[] = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        string reps[] = &#123;</span><br><span class="line">            <span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i++, j++)&#123;</span><br><span class="line">            string stri = s.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">            string strj = s.<span class="built_in">substr</span>(j, <span class="number">1</span>);</span><br><span class="line">            string str;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">13</span>; k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stri == reps[k]) a = k;</span><br><span class="line">                <span class="keyword">if</span>(strj == reps[k]) b = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b &lt; a)&#123; <span class="comment">// 需要截取两个</span></span><br><span class="line">                str = s.<span class="built_in">substr</span>(i, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">13</span>; k ++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str == reps[k])&#123;</span><br><span class="line">                        res += value[k];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i++; <span class="comment">// 跳过一位</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += value[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-14：最长公共前缀"><a href="#Let-14：最长公共前缀" class="headerlink" title="Let 14：最长公共前缀"></a>Let 14：最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p> <strong>标签：</strong> <code>字符串</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 200</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
<li><code>strs[i]</code> 仅由小写英文字母组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 寻找str 和 fl 最长公共前缀</span></span><br><span class="line">    <span class="function">string <span class="title">Juge</span><span class="params">(string str, string fl)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">min</span>(str.<span class="built_in">length</span>(), fl.<span class="built_in">length</span>());</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i ++)&#123;</span><br><span class="line">            string a = str.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            string b = fl.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span>(a != b &amp;&amp; i == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a != b &amp;&amp; i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                p = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a == b &amp;&amp; i == len)&#123;</span><br><span class="line">                p = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">substr</span>(<span class="number">0</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        string str = strs[<span class="number">0</span>]; <span class="comment">// str 存放最长公共子串;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            str = <span class="built_in">Juge</span>(str, strs[i]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; str &lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(str == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-15：三数之和"><a href="#Let-15：三数之和" class="headerlink" title="Let 15：三数之和"></a>Let 15：三数之和</h2><p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>标签：</strong> <code>数组</code>  <code>双指针</code>  <code>排序</code></p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<p>对数组进行排序后，先确定其中一个值，然后使用双指针确定另外两个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">3</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i ==<span class="number">0</span> || i != <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="type">int</span> a = <span class="number">0</span> - nums[i];</span><br><span class="line">                <span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[l] + nums[r] &lt; a)&#123;</span><br><span class="line">                        l ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[l] + nums[r] &gt; a)&#123;</span><br><span class="line">                        r --;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">                        arr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                        arr.<span class="built_in">push_back</span>(nums[l]);</span><br><span class="line">                        arr.<span class="built_in">push_back</span>(nums[r]);</span><br><span class="line">                        res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">                        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k = l + <span class="number">1</span>; k &lt; r; k++)&#123; <span class="comment">// 往后找到第一个不和左边界相等的点。</span></span><br><span class="line">                            <span class="keyword">if</span>(nums[k] != nums[l])&#123;</span><br><span class="line">                                l = k;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;  <span class="comment">//找到右边界仍然没有找到。</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-16：最接近的三数之和"><a href="#Let-16：最接近的三数之和" class="headerlink" title="Let 16：最接近的三数之和"></a>Let 16：最接近的三数之和</h2><p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
<p><strong>标签：</strong> <code>数组</code>  <code>双指针</code>  <code>排序</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0], target = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = <span class="number">100010</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> cnt = nums[i] + nums[l] + nums[r]; <span class="comment">// 三数之和</span></span><br><span class="line">                cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(cnt - target) &lt; max)&#123; <span class="comment">// 若此时更接近目标值，则更新</span></span><br><span class="line">                    max = <span class="built_in">abs</span>(nums[i] + nums[l] + nums[r] - target);</span><br><span class="line">                    res = cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt; target)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; target)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//刚好等于目标值，则直接输出目标值即可。</span></span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-17：电话号码的字母组合"><a href="#Let-17：电话号码的字母组合" class="headerlink" title="Let 17：电话号码的字母组合"></a>Let 17：电话号码的字母组合</h2><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><strong>标签：</strong> <code>哈希表</code>  <code>字符串</code>  <code>回溯</code></p>
<p> <strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string str[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; digits, <span class="type">int</span> u, string path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u &gt;= digits.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t = digits[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : str[t])&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-18：四数之和"><a href="#Let-18：四数之和" class="headerlink" title="Let 18：四数之和"></a>Let 18：四数之和</h2><p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 互不相同</li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p> 你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>标签：</strong> <code>数组</code>  <code>双指针</code>  <code>排序</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>


<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || i != <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == i + <span class="number">1</span> || j != i + <span class="number">1</span> &amp;&amp; nums[j] != nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="type">int</span> cnt = target - nums[i] - nums[j];</span><br><span class="line">                        <span class="type">int</span> l = j + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums[l] + nums[r] &lt; cnt)&#123;</span><br><span class="line">                                l++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(nums[l] + nums[r] &gt; cnt)&#123;</span><br><span class="line">                                r--;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">                                <span class="comment">// cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;&lt;&lt;nums[j]&lt;&lt;&quot; &quot;&lt;&lt; nums[l]&lt;&lt;&quot; &quot;&lt;&lt;nums[r]&lt;&lt;endl;</span></span><br><span class="line">                                vector&lt;<span class="type">int</span>&gt; arr&#123;nums[i], nums[j], nums[l], nums[r]&#125;;</span><br><span class="line">                                res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">                                <span class="keyword">for</span>(<span class="type">int</span> k = l + <span class="number">1</span>; k &lt; r; k++)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(nums[k] != nums[l])&#123;</span><br><span class="line">                                        l = k;</span><br><span class="line">                                        flag = <span class="literal">true</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// bool flag = false;</span></span><br><span class="line">                        <span class="comment">// for(int k = j + 1; k &lt; nums.size() - 2; k++)&#123;  // 跳转到下一个不重复的地方</span></span><br><span class="line">                        <span class="comment">//     if(nums[k] != nums[j])&#123;</span></span><br><span class="line">                        <span class="comment">//         j = k - 1; // 因为后面还要j++，所以需要先跳转到k-1；</span></span><br><span class="line">                        <span class="comment">//         flag = true;</span></span><br><span class="line">                        <span class="comment">//         break;</span></span><br><span class="line">                        <span class="comment">//     &#125;</span></span><br><span class="line">                        <span class="comment">// &#125;</span></span><br><span class="line">                        <span class="comment">// if(!flag) break;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-19：删除链表的倒数第N个节点"><a href="#Let-19：删除链表的倒数第N个节点" class="headerlink" title="Let  19：删除链表的倒数第N个节点"></a>Let  19：删除链表的倒数第N个节点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>标签：</strong> <code>链表</code>  <code>双指针</code></p>
<p> <strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 sz</li>
<li>1 &lt;&#x3D; sz &lt;&#x3D; 30</li>
<li>0 &lt;&#x3D; Node.val &lt;&#x3D; 100</li>
<li>1 &lt;&#x3D; n &lt;&#x3D; sz</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *k = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            ListNode *p = head;  <span class="comment">// 最后要删除的就是p所指向的节点，他的后继节点就是k</span></span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next != k)&#123;</span><br><span class="line">                p = p -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            k = p;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">if</span>(p == k)&#123;</span><br><span class="line">            head = k -&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p -&gt; next != k)&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = k-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Let-20：有效的括号"><a href="#Let-20：有效的括号" class="headerlink" title="Let 20：有效的括号"></a>Let 20：有效的括号</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<p><strong>标签：</strong> <code>栈</code>  <code>字符串</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p><strong>示例 5：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123; <span class="comment">//匹配到左括号</span></span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;  <span class="comment">//栈内有左括号</span></span><br><span class="line">                <span class="type">char</span> c = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s[i] == <span class="string">&#x27;]&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s[i] == <span class="string">&#x27;&#125;&#x27;</span> || c == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;  <span class="comment">//栈内已经没有左括号了，但是来了右括号。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sta.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123; <span class="comment">// 还有左括号未匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>AcWing</tag>
        <tag>Algorithm</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础入门 阶段1 &amp; 阶段2</title>
    <url>/2022/04/18/JAVA/01JavaBasic/</url>
    <content><![CDATA[<h1 id="JAVA程序执行过程"><a href="#JAVA程序执行过程" class="headerlink" title="JAVA程序执行过程"></a>JAVA程序执行过程</h1><ul>
<li>编写<code>Hello.java</code>类，</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;  <span class="comment">// 定义类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  <span class="comment">// 主函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);  <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过编译生成<code>Hello.class</code>文件，(字节码文件)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac Hello.java</span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>JVM(java 虚拟机)</code>运行生成结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java Hello  <span class="comment"># 实际在运行Hello.class，但是不写后缀</span></span><br></pre></td></tr></table></figure>

<h2 id="JAVA类编写注意事项"><a href="#JAVA类编写注意事项" class="headerlink" title="JAVA类编写注意事项"></a>JAVA类编写注意事项</h2><ul>
<li>一个源文件中最多只能有一个<code>public 类</code>，其他类的个数不限。</li>
<li>如果一个文件中包含<code>public 类</code>，则文件名必须和该类同名。</li>
</ul>
<h1 id="JAVA转义字符"><a href="#JAVA转义字符" class="headerlink" title="JAVA转义字符"></a>JAVA转义字符</h1><ul>
<li>JAVA中常用的转义字符：</li>
</ul>
<table>
<thead>
<tr>
<th>换行符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符，实现对齐</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>一个回车</td>
</tr>
</tbody></table>
<h1 id="JAVA注释"><a href="#JAVA注释" class="headerlink" title="JAVA注释"></a>JAVA注释</h1><ul>
<li>单行注释</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br></pre></td></tr></table></figure>

<ul>
<li>多行注释</li>
</ul>
<p>多行注释不允许嵌套多行注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这是多行注释</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<ul>
<li>文档注释</li>
</ul>
<p>里面是java doc标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 177411</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h1 id="JAVA变量"><a href="#JAVA变量" class="headerlink" title="JAVA变量"></a>JAVA变量</h1><p>变量是程序的基本组成单位，有三要素（类型 + 名称 + 值），变量表示内存中的一个存储区域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;  <span class="comment">// 声明变量</span></span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">// 变量赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 声明赋值合并</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><ul>
<li><code>int</code> 整型，占4字节</li>
<li><code>double</code> 双精度浮点类型，占8字节</li>
<li><code>char</code> 字符型，占2字节</li>
<li><code>String</code> 字符串类型，</li>
</ul>
<h1 id="JAVA数据类型-⭐"><a href="#JAVA数据类型-⭐" class="headerlink" title="JAVA数据类型 ⭐"></a>JAVA数据类型 ⭐</h1><p>java 中定义数据必须指定明确的数据类型，可以看出java 是<strong>强类型语言</strong></p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li>数值型<ul>
<li>整数类型，存放整数<code>byte[1], short[2], int[4], long[8]</code></li>
<li>浮点(小数)类型<code>float[4], double[8]</code></li>
</ul>
</li>
<li>字符型<code>char[2]</code>，存放单个字符</li>
<li>布尔型<code>boolean[1]</code></li>
</ul>
<h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>类型不同带来的是占用存储空间不同，进而带来的是数值范围不同。1个字节等于8位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 4字节</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 8字节</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">1F</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><ul>
<li>浮点数 &#x3D; 符号位 + 指数位 + 尾数位</li>
<li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li>
</ul>
<p>陷阱：</p>
<p><code>2.7</code> 和 <code>8.1 / 3</code> 不相等，<code>8.1 / 3</code> 是接近<code>2.7</code>的小数，而不是<code>2.7</code>。所以需要判断时，应该是以两个数的差值的绝对值，在某个精度范围内进行判断。</p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul>
<li>必须用单引号<code>&#39;&#39;</code></li>
<li>允许使用转义字符<code>\</code></li>
<li>允许进行运算  <code>&#39;a&#39; - &#39;a&#39;</code></li>
<li>字符型存储到计算机中，需要将对应的码值(整数)找出来进行存储。</li>
<li>字符和整数的对应关系是通过字符编码表决定的，是规定好的。</li>
</ul>
<h3 id="基本数据类型的转换"><a href="#基本数据类型的转换" class="headerlink" title="基本数据类型的转换"></a>基本数据类型的转换</h3><p><strong>自动类型转换</strong></p>
<ul>
<li><strong>精度小的类型自动转换为精度大的数据类型。</strong> </li>
<li><code>char &lt; int &lt; long &lt; float &lt; double</code></li>
<li><code>byte &lt; short &lt; int &lt; long &lt; float &lt; double</code></li>
</ul>
<p>注意：</p>
<ol>
<li>有多种类型的数据类型进行混合运算时，系统首先将所有类型转为容量大的类型，然后再进行计算。</li>
<li>把容量大的数据类型赋值给容量小的数据类型时，会报错，反之则会进行自动类型转换。</li>
<li><code>（byte, short）</code>和 <code>char</code> 之间不会自动转换。</li>
</ol>
<p><strong>强制类型转换</strong></p>
<p>将容量大的类型转换为容量小的数据类型。使用时需要加上强制转换符<code>()</code>，但可能造成精度降低或溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForceConvert</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1.9</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基本数据类型和String类型的转换"><a href="#基本数据类型和String类型的转换" class="headerlink" title="基本数据类型和String类型的转换"></a>基本数据类型和String类型的转换</h3><ul>
<li>基本类型转String类型：<code>基本类型值 + &quot;&quot;</code></li>
<li>String类型转基本类型：通过基本数据类型的包装类调用<code>parseXXX</code>进行转换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBasic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line">        str = <span class="string">&quot;89.0&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> Double.parseDouble(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> Float.parseFloat(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> <span class="variable">d</span> <span class="operator">=</span> Short.parseShort(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> Long.parseLong(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">fl</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>在将String类型转换为基本数据类型时，需要确保String类型能够转换为有效的数据。如果格式不正确，则会抛出异常，程序就会终止。</li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ul>
<li>类<code>class</code>，例如<code>String</code></li>
<li>接口<code>interface</code></li>
<li>数组<code>[]</code></li>
</ul>
<h1 id="JAVA-API文档"><a href="#JAVA-API文档" class="headerlink" title="JAVA API文档"></a>JAVA API文档</h1><p><a href="https://www.matools.com/api/java8">中文在线文档</a> </p>
<p><code>JDK &gt; Packages &gt; Interfaces + class + Exceptions &gt; function</code></p>
<h1 id="JAVA-算数运算符"><a href="#JAVA-算数运算符" class="headerlink" title="JAVA 算数运算符"></a>JAVA 算数运算符</h1><p>运算符是一种特殊的符号，用于表示数据的运算，赋值和比较。</p>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">运算</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">正号</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">负号</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">加</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">减</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">乘</td>
</tr>
<tr>
<td align="center">&#x2F;</td>
<td align="center">除</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取模（取余）</td>
</tr>
<tr>
<td align="center">++</td>
<td align="center">自增</td>
</tr>
<tr>
<td align="center">–</td>
<td align="center">自减</td>
</tr>
<tr>
<td align="center">+</td>
<td align="center">字符串相加</td>
</tr>
</tbody></table>
<h2 id="加号"><a href="#加号" class="headerlink" title="加号"></a>加号</h2><ul>
<li>当左右两边都是数值类型，则做加法。</li>
<li>当左右两边有一方是字符串类型，则做拼接。</li>
<li>运算顺序，从左到右，右括号除外。</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>基本赋值运算符：<code>=</code></p>
<p>复合运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%= </code>。</p>
<h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符的结果都是<code>boolean</code> 类型</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">运算</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&#x3D;&#x3D;</td>
<td align="center">相等于</td>
</tr>
<tr>
<td align="center">!&#x3D;</td>
<td align="center">不等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td align="center">小于</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td align="center">大于</td>
</tr>
<tr>
<td align="center">&lt;&#x3D;</td>
<td align="center">小于等于</td>
</tr>
<tr>
<td align="center">&gt;&#x3D;</td>
<td align="center">大于等于</td>
</tr>
<tr>
<td align="center">instanceof</td>
<td align="center">检查是否是类的对象</td>
</tr>
</tbody></table>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>用于连接多个条件（多个关系表达式），最终的结果也是一个<code>boolean</code>值</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a&amp;b</th>
<th align="center">a&amp;&amp;b</th>
<th align="center">a|b</th>
<th align="center">a||b</th>
<th align="center">!a</th>
<th align="center">a^b(异或)</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">F</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">F</td>
<td align="center">T</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">T</td>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">T</td>
<td align="center">T</td>
</tr>
<tr>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">F</td>
<td align="center">T</td>
<td align="center">F</td>
</tr>
</tbody></table>
<p><strong>&amp;&amp;和&amp;的区别</strong></p>
<ul>
<li><code>&amp;&amp;</code>当第一个条件为<code>false</code>时，不再判断第二个条件。效率高。</li>
<li><code>&amp;</code>当第一个条件为<code>false</code>时，仍需判断第二个条件。效率低。</li>
<li>同理 <code>||</code> 和<code>|</code> 的区别也是如此</li>
</ul>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">运算</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">按位与</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">按位或</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">按位取反</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">按位异或</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">算数右移，地位溢出，符号位不变，并用符号位补溢出的高位</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">算数左移，符号位不变，低位补</td>
</tr>
<tr>
<td align="center">&gt;&gt;&gt;</td>
<td align="center">逻辑右移</td>
</tr>
</tbody></table>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2</code></p>
<ul>
<li>如果条件表达式结果为<code>true</code>，运算后的结果是表达式1；</li>
<li>如果条件表达式结果为<code>false</code>，运算后的结果是表达式2；</li>
</ul>
<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p><strong>命名规则：（必须遵守）</strong></p>
<ul>
<li>由26个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头，</li>
<li>不可以使用关键字或保留字，但能包含关键字或保留字</li>
<li>严格区分大小写，长度无限制。</li>
<li>不能含有空格。</li>
</ul>
<p><strong>命名规范</strong></p>
<ul>
<li>包名：多个单词组成时所有字母都是小写。</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写。</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始后的所有单词首字母大写。</li>
<li>常量名：所有字母都大写。多单词时，每个单词用下划线连接。</li>
</ul>
<h1 id="键盘输入语句"><a href="#键盘输入语句" class="headerlink" title="键盘输入语句"></a>键盘输入语句</h1><p>导入<code>java.util.Scanner</code>包，创建<code>Scanner</code>对象，调用方法进行输入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Input</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner 对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入名字&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> myScanner.next(); <span class="comment">// 接收用户的输入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> myScanner.nextInt();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><ul>
<li>二进制：以<code>0b</code>或<code>0B</code>开头</li>
<li>十进制：</li>
<li>八进制：以数字<code>0</code>开头</li>
<li>十六进制：以<code>0x</code>或<code>0X</code>开头表示。</li>
</ul>
<h2 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h2><h3 id="其他进制转十进制"><a href="#其他进制转十进制" class="headerlink" title="其他进制转十进制"></a>其他进制转十进制</h3><ul>
<li>二进制转十进制</li>
</ul>
<p>从最低位(右边)开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和。</p>
<ul>
<li>八进制转十进制</li>
</ul>
<p>从最低位(右边)开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。</p>
<ul>
<li>十六进制转十进制</li>
</ul>
<p>从最低位(右边)开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和。</p>
<h3 id="十进制转其他进制"><a href="#十进制转其他进制" class="headerlink" title="十进制转其他进制"></a>十进制转其他进制</h3><ul>
<li>十进制转二进制</li>
</ul>
<p>将该数不断除以2，指导商为0为止，然后将每步得到的余数倒过来。就是对应的二进制。</p>
<ul>
<li>十进制转八进制</li>
</ul>
<p>将该数不断除以8，指导商为0为止，然后将每步得到的余数倒过来。就是对应的八进制。</p>
<ul>
<li>十进制转十六进制</li>
</ul>
<p>将该数不断除以16，指导商为0为止，然后将每步得到的余数倒过来。就是对应的十六进制。</p>
<h3 id="其他进制相互转换"><a href="#其他进制相互转换" class="headerlink" title="其他进制相互转换"></a>其他进制相互转换</h3><ul>
<li>二进制转八进制</li>
</ul>
<p>从低位开始，将二进制数每三位一组，转成对应的八进制数即可。</p>
<ul>
<li>二进制转十六进制</li>
</ul>
<p>从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。</p>
<ul>
<li>八进制转二进制</li>
</ul>
<p>将八进制数的每一位转成对应的一个3位的二进制数即可。</p>
<ul>
<li>十六进制转二进制</li>
</ul>
<p>将十六进制数的每一位转成对应的一个4位的二进制数即可。</p>
<h1 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h1><h2 id="顺序控制"><a href="#顺序控制" class="headerlink" title="顺序控制"></a>顺序控制</h2><p>程序从上到下逐行执行，中间没有任何判断和跳转。</p>
<h2 id="分支控制"><a href="#分支控制" class="headerlink" title="分支控制"></a>分支控制</h2><ul>
<li><code>if...else if...if...</code></li>
<li><code>switch...case...default...</code></li>
</ul>
<h2 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h2><ul>
<li><code>for(循环变量初始化; 循环条件; 循环变量迭代) &#123; 循环体 &#125;</code></li>
<li><code>while(循环条件) &#123; 循环体; 循环变量迭代&#125;</code></li>
<li><code>do&#123; 循环体; 循环变量迭代&#125; while(循环条件)</code></li>
</ul>
<h2 id="跳转控制"><a href="#跳转控制" class="headerlink" title="跳转控制"></a>跳转控制</h2><ul>
<li><code>break</code>：结束最近的一层循环，推出该层循环</li>
<li><code>continue</code>：结束本次循环，继续下一层循环</li>
<li><code>return</code>：表示跳出所在方法</li>
</ul>
<h1 id="数组、排序、查找"><a href="#数组、排序、查找" class="headerlink" title="数组、排序、查找"></a>数组、排序、查找</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组可以存放<code>多个</code> <code>同一类型</code> 数据，数组也是一种数据类型，是引用类型。</p>
<p>数组下标是从0开始编号的。</p>
<h3 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h3><ul>
<li><p>动态初始化：<code>数组类型 数组名[] = new 数据类型[大小]</code></p>
</li>
<li><p>动态初始化，先声明，在创建。</p>
</li>
<li><p>静态初始化，<code>数据类型 数组名[] = &#123;元素值, 元素值, ...&#125;</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 动态初始化数组</span></span><br><span class="line">        <span class="type">int</span> num[];</span><br><span class="line">        num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 先声明，再分配</span></span><br><span class="line">        <span class="type">int</span> q[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 静态初始化数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的注意事项"><a href="#数组的注意事项" class="headerlink" title="数组的注意事项"></a>数组的注意事项</h3><ul>
<li>数组内的元素必须是相同类型，</li>
<li>数组中的元素类型可以是任何数据类型，包括基本数据类型或引用数据类型，但不能混。</li>
<li>数组创建后，没有赋值，有默认值。</li>
<li>数组下标是从0开始的。</li>
<li>数组下标必须在指定范围内使用。</li>
<li>数组属于引用类型，数组型数据是对象(object)。</li>
</ul>
<h3 id="数组的赋值机制"><a href="#数组的赋值机制" class="headerlink" title="数组的赋值机制"></a>数组的赋值机制</h3><ul>
<li>基本数据类型赋值，这个值就是具体的数据，而且相互不影响。</li>
<li><strong>数组在默认情况下，是阴影传递，赋的值是地址。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span> num[] = arr; <span class="comment">// 引用赋值，此时num发生变化，则arr会发生变化。</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">       	<span class="type">int</span> <span class="variable">arr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];  <span class="comment">// 数组拷贝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i ++)&#123;</span><br><span class="line">            arr2[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>每次冒泡都将最大的数找出，并移动到后面。</p>
<ul>
<li>需要进行<code>arr.length - 1</code> 轮排序。</li>
<li>第<code>i</code>轮排序需要确定第<code>i</code>大数的位置。</li>
<li>每轮比较依次减少<code>i</code>次比较。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">26</span>, <span class="number">90</span>, <span class="number">86</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">72</span>, <span class="number">16</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = i; i &lt; arr.length; i ++) &#123;  <span class="comment">// 需要进行 arr.length - 1 次</span></span><br><span class="line">            <span class="comment">// 每次需要比较 arr.length - i - 1次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123; </span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;  <span class="comment">// 如果当前数比后一个数大，则进行交换</span></span><br><span class="line">                    <span class="type">int</span> a = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul>
<li>顺序查找：用目标值依次和数组中的元素进行比较，若相等，则查找到，若遍历结束仍没有找到，则不存在。</li>
<li>二分查找，需要保证原数组是有序的。</li>
</ul>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ul>
<li>动态初始化：<code>类型 数组名[][] = new 类型[大小][大小]</code></li>
<li>动态初始化：先声明，在分配空间</li>
<li>动态初始化：列数不确定</li>
<li>静态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// 动态初始化数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> num[][];</span><br><span class="line">        num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">// 先声明，再分配</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]; <span class="comment">// 列数不确定</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i ++)&#123; <span class="comment">// 给列分配空间。</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> q[][] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;; <span class="comment">// 静态初始化数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><ul>
<li>类：就是数据类型，例如Cat</li>
<li>对象：就是一个具体的实例，<code>对象[属性, 行为]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">cat</span>();  <span class="comment">// 对象</span></span><br><span class="line">        cat1.name = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line">        cat1.age = <span class="number">20</span>;</span><br><span class="line">        cat1.color = <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> cat1.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>&#123; <span class="comment">// 类</span></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p><code>属性</code>也叫<code>成员变量</code>，也叫<code>field(字段)</code></p>
<ul>
<li>属性是类的一个组成部分，一般是数据类型，也可以是引用类型。</li>
</ul>
<p><strong>属性的定义方法：</strong></p>
<p><code>访问修饰符 属性类型 属性名</code></p>
<p>访问修饰符包括：<code>public</code>，<code>private</code>， <code>protected</code>，默认为<code>public</code></p>
<h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>某个类中的函数就是该类的成员方法或者叫成员函数。</p>
<p><strong>成员方法的定义：</strong></p>
<p><code>访问修饰符 返回类型 方法名(形参列表) &#123; 函数体 ; return 返回值;&#125;</code></p>
<ul>
<li>形参列表：代表成员方法的输入。</li>
<li>返回类型：表示成员方法的输出，若为<code>void</code>，则没有返回值</li>
<li><code>return</code>不是必须的</li>
</ul>
<p><strong>传参机制</strong></p>
<ul>
<li>值传递；方法运行后不会影响实参的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引用数据传递：接收数组，传递的是地址。</li>
</ul>
<p><strong>方法的递归调用</strong></p>
<ul>
<li>直接递归：方法自己本身直接调用自己。</li>
<li>简介递归</li>
</ul>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>JAVA允许在同一个类中的成员方法中，有多个重名函数存在，但是要求形参列表不一样！</p>
<p><strong>重载的优点</strong></p>
<ul>
<li>减轻了起名的麻烦</li>
<li>减轻了记名的麻烦</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverLoad01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCaculate</span> <span class="variable">myCaculate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCaculate</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">caculate</span> <span class="operator">=</span> myCaculate.Caculate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">caculate1</span> <span class="operator">=</span> myCaculate.Caculate(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">caculate2</span> <span class="operator">=</span> myCaculate.Caculate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCaculate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Caculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Caculate</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Caculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>方法名必须一样</li>
<li>形参列表必须不同，形参类型不同 或者 个数不同 或者 顺序不同。</li>
<li>参数名没有要求</li>
<li>返回类型无要求，返回类型不是构成方法重载的条件。</li>
</ul>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>JAVA允许将同一个类中多个同名同功能但参数个数不同的方法，封装成同一个方法。</p>
<p><code>for(参数类型... 参数名)</code>，此时参数名可以当做数组使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarParameter01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HspMethod hspMethod=<span class="keyword">new</span> <span class="title class_">HspMethod</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> hspMethod.sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> hspMethod.sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HspMethod</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;  <span class="comment">// 可以接受int类型的多个参数，可以将nums当作数组使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cun</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            cun += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>可变参数的实参可以直接是数组</li>
<li>可变参数的实参可以是0个或多个</li>
<li><strong>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</strong></li>
<li><strong>一个形参列表只能出现一个可变参数</strong></li>
</ul>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>包括<strong>局部变量</strong>或者<strong>全局变量</strong></p>
<ul>
<li>局部变量：定义在某一个成员方法中的变量 或定义在某一个代码块中 。作用域仅在该成员方法中 或 该代码块中。</li>
<li>全局变量：直接定义在类中的变量，属性就是全局变量，在该类中的任何成员方法中都可以直接使用。作用域在整个类中。</li>
<li>全局变量可以不用赋值，有默认值，局部变量必须赋值后才可以使用，不会有默认值。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>属性和局部变量可以重名，使用时遵守<code>就近原则</code> </li>
<li>在同一个作用域内，两个局部变量不能重名</li>
<li>属性声明周期比较长，局部变量声明周期相对比较短</li>
</ul>
<p><strong>作用域范围</strong></p>
<ul>
<li>属性：可以被本类所有成员方法使用，也可以通过对象调用被其他类使用。</li>
<li>局部变量：只能在本成员方法中使用。</li>
</ul>
<p><strong>修饰符</strong></p>
<ul>
<li>属性：可以添加修饰符</li>
<li>局部变量：不可以添加修饰符</li>
</ul>
<h2 id="构造方法-x2F-构造器"><a href="#构造方法-x2F-构造器" class="headerlink" title="构造方法&#x2F;构造器"></a>构造方法&#x2F;构造器</h2><p><strong>基本语法：</strong><code>[修饰符] 方法名(形参列表) &#123; 方法体; &#125;</code></p>
<p><strong>作用：</strong>在创建对象时，实现对对象的初始化。</p>
<ul>
<li>构造器的修饰符可以是默认的也可以是其他的。</li>
<li>构造器没有返回值</li>
<li>方法名和类名必须保持一致</li>
<li>构造器的调用是由系统完成的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xzt&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(person.name + <span class="string">&quot;的年龄为&quot;</span> + person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Person() &#123;  <span class="comment">// 默认构造函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age) &#123;  <span class="comment">// 重写构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>一个类可以构造多个构造器，即构造器的重载</li>
<li>若没有自定义构造器，则系统会自动给类生成一个默认无参构造器，但是若定义了一个新的构造器，则不会再自动生成一个默认无参构造器。</li>
</ul>
<h2 id="对象创建流程"><a href="#对象创建流程" class="headerlink" title="对象创建流程"></a>对象创建流程</h2><ul>
<li>加载类信息，只会加载一次</li>
<li>在堆中分配空间（地址）</li>
<li>完成对象初始化，<ul>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器初始化</li>
</ul>
</li>
<li>在对象堆中的地址，返回给创建的对象</li>
</ul>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p><code>java</code>虚拟机给每个对象分配<code>this</code>，代表当前对象。</p>
<p><strong>作用：</strong>在成员方法中，<code>this</code>主要用在当形参和属性名同名时，使用<code>this.属性名</code>代替属性名，来区分同名问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xzt&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(person.name + <span class="string">&quot;的年龄为&quot;</span> + person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Person() &#123;  <span class="comment">// 默认构造函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age) &#123;  <span class="comment">// 重写构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age; <span class="comment">// 此时使用this.age 代替属性age</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本质</strong>：哪个对象调用，<code>this</code>就代表哪个对象</p>
<p><strong>注意事项</strong></p>
<ul>
<li><code>this</code>可以访问本类的属性、方法、构造器</li>
<li><code>this</code>用于区分当前类的属性和局部变量</li>
<li>访问成员方法时语法：<code>this.方法名(参数列表)</code></li>
<li>访问构造器语法：<code>this(参数列表)</code>；注意只能在构造器中使用</li>
<li><code>this</code>不能再类定义的外部使用，只能再类定义的方法中使用</li>
</ul>
<h1 id="Intellij-IDEA"><a href="#Intellij-IDEA" class="headerlink" title="Intellij IDEA"></a>Intellij IDEA</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><table>
<thead>
<tr>
<th align="center">功能描述</th>
<th align="center">快捷键</th>
</tr>
</thead>
<tbody><tr>
<td align="center">删除当前行</td>
<td align="center"><code>ctrl + y</code></td>
</tr>
<tr>
<td align="center">复制当前行</td>
<td align="center"><code>ctrl + d</code></td>
</tr>
<tr>
<td align="center">代码格式化</td>
<td align="center"><code>ctrl + alt + L</code></td>
</tr>
<tr>
<td align="center">补全代码</td>
<td align="center">补全代码：<code>alt + /</code></td>
</tr>
<tr>
<td align="center">单行注释</td>
<td align="center"><code>ctrl + /</code></td>
</tr>
<tr>
<td align="center">多行注释</td>
<td align="center"><code>ctrl + shift + /</code></td>
</tr>
<tr>
<td align="center">显示错误</td>
<td align="center"><code>alt + Enter</code></td>
</tr>
<tr>
<td align="center">快速运行代码</td>
<td align="center"><code>ctrl + shift + F10</code></td>
</tr>
<tr>
<td align="center">生成构造器、get函数、set函数</td>
<td align="center"><code>alt + insert</code></td>
</tr>
<tr>
<td align="center">查看类的继承关系</td>
<td align="center"><code>ctrl + h</code></td>
</tr>
<tr>
<td align="center">定位到定义的方法</td>
<td align="center"><code>ctrl + b</code></td>
</tr>
<tr>
<td align="center">自动分配变量名</td>
<td align="center">在后面加<code>.var</code></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>查看模板：<code>file -&gt; settings -&gt; editor -&gt; Live templates -&gt; Java</code>，可以自定义自己的模板</p>
<table>
<thead>
<tr>
<th align="center">功能描述</th>
<th align="center">快捷键</th>
</tr>
</thead>
<tbody><tr>
<td align="center">主函数</td>
<td align="center"><code>main + enter</code></td>
</tr>
<tr>
<td align="center">输出语句</td>
<td align="center"><code>sout + enter</code></td>
</tr>
<tr>
<td align="center">for循环语句</td>
<td align="center"><code>fori + enter</code></td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<h1 id="面向对象编程（中）"><a href="#面向对象编程（中）" class="headerlink" title="面向对象编程（中）"></a>面向对象编程（中）</h1><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p><strong>作用</strong></p>
<ul>
<li>可以区分相同名字的类</li>
<li>当类很多时，可以很好的管理类</li>
<li>控制访问范围</li>
</ul>
<p><strong>基本语法</strong>：<code>package.com.constructor</code></p>
<ul>
<li><code>package</code> 关键字，表示打包</li>
<li><code>com.constructor</code> 表示包名</li>
</ul>
<p><strong>原理：</strong> 创建不同的文件夹来保存类文件。</p>
<p><strong>命名规则</strong></p>
<ul>
<li>只能包含数字、字母、下划线、小圆点，但不能以数字开头，不能是数字或保留字</li>
</ul>
<p><strong>命名规范</strong></p>
<ul>
<li>一般是小写字母 + 小圆点，一般是<code>com.公司名.项目名.业务模块名</code></li>
</ul>
<h3 id="常用的包"><a href="#常用的包" class="headerlink" title="常用的包"></a>常用的包</h3><ul>
<li><code>java.lang.*</code> 默认引入，不需要再引入。例如<code>Mathl类</code></li>
<li><code>java.util.*</code> 系统提供的工具包，工具类，使用<code>Scanner</code></li>
<li><code>java.net.*</code> 网路包，网络开发</li>
<li><code>java.awt.*</code> Java界面开发，GUI</li>
</ul>
<h3 id="导入包"><a href="#导入包" class="headerlink" title="导入包"></a>导入包</h3><p>基本语法：<code>import 包</code>，引入一个包的目的是使用该包下面的类。</p>
<ul>
<li><code>package</code>的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一个<code>package</code></li>
<li><code>import</code> 放在<code>package</code>和类之间，可以有多条且顺序没有要求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pkg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 只会导入java.util下面的Scanner类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;  <span class="comment">// 导入java.util包下面的所有类， 不建议使用</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Import01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;-<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i ++)&#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>java提供四种访问修饰控制符，用于控制方法和属性（成员变量）的访问权限。</p>
<ul>
<li>公开级别：<code>public</code> 修饰，对外公开</li>
<li>受保护级别：<code>protected</code> 修饰，对子类和同一个包中的类公开</li>
<li>默认级别：没有修饰符，向同一个包的类公开，对子类不能访问</li>
<li>私有级别：<code>private</code> 修饰，只有类本身可以访问，不对外公开</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>修饰符可以用来修饰类中的属性，成员方法以及类</li>
<li>只有默认的和<code>public</code>才可以修饰类</li>
</ul>
<h2 id="三大特征-⭐"><a href="#三大特征-⭐" class="headerlink" title="三大特征 ⭐"></a>三大特征 ⭐</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p><strong>定义：</strong> 把抽象出来数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。</p>
<p><strong>优点</strong></p>
<ul>
<li>隐藏实现细节，直接调用即可</li>
<li>可以对数据进行验证，保证安全合理</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>将属性私有化</li>
<li>提供一个<code>public 的 set</code>方法，对属性判断并赋值</li>
<li>提供一个<code>public 的 get</code>方法，用于获得属性值</li>
</ol>
<p>当使用构造器对属性赋值时，构造器函数体的编写方法需要进行改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.encapsulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encapsulation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;xzt&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">200</span>);</span><br><span class="line">        person.setSalary(<span class="number">30000</span>);</span><br><span class="line">        System.out.println(person.info());</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">smith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;smith&quot;</span>, <span class="number">30</span>, <span class="number">15000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有三个属性的构造器 并进行重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        setName(name);</span><br><span class="line">        setAge(age);</span><br><span class="line">        setSalary(salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快捷键 alt + insert</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &gt;= <span class="number">1</span> &amp;&amp; age &lt;= <span class="number">120</span>)</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄需要在1~120之间&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;信息为：名字是 &quot;</span> + getName() + <span class="string">&quot;, 年龄是：&quot;</span> + getAge() + <span class="string">&quot;，工资是：&quot;</span> + getSalary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p><strong>定义：</strong> 当两个类中有很多属性和方法是相同的，则可以使用继承来减少代码复用。</p>
<p><strong>基本语法：</strong> </p>
<p><code>class 子类名 extends 父类名 &#123;&#125;</code></p>
<ul>
<li>子类会自动拥有父类定义的属性和方法</li>
<li>父类又叫超类或者基类</li>
<li>子类又叫派生类</li>
</ul>
<p><strong>优点：</strong> 代码的复用性、扩展性、维护性都得到很大提升</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>子类继承了所有的属性和方法，但是私有属性不能在子类中直接访问，要通过公共的方法去访问。</li>
<li><strong>子类必须调用父类的构造器，完成父类的初始化。</strong> 在子类的构造函数中会默认调用<code>super()</code>函数</li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器，如果父类中没有提供无参构造器，则必须在子类的构造器中用<code>super()</code>去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。</li>
<li>如果希望指定去调用父类的某个构造器，则显示的调用一下，<code>super(参数列表)</code></li>
<li><code>super()</code> 在使用时，需要放在构造器的第一行（<code>super()</code>只能在构造器中使用）</li>
<li><code>super()</code> 和 <code>this()</code> 都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器</li>
<li>java所有类时<code>Object类</code>的子类，<code>Object类</code>是所有类的基类</li>
<li>父类构造器的调用不限于直接父类。将一直往上追溯直到<code>Object类</code>（顶级父类）</li>
<li>子类最多只能继承一个父类（指直接继承），即<strong>java中是单继承机制</strong></li>
<li>不能滥用继承，子类和父类之间必须满足<code>is-a</code>的逻辑关系（子类是父类中的一类）</li>
</ul>
<p><strong>super关键字：</strong> <code>super()</code> 代表父类的引用，用于访问父类的属性，方法，构造器。</p>
<ul>
<li>访问父类的属性&#x2F;方法，但不能访问<code>private</code>私有属性&#x2F;方法，<code>super.属性名</code></li>
<li>访问父类的构造器，<code>super(参数列表)</code>只能放在构造器的第一行</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>调用父类构造器，分工明确，父类属性由父类初始化，子类的属性由子类初始化</li>
<li>当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过<code>super</code>关键字。</li>
<li>若多个上级类都有同名，则<code>super</code>访问遵循就近原则</li>
</ul>
<p><code>super</code>和<code>this</code><strong>的比较</strong></p>
<table>
<thead>
<tr>
<th align="center">No.</th>
<th align="center">区别点</th>
<th align="center">this</th>
<th align="center">super</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">访问属性</td>
<td align="center">访问本类中的属性，若本类中没有此属性，则从父类中继续查找</td>
<td align="center">访问父类中的属性</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">调查方法</td>
<td align="center">访问本类中的方法，若本类中没有此方法，则从父类中继续查找</td>
<td align="center">访问父类中的方法</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">调用构造器</td>
<td align="center">调用本类的构造器，必须放在构造器首行</td>
<td align="center">调用父类的构造器，必须放在子类构造器的首行</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">特殊</td>
<td align="center">表示当前对象</td>
<td align="center">子类中访问父类对象</td>
</tr>
</tbody></table>
<h4 id="方法重写-x2F-覆盖"><a href="#方法重写-x2F-覆盖" class="headerlink" title="方法重写&#x2F;覆盖"></a>方法重写&#x2F;覆盖</h4><p>方法重写就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么就说子类的这个方法覆盖了父类的方法。</p>
<p><strong>注意事项</strong></p>
<ul>
<li>子类的方法的参数、方法名称要和父类方法的参数、名称完全一样</li>
<li>子类的方法的返回类型要和父类方法的返回类型一样，或者是父类返回类型的子类。例如：父类返回类型为<code>Object</code>,子类方法的返回类型可以是<code>String</code>。</li>
<li>子类方法不能缩小父类方法的访问权限：<code>public &gt; protected &gt; 默认 &gt; private</code></li>
</ul>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承的基础之上的。</p>
<p><strong>作用：</strong> 提高代码的复用性</p>
<ul>
<li>方法的多态：方法的<code>重载 和 重写</code>就体现多态</li>
<li><strong>对象的多态：【核心】</strong><ul>
<li><strong>一个对象的编译类型和运行类型可以不一致。</strong>例如：<code>Animal animal = new Dog()</code>；可以让一个父类的引用指向子类的对象。<code>animal</code>的编译类型是<code>Animal</code>，运行类型是<code>Dog</code></li>
<li>编译类型在定义对象时，就确定了，不能改变</li>
<li>运行类型是可以变化的。</li>
<li>编译类型看定义时 <code>=</code> 左边，运行类型看 <code>=</code> 右边。</li>
</ul>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>两个类存在继承关系</li>
<li>多态是向上转型<ul>
<li>本质：父类的引用指向子类对象</li>
<li>语法：<code>父类类型 引用名 = new 子类类型()</code></li>
<li>特点：编译类型看左边，运行类型看右边</li>
</ul>
</li>
<li>多态的向下转型<ul>
<li>语法：<code>子类类型 引用名 = (子类类型) 父类引用</code>；</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>可以调用子类类型中所有的成员日</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 向上转型</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal; <span class="comment">// 向下转型</span></span><br><span class="line"></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal; <span class="comment">// 错误，animal原来是Dog类型，不能转为cat</span></span><br></pre></td></tr></table></figure>

<p><strong>属性重写：</strong> </p>
<ul>
<li>属性没有重写之说，属性的值看编译类型。</li>
<li><code>instanceof</code> 比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(base.count); <span class="comment">// 10，看编译类型</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(base <span class="keyword">instanceof</span> Sub); <span class="comment">// True</span></span><br><span class="line">        System.out.println(base <span class="keyword">instanceof</span> Base); <span class="comment">// True</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(sub <span class="keyword">instanceof</span> Sub); <span class="comment">// True</span></span><br><span class="line">        System.out.println(sub <span class="keyword">instanceof</span> Base); <span class="comment">// True</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java动态绑定机制-⭐"><a href="#java动态绑定机制-⭐" class="headerlink" title="java动态绑定机制 ⭐"></a>java动态绑定机制 ⭐</h4><ul>
<li>Java重要特性：<code>动态绑定机制</code></li>
<li>当调用对象方法的时候，该方法会和该对象的内存地址&#x2F;运行类型绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.poly._dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum()); <span class="comment">// 30  动态绑定机制，所以调用父类的sum，所以 getI()是B的为20  20 + 10</span></span><br><span class="line">        System.out.println(a.sum1()); <span class="comment">// 20  属性没有动态绑定机制，所以调用父类的sum1，所以 i为10  10 + 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    public int sum()&#123;</span></span><br><span class="line">    <span class="comment">//        return getI() + 20;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    public int sum1()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多态的应用"><a href="#多态的应用" class="headerlink" title="多态的应用"></a>多态的应用</h4><ul>
<li>多态数组：数组的定义类型为父类型，里面保存的实际元素类型为子类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tes</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Person[] person =  <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        Person[<span class="number">0</span>] = student;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        Person[<span class="number">1</span>] = teacher;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; person.length; i++)&#123;</span><br><span class="line">            <span class="comment">//person[i] 编译类型是Person，运行类型是根据实际情况由JVN来判断</span></span><br><span class="line">            System.out.println(person[i].say());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 因为teach() 和study() 不存在于Person类中，所以需要判断后进行向下强转</span></span><br><span class="line">            <span class="keyword">if</span>(person[i] <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">                <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) person[i];</span><br><span class="line">                s.study();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(person[i] <span class="keyword">instanceof</span> Teacher)&#123;</span><br><span class="line">                ((Teacher) person[i]).teach();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 老师类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多态参数：方法定义的参数类型为父类，实参类型允许是子类类型。</li>
</ul>
<h2 id="Object-类详解"><a href="#Object-类详解" class="headerlink" title="Object 类详解"></a>Object 类详解</h2><h3 id="equal方法"><a href="#equal方法" class="headerlink" title="equal方法"></a><code>equal</code>方法</h3><ul>
<li><code>==</code> 既可以判断基本类型，又可以判断引用类型</li>
<li><code>==</code> 如果判断基本类型，判断的是值是否相等，</li>
<li><code>==</code> 如果判断引用类型，判断的是地址是否相等，<strong>即判断的是否是同一个对象</strong></li>
<li><code>equal</code> 是<code>Object</code>类中的方法，只能判断引用类型</li>
<li>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String类中重写的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a><code>hashCode</code>方法</h3><ul>
<li>提高具有哈希表结构的容器的效率</li>
<li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样</li>
<li>两个引用，如果指向的是不同对象，则哈希值不一样</li>
<li>哈希值主要是根据地址号来的，不能完全将哈希值等价于地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa2</span> <span class="operator">=</span> aa;</span><br><span class="line">        System.out.println(aa.hashCode);</span><br><span class="line">        System.out.println(aa1.hashCode);  <span class="comment">//aa1 和 aa的hashcode相同</span></span><br><span class="line">        System.out.println(aa2.hashCode);  <span class="comment">// aa2 和 aa的hashcode相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a><code>toString</code>方法</h3><p>默认返回：<code>全类名 + @ + 哈希值的十六进制</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object 类中的toString方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Integer.toHexString(hashCode()); 将对象以hashcode值转成十六进制返回</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重写<code>toString</code>方法，在类中使用快捷键<code>alt + insert</code> 然后选中<code>toString</code>即可</li>
<li>当直接输出一个对象时，<code>toString</code>方法会被默认调用</li>
</ul>
<h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a><code>finalize</code>方法</h3><ul>
<li>当对象被回收时，系统会自动调用该对象的<code>finalize</code>方法。子类可以重写该方法，做一些释放资源的操作</li>
<li>什么时候被回收：当某个对象没有任何引用时，则<code>jvm</code>就认为该对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用<code>finalize</code>方法</li>
<li>垃圾回收机制的调用，是由系统来决定（即有自己的<code>GC算法</code>），也可以通过<code>System.gc()</code>主动触发垃圾回收机制。</li>
</ul>
<h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><p>在断点调试过程中，试运行状态，是以对象的运行类型来执行的。</p>
<ul>
<li>断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而会找到这个Bug</li>
</ul>
<h3 id="快捷键-1"><a href="#快捷键-1" class="headerlink" title="快捷键"></a>快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>F7</code></td>
<td align="center">跳入方法内</td>
</tr>
<tr>
<td align="center"><code>F8</code></td>
<td align="center">跳过，逐行执行代码</td>
</tr>
<tr>
<td align="center"><code>shift + F8</code></td>
<td align="center">跳出方法</td>
</tr>
<tr>
<td align="center"><code>F9</code></td>
<td align="center">resume，执行到下一个断点</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础入门 阶段3</title>
    <url>/2022/04/18/JAVA/02JavaBasic/</url>
    <content><![CDATA[<h1 id="类变量和类方法"><a href="#类变量和类方法" class="headerlink" title="类变量和类方法"></a>类变量和类方法</h1><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><p>也叫静态变量&#x2F;静态属性，用<code>static</code> 修饰，可以被本类的所有对象实例共享。任何对象去访问它时访问的都是同一个变量</p>
<ul>
<li>语法：<code>访问修饰符 static 变量类型 变量名</code></li>
<li>访问方法：<code>类名.类变量名</code>、<code>对象名.类变量名</code>，推荐使用：<code>类名.类变量名</code></li>
<li>类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt._static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> A.name; <span class="comment">// 通过类名访问</span></span><br><span class="line">        System.out.println(name);  <span class="comment">//xzt</span></span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(a.name); <span class="comment">//xzt</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;xzt&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>当需要让某个类变量都共享一个变量时，可以使用类变量(静态变量)</li>
<li>类变量时所有对象共享的，而实例变量时每个对象独享的</li>
<li>加上<code>static</code>成为类变量或静态变量，否则成为实例变量&#x2F;普通变量</li>
</ul>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>也叫静态方法，用<code>static</code>修饰</p>
<ul>
<li>语法：<code>访问修饰符 static 返回类型 方法名(参数列表) &#123;&#125;</code></li>
<li>访问方法：<code>类名.类方法名</code>、<code>对象名.类方法名</code>，推荐使用：<code>类名.类方法名</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt._static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        tom.payFee(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Stu</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        jack.payFee(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        Stu.showFee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">fee</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 学费</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法可以使用静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">payFee</span><span class="params">(<span class="type">double</span> fee)</span>&#123;</span><br><span class="line">        Stu.fee += fee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showFee</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;总学费有&quot;</span> + Stu.fee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用场景：</strong>当方法中不涉及任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率，例如工具类：<code>Math 类</code></p>
<p><strong>注意事项</strong></p>
<ul>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区<ul>
<li>类方法中不能使用<code>this</code>关键字</li>
</ul>
</li>
<li>类方法可以通过类名调用，普通方法不能通过类名调用。</li>
</ul>
<h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a><code>main</code> 方法</h3><p>语法：<code>public static void main(String[] args) &#123;&#125;</code></p>
<ul>
<li><code>main</code>是java虚拟机调用，所以类方法需要是<code>public</code></li>
<li>java虚拟机在执行<code>main</code>方法时不需要创建对象，所以需要是<code>static</code></li>
<li>该方法接收<code>String</code>类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li>
<li><code>java 执行的程序 参数1 参数2 参数3</code>，参数组成<code>String[] args</code></li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>在<code>main</code> 方法中可以直接调用<code>main</code>方法所在类的静态方法或静态属性。</li>
<li>但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的静态成员</li>
</ul>
<h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p>代码块又称初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过<code>&#123;&#125;</code>包围起来。但和方法不同，没有方法名，没有参数，只有方法体，而且不用通过对象或类显式调用，二十加载类时，或创建对象时隐士调用。</p>
<ul>
<li>基本语法：<code>[修饰符] &#123; 代码 &#125;;</code></li>
<li>修饰符可选，要写的话，也只能写<code>static</code></li>
<li>代码块分为两类，使用<code>static</code>修饰的叫静态代码块，没有<code>static</code>修饰的叫普通代码块</li>
<li>逻辑语句可以为任何逻辑语句，（输入、输出、方法调用、循环、判断等）</li>
<li><code>;</code>可以写上，也可以省略</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>相当于另一种形式的构造器，可以做初始化的操作</li>
<li>场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li>
<li><strong>代码块的调用优先于构造器的调用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String director;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;屏幕开启&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;广告开始&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;电影开始&quot;</span>);</span><br><span class="line">    &#125;;  <span class="comment">// 代码块，当任何一个构造器被调用时都会优先调用构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price, String director)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.director = director;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>用<code>static</code>修饰的代码块也叫静态代码块，作用就是对类进行初始化，而且它<strong>随着类的加载而执行</strong>，并且<strong>只会执行一次</strong>，如果是普通代码块，每创建一个对象，就执行。</li>
<li><strong>类什么时候被加载</strong> ⭐<ul>
<li>创建对象实例时<code>(new)</code></li>
<li>创建子类对象实例时，父类也会被加载</li>
<li>使用类的静态成员时（静态属性、静态方法）</li>
</ul>
</li>
<li>普通代码块，会在创建对象实例时被隐士调用，创建一次则执行一次，如果使用类的静态成员时，普通代码块并不会执行。</li>
<li><strong>创建一个对象时，在一个类调用顺序是：</strong>⭐⭐<ol>
<li><strong>调用静态代码块和静态属性初始化</strong>（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的先后顺序调用）</li>
<li><strong>调用普通代码块和普通属性的初始化</strong>（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通变量初始化，则按他们定义的先后顺序调用）</li>
<li><strong>调用构造方法</strong></li>
</ol>
</li>
<li>构造器最前面其实隐含了<code>super()</code>和 调用普通代码块，</li>
<li><strong>创建一个子类时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：</strong>⭐⭐<ol>
<li>父类的静态代码块和静态属性初始化（优先级一样，按定义顺序执行）</li>
<li>子类的静态代码块和静态属性初始化（优先级一样，按定义顺序执行）</li>
<li>父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>
<li>子类的构造方法</li>
</ol>
</li>
<li>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</li>
</ul>
<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p><strong>设计模式</strong>：设计模式是在大量的实践中总结和理论化之后的优选的代码结构、编程风格、以及解决问题的思考方式。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得对象实例的方法。</p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>没有使用对象，但是加载类的时候就会创建对象。可能造成创建了对象，但没有使用，造成资源的浪费。</p>
<ol>
<li>构造器私有化</li>
<li>类内部创建对象（该对象时<code>static</code>）</li>
<li>向外暴露一个静态的公共方法，<code>getInstance()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.single_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTone01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> GirlFriend.getInstance();  <span class="comment">// 创建对象</span></span><br><span class="line">        System.out.println(gf);</span><br><span class="line">        </span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">gf2</span> <span class="operator">=</span> GirlFriend.getInstance();  <span class="comment">// 创建对象 和 上面的gf其实是同一个对象</span></span><br><span class="line">        System.out.println(gf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;qqy&quot;</span>);  <span class="comment">// 2.对象在类内部创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123;   <span class="comment">//1.构造方法私有化</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123;  <span class="comment">//3.向外暴露一个公共的静态方法</span></span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>在使用时创建对象，只有在用户使用<code>getInstance()</code>方法时才返回对象，后面再次调用时会返回上次创建的对象，从而保证了单例。</p>
<ol>
<li>构造器私有化</li>
<li>定义一个<code>static</code>静态属性对象</li>
<li>定义一个<code>public</code>的<code>static</code>方法可以返回Cat对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式的单例模式</span></span><br><span class="line"><span class="keyword">package</span> com.xzt.single_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示懒汉式的单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> Cat.getInstance();</span><br><span class="line">        System.out.println(cat.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望在程序运行过程中只能创建一个Cat对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat; <span class="comment">// 2.定义一个static静态属性对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123; <span class="comment">// 1.构造器私有化</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span>&#123;  <span class="comment">//3.定义一个public的static方法可以返回Cat对象</span></span><br><span class="line">        <span class="keyword">if</span>(cat == <span class="literal">null</span>)&#123; <span class="comment">// 如果还没有创建Cat对象</span></span><br><span class="line">            cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;xzt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="饿汉式和懒汉式的区别"><a href="#饿汉式和懒汉式的区别" class="headerlink" title="饿汉式和懒汉式的区别"></a>饿汉式和懒汉式的区别</h3><ul>
<li>最主要的区别是创建对象的<strong>时机不同</strong>，饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li>
<li>饿汉式不存在线程安全问题，<strong>懒汉式存在线程安全问题</strong></li>
<li><strong>饿汉式存在浪费资源的问题</strong>，懒汉式则不存在这个问题。和对象的创建时机有很大的关系</li>
<li>在<code>javaSE</code>标准类中，<code>java.lang.Runtime</code>就是经典的单例模式</li>
</ul>
<h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a><code>final</code>关键字</h1><p><code>final</code>可以修饰类、属性、方法和局部变量</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>当不希望类被继承时，可以使用<code>final</code>修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.final_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;  <span class="comment">// 报错，不能被继承</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当不希望父类的某个方法被子类重写&#x2F;覆盖(<code>override</code>)时，可以使用<code>final</code>关键字修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;  <span class="comment">// 报错 不能被重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重写了hi方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当不希望类的某个属性的值被修改，可以使用<code>final</code>修饰</li>
<li>当不希望某个局部变量被修改。可以使用<code>final</code>修饰</li>
</ul>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li><code>final</code>修饰的属性又叫常量，一般用<code>XX_XX_XX</code>来命名</li>
<li><code>final</code>修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以再如下位置之一：<ul>
<li>定义时，例如：<code>public final double PI = 3.1415926;</code></li>
<li>在构造器中</li>
<li>在代码块中</li>
</ul>
</li>
<li>如果<code>final</code>修饰的属性是静态的，则初始化的位置只能是：<ul>
<li>定义时</li>
<li>在静态代码块中，不能在构造器中赋值</li>
</ul>
</li>
<li><code>final</code>类不能被继承，但可以实例化对象。</li>
<li>如果类不是<code>final</code>类，但是含有<code>final</code>方法，则该方法虽然不能被重写，但是可以被继承。</li>
<li>一般来说，如果一个类是<code>final</code>类了，就没必要再将方法修饰成<code>final</code>方法</li>
<li><code>final</code>不能修饰构造器（构造方法）</li>
<li><code>final</code>和<code>static</code>往往搭配使用，效率更高，底层编译器做了优化处理。调用类中的该属性时，不会加载类。</li>
<li>包装类（<code>Integer</code>，<code>Double</code>，<code>Float</code>，<code>Boolean</code>等都是<code>final</code>类），<code>String</code>也是<code>final</code>类</li>
</ul>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p><strong>定义：</strong>当父类的某些方法需要声明，但是又不能确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类</p>
<ul>
<li>用<code>abstract</code>修饰的方法</li>
<li>所谓抽象方法就是没有实现的方法，没有实现就是指没有函数体</li>
<li>当一个类中存在抽象方法时，需要将该类声明为<code>abstract</code>类</li>
<li>一般来说抽象类会被继承，由其子类实现抽象方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstract01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里实现了，但没什么意义，即父类方法不确定性问题</span></span><br><span class="line"><span class="comment">//    public void eat()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这是一个动物，不知道吃什么&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 所谓抽象类就是没有函数体的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  <span class="comment">// 当一个类中存在抽象方法时,需要将该类声明为抽象类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含<code>abstract</code>方法，</li>
<li>一旦类中包含了<code>abstract</code>方法，则这个类必须声明为<code>abstract</code></li>
<li><code>abstract</code>只能修饰类和方法，不能修饰属性和其它的。</li>
<li>抽象类可以有任意成员【抽象类的本质还是类】</li>
<li>抽象方法不能有主体，即不能实现。</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为<code>abstract</code>类</li>
<li>⭐<code>final</code>不能被继承，<code>static</code>不能被重写，所以<code>abstract</code>不能和<code>final</code>或者<code>static</code>组合使用</li>
<li>⭐<code>private</code>不能被重写，所以<code>abstract</code>也不能时<code>private</code>的</li>
</ul>
<h2 id="抽象类的最佳实践-模板设计模式"><a href="#抽象类的最佳实践-模板设计模式" class="headerlink" title="抽象类的最佳实践-模板设计模式"></a>抽象类的最佳实践-模板设计模式</h2><p>编写模板类，例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        job();  <span class="comment">// 实际调用了子类中重写的job()方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.calculateTime();</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.calculateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。</p>
<ul>
<li><strong>基本语法：</strong><code>interface 接口名&#123; //属性  // 方法&#125;</code></li>
<li><strong>实现方法：</strong><code>class 类名 implements 接口名 &#123; // 自己的属性  // 自己的方法 //必须实现的接口的抽象方法&#125;</code></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>在<code>Jdk7.0</code>前，接口里的所有方法都没有方法体，即都是抽象方法</li>
<li><code>Jdk8.0</code>后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在接口中抽象方法可以省略abstract</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">AInterface</span>&#123;  <span class="comment">// 实现接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口后，需要将该接口中所有的抽象方法全部实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>接口不能被实例化</li>
<li>接口中所有方法时<code>public</code>方法，接口中抽象方法，可以不用<code>abstract</code>修饰</li>
<li>一个普通类实现接口，就必须将该接口的所有方法都是实现</li>
<li>抽象了实现接口，可以不用实现接口的方法</li>
<li><strong>一个类可以同时实现多个接口</strong></li>
<li>接口中的属性只能时<code>final</code>，而且时<code>public static final</code>修饰符；例如：<code>int a = 1</code>实际上是<code>public static final int a = 1</code></li>
<li>接口中的属性的访问形式：<code>接口名.属性名</code></li>
<li>接口中不能继承其他的类，但是<strong>可以继承多个别的接口</strong>。<code>interface A extends B, C &#123;&#125;</code></li>
<li>接口的修饰符只能是<code>public</code>和默认，这点和类的修饰符是一样的</li>
</ul>
<h2 id="实现接口-VS-继承类"><a href="#实现接口-VS-继承类" class="headerlink" title="实现接口 VS 继承类"></a>实现接口 VS 继承类</h2><ul>
<li><strong>实现接口是对单继承机制的补充</strong></li>
<li>继承：先天拥有，当子类继承了父类，则自动拥有了父类的能力，</li>
<li>实现：后天学习，如果子类需要扩展某些功能，则需要实现接口的方式进行获取。</li>
<li>接口和问题解决的问题不同：<ul>
<li>继承的价值在于<strong>解决代码的复用性和可维护性</strong></li>
<li>接口的价值在于：设计，设计好各种规范（方法），让其他类去实现这些方法</li>
</ul>
</li>
<li>接口比继承更加灵活</li>
<li>接口在一定程度上可以实现代码解耦【即：接口规范 + 动态绑定机制】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsVSInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LittleMonkey</span> <span class="variable">wukong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LittleMonkey</span>(<span class="string">&quot;悟空&quot;</span>);</span><br><span class="line">        wukong.climbing();</span><br><span class="line"></span><br><span class="line">        wukong.swimming();</span><br><span class="line">        </span><br><span class="line">        wukong.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monkey</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monkey</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">climbing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;猴子会爬树&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LittleMonkey</span> <span class="keyword">extends</span> <span class="title class_">Monkey</span> <span class="keyword">implements</span> <span class="title class_">Fish</span>, Bird &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LittleMonkey</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; 通过学习会游泳了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; 通过学习会飞翔了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h2><ul>
<li><strong>多态参数</strong>，可以接受实现了该接口的所有类的实例对象，接口类型的变量可以指向实现了该接口的对象。和继承体现的多态类似。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyParameter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IF</span> <span class="variable">if01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">IF</span> <span class="variable">if02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(); <span class="comment">// 体现了接口的多态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IF</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> <span class="keyword">implements</span> <span class="title class_">IF</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">IF</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>多态数组</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyArr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Usb[] usbs = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>]; <span class="comment">// 接口类型的数组</span></span><br><span class="line"></span><br><span class="line">        usbs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Camera</span>();  <span class="comment">// 接口数组实现多态</span></span><br><span class="line">        usbs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; usbs.length; i++) &#123;</span><br><span class="line">            usbs[i].work();  <span class="comment">// 动态绑定</span></span><br><span class="line">            <span class="keyword">if</span>(usbs[i] <span class="keyword">instanceof</span> Phone)&#123;  <span class="comment">// 判断其运行类型是否为 Phone</span></span><br><span class="line">                ((Phone) usbs[i]).call();  <span class="comment">// 进行类型向下转型并调用方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机工作中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机工作中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>多态传递</strong>：如果接口A继承了接口B，而类C仅仅实现了接口A，则相当于类C也实现了接口B。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示多态传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyPass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 接口类型的变量可以指向实现了该接口的类的对象</span></span><br><span class="line">        <span class="type">IG</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">IH</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();  <span class="comment">// 因为IG继承了IH，所以Teacher对象实例也实现了IH</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>当类C继承了类A，实现了接口B，并且类A和接口B中有同名的属性，直接调用时则会造成模糊，所以调用父类的可以使用 <code>super.属性名</code>,调用接口的可以使用<code>接口名.属性名</code>。</p>
<p><strong>类的五大成员：</strong>属性、方法、构造器、代码块、内部类。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类（<code>inner class</code>），嵌套其他类的类称为外部类（<code>outer class</code>）。是我们类的第五大成员。<strong>内部类最大的特点就是可以访问私有属性，并且可以体现类与类之间的包含关系。</strong></p>
<ul>
<li><strong>基本语法：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;  <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123; <span class="comment">// 内部类</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123; <span class="comment">// 外部其他类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass01</span> &#123;  <span class="comment">// 外部其他类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;  <span class="comment">// 外部其他类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;   <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> n1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n1 = n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;  <span class="comment">// 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="comment">// 代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">inner</span> &#123;  <span class="comment">//内部类</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h2><ul>
<li>定义在外部类局部位置上（比如方法内）：<ul>
<li>局部内部类（有类名）</li>
<li>匿名内部类（没有类名，重点！！！）⭐⭐</li>
</ul>
</li>
<li>定义在外部类的成员位置上<ul>
<li>成员内部类（没用<code>static</code>修饰）</li>
<li>静态内部类（用<code>static</code>修饰）</li>
</ul>
</li>
</ul>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>定义在外部类的局部位置，比如方法中，并且有类名。</p>
<ul>
<li>可以直接访问外部类的所有成员，包含私有的。</li>
<li>不能添加访问修饰符，局部变量不能添加访问修饰符，可以使用<code>final</code>修饰，局部变量可以使用<code>final</code>修饰</li>
<li><strong>作用域：</strong>仅仅在定义它的方法或代码块中。</li>
<li>局部内部类 <strong>直接访问</strong> 外部类成员</li>
<li>外部类 访问 局部内部类的成员，访问方式：创建对象，再访问（注意：必须在作用域内）</li>
<li>外部其他类 <strong>不能访问</strong> 局部内部类（因为局部内部类是一个局部变量）</li>
<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果像访问外部类的成员，则可以使用（<code>外部类.this.成员</code>）去访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示局部内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer02</span> <span class="variable">outer02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>();</span><br><span class="line">        outer02.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner02</span> &#123;  <span class="comment">// 局部内部类的本质还是类</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">            <span class="comment">//可以直接访问外部类的所有成员，包含私有的</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 直接访问外部类的成员</span></span><br><span class="line">                System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1);  <span class="comment">// 100,内部类的n1</span></span><br><span class="line">                System.out.println(Outer02.<span class="built_in">this</span>.n1);  <span class="comment">// 10  ,外部类的n1,  Outer02.this 本质是调用了m1方法的对象</span></span><br><span class="line">                m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 外部类访问内部类成员，通过创建对象来进行访问</span></span><br><span class="line">        <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.f1();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;  <span class="comment">// 代码块</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner03</span>&#123;  <span class="comment">// 内部类</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名内部类-⭐⭐⭐"><a href="#匿名内部类-⭐⭐⭐" class="headerlink" title="匿名内部类 ⭐⭐⭐"></a>匿名内部类 ⭐⭐⭐</h2><p>匿名内部类是定义在外部类的局部位置，比如方法中，并且没有名字。</p>
<ul>
<li>本质：是一个<code>类</code>，且是一个<code>内部类</code>,该类没有名字，同时还是一个对象。</li>
<li>基本语法：<code>new 类或接口(参数列表) &#123;&#125;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示匿名内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer04</span> <span class="variable">outer04</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer04</span>();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer04</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 基于接口的匿名内部类,</span></span><br><span class="line">        <span class="comment">// Tiger 编译类型为 A，运行类型为匿名内部类</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">Tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Tiger.cry(); <span class="comment">// 调用方法1，通过对象名调用</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger的运行类型 = &quot;</span> + Tiger.getClass()); <span class="comment">// Outer04$1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于类的匿名内部类</span></span><br><span class="line">        <span class="comment">// father 的编译类型为Father，运行类型为 Outer04$2</span></span><br><span class="line">        <span class="comment">// class Outer04$2 extends Father &#123;&#125;</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&quot;jack&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了Test()方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.Test();   <span class="comment">// 调用方法2，因为是对象所以可以直接调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;father的运行类型 = &quot;</span> + father.getClass()); <span class="comment">// Outer04$1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;  <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;  <span class="comment">// 类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义的特征，也有创建对象的特征。所以调用方法有两种，看上面的示例。</li>
<li>可以直接访问外部类的所有成员，包括私有成员。</li>
<li>不能添加访问修饰符，因为它是一个局部变量</li>
<li>作用域：仅仅在定义它的方法或代码块中</li>
<li>匿名内部类 <strong>直接访问</strong> 外部类成员</li>
<li>外部其它类 <strong>不能访问</strong> 匿名内部类，因为匿名内部类是一个局部变量，</li>
<li>如果外部类的成员和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果像访问外部类的成员，则可以使用<code>外部类名.this.成员</code>去访问。</li>
</ul>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>定义在外部类的成员位置，并且没有<code>static</code>修饰，</p>
<ul>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>可以添加访问修饰符（<code>public</code>、<code>private</code>、<code>默认</code>、<code>protected</code>），因为他的地位就是一个成员。</li>
<li>作用域：和外部类的其他成员一样，为整个类体。</li>
<li>成员内部类 <strong>直接访问</strong> 外部类（比如：属性）【访问方式：直接访问】</li>
<li>外部类 <strong>简介访问</strong> 内部类，访问方式：创建对象，再访问</li>
<li>外部其他类 访问 内部类，有两种访问方式：<ul>
<li><code>Outer08.Inner08 inner08 = outer08.new Inner08();</code></li>
<li><code>Outer08.Inner08 inner081 = outer08.getInner08Instance();</code></li>
</ul>
</li>
<li>如果外部类和内部类中的成员重名时吗，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(<code>外部类.this.成员</code>)去访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer08</span> <span class="variable">outer08</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer08</span>();</span><br><span class="line">        outer08.t1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外部其他类访问内部类 的方式1</span></span><br><span class="line">        Outer08.<span class="type">Inner08</span> <span class="variable">inner08</span> <span class="operator">=</span> outer08.<span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2：在外部类中，编写一个方法，可以返回Inner08 对象</span></span><br><span class="line">        Outer08.<span class="type">Inner08</span> <span class="variable">inner081</span> <span class="operator">=</span> outer08.getInner08Instance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer08</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner08</span> &#123;  <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer08 的 n1 = &quot;</span> + n1 + <span class="string">&quot;Outer08 的 name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Inner08对象实例</span></span><br><span class="line">    <span class="keyword">public</span> Inner08 <span class="title function_">getInner08Instance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span>&#123;  <span class="comment">// 调用内部类的方法。</span></span><br><span class="line">        <span class="type">Inner08</span> <span class="variable">inner08</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">        inner08.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类是定义在外部类的成员位置，并且有<code>static</code>修饰</p>
<ul>
<li>可以直接访问外部类的所有静态成员，包括私有的，<strong>但不能直接访问非静态成员</strong></li>
<li>可以添加任意的访问修饰符，因为它是成员</li>
<li>作用域：同其他成员，为整个类体</li>
<li>静态内部类 <strong>直接访问</strong> 外部类的所有静态成员</li>
<li>外部类 <strong>访问</strong> 静态内部类 需要创建对象，再访问。</li>
<li>外部其他类 使用 静态内部类：三种方式<ul>
<li><code>Outer10.Inner10 inner10 = new Outer10.Inner10();</code></li>
<li><code>Outer10.Inner10 inner10Instance = new Outer10().getInner10Instance();</code>创建对象，调用方法</li>
<li><code>Outer10.Inner10 inner10Instance1 = Outer10.getInner10Instance();</code>直接使用类名调用静态方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line">        <span class="comment">// 因为静态内部类，是可以通过类名直接进行访问。</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>.Inner10();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner10Instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>().getInner10Instance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三：</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner10Instance1</span> <span class="operator">=</span> Outer10.getInner10Instance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer10</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner10</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Inner10 <span class="title function_">getInner10Instance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h1><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><ul>
<li>枚举是一组常量的集合</li>
<li>枚举属于一种特殊的类，里面只包含一组有限的特定的对象</li>
</ul>
<p>两种实现方式：</p>
<ul>
<li>自定义类实现枚举</li>
<li>使用<code>enum</code>关键字实现枚举</li>
</ul>
<h3 id="自定义类实现枚举"><a href="#自定义类实现枚举" class="headerlink" title="自定义类实现枚举"></a>自定义类实现枚举</h3><ol>
<li>将构造器私有化，目的是防止直接new</li>
<li>去掉<code>setXXX</code>方法，防止属性被修改，因为枚举对象通常为只读</li>
<li>在类内部直接创建固定的对象</li>
<li>对枚举对象&#x2F;属性使用<code>static + final</code>共同修饰，实现底层优化</li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.enum_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enumeration01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.SPRING);</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示自定义枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;  <span class="comment">// 季节类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc; <span class="comment">// 描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义了四个对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;酷热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将构造器私有化，目的是防止直接new</span></span><br><span class="line">    <span class="comment">// 2. 去掉setXXX方法，防止属性被修改</span></span><br><span class="line">    <span class="comment">// 3. 在Season内部直接创建固定的对象</span></span><br><span class="line">    <span class="comment">// 4. 加入final修饰符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public void setName(String name) &#123;</span></span><br><span class="line"><span class="comment">        this.name = name;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public void setDesc(String desc) &#123;</span></span><br><span class="line"><span class="comment">        this.desc = desc;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="enum关键字实现枚举"><a href="#enum关键字实现枚举" class="headerlink" title="enum关键字实现枚举"></a><code>enum</code>关键字实现枚举</h3><p><strong>实现步骤：</strong></p>
<ul>
<li>使用<code>enum</code>关键字替换<code>class</code>关键字</li>
<li><code>SPRING(&quot;春天&quot;, &quot;温暖&quot;); </code>代替 <code>public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);</code>创建对象</li>
<li>如果有多个常量（对象），使用<code>, </code>间隔</li>
<li>如果使用<code>enum</code>来实现枚举，要求将定义常量对象，写在最前面。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.enum_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enumeration02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season02.AUTUMN);</span><br><span class="line">        System.out.println(Season02.SPRING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示使用enum关键字实现枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season02</span> &#123;</span><br><span class="line">    <span class="comment">// 定义了四个对象。</span></span><br><span class="line"><span class="comment">//    public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);</span></span><br><span class="line"><span class="comment">//    public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);</span></span><br><span class="line"><span class="comment">//    public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;酷热&quot;);</span></span><br><span class="line"><span class="comment">//    public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.使用enum 代替class</span></span><br><span class="line">    <span class="comment">// 2.SPRING(&quot;春天&quot;, &quot;温暖&quot;); 代替 public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);创建对象</span></span><br><span class="line">    <span class="comment">// 3.如果有多个常量（对象），使用, 间隔</span></span><br><span class="line">    <span class="comment">// 4.如果使用enum来实现枚举，要求将定义常量对象，写在最前面。</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>), SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;酷热&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>), WHAT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc; <span class="comment">// 描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season02</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season02</span><span class="params">()</span> &#123;&#125;  <span class="comment">//无参构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season02&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>当我我们<code>enum</code>关键字开发一个枚举类时，默认会继承<code>Enum</code>类，而且是一个<code>final</code>类，使用<code>javap</code>工具进行验证</li>
<li>定义对象时被简化</li>
<li>如果使用的是无参构造器 创建 枚举对象，则实参列表和小括号都可以省略。</li>
<li>当有多个枚举对象时，使用<code>,</code>间隔，最后一个分号结束</li>
<li><strong>枚举对象必须放在枚举类的行首</strong></li>
<li><strong>当使用<code>enum</code>关键字后，就不能继承其他类，因为<code>enum</code>会隐式继承<code>Enum</code>类</strong></li>
<li><strong><code>enum</code>实现的枚举类，仍然是一个类，所以还是可以实现接口的</strong></li>
</ul>
<h4 id="Enum类中的方法"><a href="#Enum类中的方法" class="headerlink" title="Enum类中的方法"></a><code>Enum</code>类中的方法</h4><ul>
<li><code>toString()</code> : <code>Enum</code>类已经重写过了，返回的时当前对象名</li>
<li><code>name()</code>：输出枚举对象的名称</li>
<li><code>ordinal()</code>：输出该枚举对象的次序，从0开始编号</li>
<li><code>values()</code>：将所有定义的所有枚举对象以数组形式返回</li>
<li><code>valueOf()</code>：将字符串转成枚举对象，但要求字符串必须为已有的常量名，否则报异常。</li>
<li><code>compareTo()</code>：比较两个枚举常量，比较就是编号 <code>retrun self.ordinal - other.ordinal;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.enum_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 演示Enum类的各种方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season02</span> <span class="variable">autumn</span> <span class="operator">=</span> Season02.AUTUMN;</span><br><span class="line">        <span class="comment">// name()：输出枚举对象的名称</span></span><br><span class="line">        System.out.println(autumn.name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ordinal()：输出该枚举对象的次序，从0开始编号</span></span><br><span class="line">        System.out.println(autumn.ordinal());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// values():将所有定义的所有枚举对象以数组形式返回</span></span><br><span class="line">        Season02[] values = Season02.values();</span><br><span class="line">        <span class="keyword">for</span> (Season02 season: values) &#123;  <span class="comment">// 增强for循环， foreach</span></span><br><span class="line">            System.out.println(season);  <span class="comment">// 调用toString方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// valueOf(): 将字符串转成枚举对象，但要求字符串必须为已有的常量名，否则报异常。</span></span><br><span class="line">        <span class="type">Season02</span> <span class="variable">summer</span> <span class="operator">=</span> Season02.valueOf(<span class="string">&quot;SUMMER&quot;</span>);</span><br><span class="line">        System.out.println(summer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compareTo(): 比较两个枚举常量，比较就是编号 retrun self.ordinal - other.ordinal;</span></span><br><span class="line">        <span class="comment">// 用AUTUMN的编号减去SUMMER的编号，所以当等于0时，则相等</span></span><br><span class="line">        System.out.println(Season02.AUTUMN.compareTo(Season02.SUMMER));  <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>注解（<code>Annotation</code>）也被称为元数据（<code>Metadata</code>），用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。</p>
<p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</p>
<p>在<code>JavaSE</code>中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在<code>JavaEE</code>中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替<code>Java EE</code>旧版中所遗留的繁冗代码和XML配置等。</p>
<p>使用<code>Annotation</code>时要在其前面增加<code>@</code>符号，并把该<code>Annotation</code>当成一个修饰符使用。用于修饰它支持的程序元素。</p>
<h3 id="三个基本的Annotation"><a href="#三个基本的Annotation" class="headerlink" title="三个基本的Annotation"></a>三个基本的<code>Annotation</code></h3><ul>
<li><p><code>@Override</code>：限定某个方法，是重写父类方法，该注解只能用于方法。</p>
<ul>
<li><p><code>@Override</code>可写可不写</p>
</li>
<li><p>如果写了<code>@Override</code>注解，编译器就会检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过，否则，则编译错误。</p>
</li>
<li><p>&#96;&#96;&#96;java<br>@Target(ElementType.METHOD)<br>@Retention(RetentionPolicy.SOURCE)<br>public @interface Override {  &#x2F;&#x2F; @interface 表示这个是一个注解<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - `@Target(ElementType.METHOD)`表示该注解只能修饰方法，`@Target`是修饰注解的注解，称为元注解</span><br><span class="line"></span><br><span class="line">- `@Deprecated`：用于表示某个程序元素（类、方法等）已过时，即不推荐使用，但仍然可以使用，可以做版本升级过渡使用。</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  @Documented</span><br><span class="line">  @Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">  @Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line">  public @interface Deprecated &#123;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>@SuppressWarnings</code>：抑制编译器警告</p>
</li>
</ul>
<h3 id="JDK的元注解（了解）"><a href="#JDK的元注解（了解）" class="headerlink" title="JDK的元注解（了解）"></a>JDK的元注解（了解）</h3><p>JDK的元Annotation用于修饰其它Annotation</p>
<h1 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常 Exception"></a>异常 Exception</h1><blockquote>
<p>Java语言中将程序执行中发生的不正常情况称为”异常”。（语法错误和逻辑错误不是异常）</p>
</blockquote>
<p>执行过程中异常可以分为两类：</p>
<ul>
<li><code>Error</code>（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等情况，</li>
<li><code>Exception</code>：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。<ul>
<li>运行时异常：程序运行时发生的异常</li>
<li>编译时异常：程序编程时，由编译器检查出的异常。</li>
</ul>
</li>
</ul>
<p><img src="D:\Blog\source\img\Java\Error.png" alt="image-20220423110003693"></p>
<h2 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h2><p>编译器不要求强制处置的异常。一般是指编程时的逻辑错误没事成簇元应该避免其出现的异常。<code>java.lang.RuntimeException</code>类及它的子类都是运行时异常。</p>
<p>对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能对程序的可读性和运行效率产生影响。</p>
<h3 id="五大运行时异常"><a href="#五大运行时异常" class="headerlink" title="五大运行时异常"></a>五大运行时异常</h3><ul>
<li><code>NullPointerException</code>空指针异常，当应用程序试图在需要对象的地方使用null时，抛出该异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.exception_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullPointerException_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(name.length());  <span class="comment">// 存在空指针异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ArithmeticException</code>数学运算异常，当出现异常的运算条件时，抛出此异常。</li>
<li><code>ArryIndexOutOfBoundsException</code>数组越界异常，用非法索引访问数组时抛出异常。</li>
<li><code>ClassCastException</code>类型转换异常，当试图将对象强制转换成不是实例的子类时抛出异常。</li>
<li><code>NumberFormatException</code>数字格式不正确异常，当应用程序试图将字符串转换成一种数值类型，但该字符串必能准换为适当格式时，抛出异常。</li>
</ul>
<h2 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h2><p>是编译器要求必须处置的异常。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><blockquote>
<p>当异常发生时，对异常处理的方式</p>
</blockquote>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try - catch - finally"></a><code>try - catch - finally</code></h3><p>程序员在代码中捕获发生的异常，自行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码可能有异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//捕获到异常</span></span><br><span class="line">    <span class="comment">//1.当异常发生时，系统将异常封装给Exception对象e，传递给catch</span></span><br><span class="line">    <span class="comment">//2.得到异常对象后，程序员自己处理。</span></span><br><span class="line">    <span class="comment">//注意：如果没有发生异常，catch代码块不会执行。</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块是否有异常发生，始终要执行finally</span></span><br><span class="line">    <span class="comment">//通常将关闭释放资源的代码放在finally里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>如果异常发生了，则异常后买你的代码不会执行，直接进入到<code>catch</code>块，</li>
<li>如果异常没有发生，则顺序执行<code>try</code>的代码块，不会进入到<code>catch</code></li>
<li>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等）则使用<code>finally</code></li>
</ul>
<h3 id="throws"><a href="#throws" class="headerlink" title="throws"></a><code>throws</code></h3><p>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p>
<p>当下层方法出现异常时，可以将异常抛出至上层调用自己的方法。直至抛出至JVM，JVM处理异常方法：输出异常信息，中断程序，退出程序。</p>
<p>如果程序员没有显示的处理异常，默认使用<code>throws</code>处理异常</p>
<p><strong>注意事项</strong></p>
<ul>
<li>对于编译异常，程序中必须处理，比如<code>try - catch</code>或者<code>throws</code></li>
<li>对于运行异常，程序中如果没有处理，默认就是<code>throws</code>方式处理</li>
<li>子类重写父类方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类。</li>
<li>在<code>throws</code>过程中，如果有方法<code>try-catch</code>，就相当于处理异常，就可以不必<code>throws</code></li>
</ul>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><blockquote>
<p>当程序中出现了某些“错误”，但该错误信息并没有在Trowable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。</p>
</blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>定义类：自定义异常类名（程序员自己写），继承<code>Exception</code>或<code>RuntimeException</code></li>
<li>如果继承<code>Exception</code>，属于编译异常。</li>
<li>如果继承<code>RuntimeException</code>，属于运行异常（一般来说，继承<code>RuntimeException</code>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.customexception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在 18~120之间&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的年龄范围正确。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义运行时异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="throw-和-throws-的区别"><a href="#throw-和-throws-的区别" class="headerlink" title="throw 和 throws 的区别"></a><code>throw</code> 和 <code>throws</code> 的区别</h3><table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h1 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h1>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>故障注入&amp;检测流程</title>
    <url>/2022/03/22/LLVM/01faultInjection/</url>
    <content><![CDATA[<h1 id="故障注入-amp-检测流程"><a href="#故障注入-amp-检测流程" class="headerlink" title="故障注入&amp;检测流程"></a>故障注入&amp;检测流程</h1><h2 id="CPU故障注入-amp-检测流程"><a href="#CPU故障注入-amp-检测流程" class="headerlink" title="CPU故障注入&amp;检测流程"></a>CPU故障注入&amp;检测流程</h2><h3 id="处理源程序"><a href="#处理源程序" class="headerlink" title="处理源程序"></a>处理源程序</h3><ol>
<li><strong>将源代码转换成中间代码，划分了基本块</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -S -g -emit-llvm dm_dist.c -o dm_dist.ll</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>给中间代码添加全局变量：</strong>调用<code>Pass</code> <code> AddGlobalSig.so</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../AddGlobalSig.so -AddGlobalSig -S dm_dist.ll -o dm_dist.ll</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>对每个基本块进行脆弱性分析；</strong>并将结果输出至<code>allindex.txt</code>文件中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../Index.so -Index -disable-output dm_dist.ll 2&gt; allindex.txt</span><br></pre></td></tr></table></figure>

<p><code>allindex.txt</code>文件里面的内容为（基本块号，每个基本块里的指令数量）</p>
<ol start="4">
<li><strong>执行排序程序，</strong>将<code>allindex.txt</code>文件的内容按照基本块指令数量从小到大排序，并输出前n&#x2F;3-1个基本块的块号至<code>index.txt</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pthon3 sort.py &gt; index.txt</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>将脆弱性高的基本块进行再拆分.</strong> 这里的<code>$line</code>是 <code>index.txt</code> 里面存放的值</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> `<span class="built_in">cat</span> index.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	/home/yy2/Desktop/llvm/build/bin/opt -load /home/yy2/Desktop/llvm/build/lib/SplitBlock.so -SplitBlock -S -index <span class="variable">$line</span> dm_dist.ll -o dm_dist.ll</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><strong>使用<code>CFCSS</code>对中间代码进行插桩</strong> 使用<code>Pass：CFCSS.so</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../CFCSS.so -CFCSS -S dm_dist.ll -o cfcss.ll</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>编译.ll文件生成可执行程序</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang cfcss.ll -o dm_dist/dm_dist_cf</span><br></pre></td></tr></table></figure>

<h3 id="故障注入"><a href="#故障注入" class="headerlink" title="故障注入"></a>故障注入</h3><p><strong>调用<code>auto.sh</code>进行自动化注入</strong></p>
<p>$1 待注入程序    $2 程序的输入文件(不懂)    $3 运行次数   $4 p&#x2F;r 故障注入方式  $5 守护进程检测时间间隔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./auto.sh ../qt/TestProgram/dm_dist/dm_dist_cf input_small.dat <span class="string">&quot;2500&quot;</span> <span class="string">&quot;r&quot;</span> <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>

<p>在<code>auto.sh</code>里面调用<code>gdb</code>工具进行故障注入。<code>start.py</code></p>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>调用python文件进行结果分析:使用了<code>statistics.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 ../qt/CPUControl/fault_inject/statistics.py inject.output inject.correct</span><br></pre></td></tr></table></figure>

<h2 id="寄存器故障注入-amp-检测流程"><a href="#寄存器故障注入-amp-检测流程" class="headerlink" title="寄存器故障注入&amp;检测流程"></a>寄存器故障注入&amp;检测流程</h2><h3 id="标签扩展"><a href="#标签扩展" class="headerlink" title="标签扩展"></a>标签扩展</h3><ol>
<li><strong>使用clang将源程序转化为中间代码</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang dm.cpp --target=arm-v7-linux-gnueabi -emit-llvm -g -S -o dm.ll</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>加固程序,给中间代码添加编号</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../pass/build/libgenLLFIIndex/libgenLLFIIndex.so -genllfiindexpass -S dm.ll -o dm_id.ll</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>加固，通过冗余进行程序加固</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../pass/build/libdmr/libdmr.so -eddi -select_set_file=../xzt_jcq/index.txt -S dm_id.ll -o dm_df.ll</span><br></pre></td></tr></table></figure>

<h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><ol>
<li><strong>编译程序，生成链接文件</strong> 生成.o文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang dm_df.ll --target=arm-v7-linux-gnueabi -c -o dm_df.o</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>链接程序，生成可执行文件</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc dm_df.o exec.o -static -o dm_df</span><br></pre></td></tr></table></figure>

<h3 id="故障注入-1"><a href="#故障注入-1" class="headerlink" title="故障注入"></a>故障注入</h3><p>通过<code>gem5</code>对可执行程序进行故障注入</p>
<p>通过for循环执行n次命令，从而进行n次故障注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../res/gemFI/build/ARM/gem5.opt ../res/gemFI/configs/example/se.py -c dm_df</span><br></pre></td></tr></table></figure>

<h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ./.statistics.py</span><br></pre></td></tr></table></figure>

<h2 id="IO故障注入-amp-检测流程"><a href="#IO故障注入-amp-检测流程" class="headerlink" title="IO故障注入&amp;检测流程"></a>IO故障注入&amp;检测流程</h2><h3 id="加固"><a href="#加固" class="headerlink" title="加固"></a>加固</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-g++ ../qt/IO/benchmark/dm/ManagerTask.cpp ../Desktop/qt/IO/benchmark/dm/dm.cpp -static -g -o /../Desktop/qt/IO/benchmark/dm/IOFaultTolerance</span><br><span class="line">arm-linux-gnueabi-g++ ../Desktop/qt/IO/benchmark/dm/dm_dist.cpp ../Desktop/qt/IO/benchmark/dm/exec.cpp -static -g -o ../Desktop/qt/IO/benchmark/dm/dm_dist.out</span><br></pre></td></tr></table></figure>

<h3 id="故障注入-2"><a href="#故障注入-2" class="headerlink" title="故障注入"></a>故障注入</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../home/yy2/res/gemFI/build/ARM/gem5.opt /home/yy2/res/gemFI/configs/example/se.py -c </span><br><span class="line">../Desktop/qt/IO/benchmark/dm/dm.out</span><br><span class="line">../res/gemFI/build/ARM/gem5.opt /gemFI/configs/example/se.py -c ../Desktop/qt/IO/benchmark/dm/IOFaultTolerance</span><br></pre></td></tr></table></figure>

<h3 id="结果分析-2"><a href="#结果分析-2" class="headerlink" title="结果分析"></a>结果分析</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python statistic.py <span class="comment">#调用的是/home/yy2/Desktop/qt/IO/benchmark/dm/fiwork/fi/golden/out.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="LLVM-IR"><a href="#LLVM-IR" class="headerlink" title="LLVM IR"></a>LLVM IR</h2><p>生成.ll文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../Desktop/llvm/build/bin/clang -S -g -emit-llvm dm_dist.c -o dm_dist.ll</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>故障注入</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM Pass编写及运行</title>
    <url>/2022/03/22/LLVM/02PassWriteProcess/</url>
    <content><![CDATA[<h1 id="Pass编写运行"><a href="#Pass编写运行" class="headerlink" title="Pass编写运行"></a>Pass编写运行</h1><h2 id="编写Pass"><a href="#编写Pass" class="headerlink" title="编写Pass"></a>编写Pass</h2><ol>
<li>在<code>llvm/lib/Transforms/</code>目录下新建文件夹，命名为<code>MyPass</code></li>
</ol>
<p><img src="/../../img/LLVM/Pass1.png" alt="Pass1"></p>
<ol start="2">
<li>在<code>MyPass</code> 文件夹下创建两个文件，分别为<code>MyPass.cpp</code>、<code>CMakeLists.txt</code></li>
</ol>
<p><img src="/../../img/LLVM/Pass2.png" alt="image-20220102144652248"></p>
<ol start="3">
<li>对<code>MyPass.cpp</code>以及<code>CMakeLists.txt</code>文件进行编写。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#MyPass.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Analysis/LoopInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_TYPE <span class="string">&quot;hello&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyPass</span> : <span class="keyword">public</span> FunctionPass&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">        <span class="built_in">MyPass</span>() : <span class="built_in">FunctionPass</span>(ID)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            LoopInfo *LI = &amp;<span class="built_in">getAnalysis</span>&lt;LoopInfoWrapperPass&gt;().<span class="built_in">getLoopInfo</span>();</span><br><span class="line">            <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;Function &quot;</span>&lt;&lt;F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(Loop *L : *LI)</span><br><span class="line">                <span class="built_in">countBlocksInLoop</span>(L,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">countBlocksInLoop</span><span class="params">(Loop *L,<span class="type">unsigned</span> nest)</span></span>&#123;</span><br><span class="line">            <span class="type">unsigned</span> num_Blocks=<span class="number">0</span>;</span><br><span class="line">            Loop::block_iterator bb;</span><br><span class="line">            <span class="keyword">for</span>(bb = L-&gt;<span class="built_in">block_begin</span>();bb!=L-&gt;<span class="built_in">block_end</span>();++bb)</span><br><span class="line">                num_Blocks++;</span><br><span class="line">            <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;Loop level &quot;</span>&lt;&lt; nest &lt;&lt;<span class="string">&quot;has&quot;</span>&lt;&lt;num_Blocks&lt;&lt;<span class="string">&quot; blocks\n&quot;</span>;</span><br><span class="line">            std::vector&lt;Loop*&gt; subLoops = L-&gt;<span class="built_in">getSubLoops</span>();</span><br><span class="line">            Loop::iterator j,f;</span><br><span class="line">            <span class="keyword">for</span>(j = subLoops.<span class="built_in">begin</span>(),f=subLoops.<span class="built_in">end</span>();j!=f;++j)</span><br><span class="line">                <span class="built_in">countBlocksInLoop</span>(*j, nest+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp;AU)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            AU.<span class="built_in">addRequired</span>&lt;LoopInfoWrapperPass&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> MyPass::ID=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;MyPass&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;MyPass&quot;</span>,<span class="string">&quot;Function Block Count&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span>CMakeLists.txt</span><br><span class="line">cmake<span class="built_in">_</span>minimum<span class="built_in">_</span>required(VERSION 3.5)</span><br><span class="line"></span><br><span class="line">add<span class="built_in">_</span>llvm<span class="built_in">_</span>loadable<span class="built_in">_</span>module(MyPass</span><br><span class="line">	MyPass.cpp</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>对Transforms&#x2F;文件夹下面的CMakeLists.txt文件进行修改。</li>
</ol>
<p><img src="/../../img/LLVM/Pass3.png" alt="image-20220102145118378"></p>
<h2 id="编译生成-so文件"><a href="#编译生成-so文件" class="headerlink" title="编译生成.so文件"></a>编译生成.so文件</h2><p>在<code>llvm/build/</code>目录下面执行<code>make</code>指令，则会编译生成动态链接库<code>.so</code>文件，生成的文件在<code>llvm/build/lib/</code>目录下面。</p>
<h2 id="编写测试程序"><a href="#编写测试程序" class="headerlink" title="编写测试程序"></a>编写测试程序</h2><p>编写<code>.c</code>或<code>.cpp</code>文件，然后用<code>clang</code>工具对源程序进行编译，生成<code>LLVM IR</code>中间代码。</p>
<h2 id="运行Pass"><a href="#运行Pass" class="headerlink" title="运行Pass"></a>运行Pass</h2><p>通过调用测试程序运行<code>Pass</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../Desktop/llvm/build/lib/MyPass.so -MyPass -disable-output testPra.ll</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Pass</tag>
      </tags>
  </entry>
</search>
