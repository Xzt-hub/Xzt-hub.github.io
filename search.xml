<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/03/19/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2>
<h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">::: tips</span><br><span class="line">**提示**</span><br><span class="line">这是一个提示</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: warning</span><br><span class="line">**注意**</span><br><span class="line">这是一个警告</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: danger</span><br><span class="line">**警告**</span><br><span class="line">这是一个危险信号</span><br><span class="line">:::</span><br><span class="line"></span><br><span class="line">::: success</span><br><span class="line">**成功**</span><br><span class="line">这是一个成功信号</span><br><span class="line">:::</span><br></pre></td></tr></table></figure>
<h3 id="details"><a class="markdownIt-Anchor" href="#details"></a> Details</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">details</span> <span class="attr">open</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">summary</span>&gt;</span></span> <span class="language-xml"><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span></span><br><span class="line">//内容</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<details yellow open>
<summary>Hello Hexo</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello Hexo&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<h3 id="note"><a class="markdownIt-Anchor" href="#note"></a> Note</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% note simple %&#125;</span><br><span class="line">默认 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;</span><br><span class="line">default 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;</span><br><span class="line">primary 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;</span><br><span class="line">success 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;</span><br><span class="line">info 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;</span><br><span class="line">warning 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;</span><br><span class="line">danger 提示块标籤</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>
<div class="note simple"><p>默认 提示块标籤</p>
</div>
<div class="note default simple"><p>default 提示块标籤</p>
</div>
<div class="note primary simple"><p>primary 提示块标籤</p>
</div>
<div class="note success simple"><p>success 提示块标籤</p>
</div>
<div class="note info simple"><p>info 提示块标籤</p>
</div>
<div class="note warning simple"><p>warning 提示块标籤</p>
</div>
<div class="note danger simple"><p>danger 提示块标籤</p>
</div>
<h3 id="tabs"><a class="markdownIt-Anchor" href="#tabs"></a> Tabs</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure>
<div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
  </entry>
  <entry>
    <title>Java 基础入门 阶段1 &amp; 阶段2</title>
    <url>/2022/04/18/JAVA/01JavaBasic/</url>
    <content><![CDATA[<h1 id="java程序执行过程"><a class="markdownIt-Anchor" href="#java程序执行过程"></a> JAVA程序执行过程</h1>
<ul>
<li>编写<code>Hello.java</code>类，</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;  <span class="comment">// 定义类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  <span class="comment">// 主函数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world&quot;</span>);  <span class="comment">// 输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过编译生成<code>Hello.class</code>文件，(字节码文件)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac Hello.java</span><br></pre></td></tr></table></figure>
<ul>
<li>调用<code>JVM(java 虚拟机)</code>运行生成结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java Hello  <span class="comment"># 实际在运行Hello.class，但是不写后缀</span></span><br></pre></td></tr></table></figure>
<h2 id="java类编写注意事项"><a class="markdownIt-Anchor" href="#java类编写注意事项"></a> JAVA类编写注意事项</h2>
<ul>
<li>一个源文件中最多只能有一个<code>public 类</code>，其他类的个数不限。</li>
<li>如果一个文件中包含<code>public 类</code>，则文件名必须和该类同名。</li>
</ul>
<h1 id="java转义字符"><a class="markdownIt-Anchor" href="#java转义字符"></a> JAVA转义字符</h1>
<ul>
<li>JAVA中常用的转义字符：</li>
</ul>
<table>
<thead>
<tr>
<th>换行符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\n</code></td>
<td>换行符</td>
</tr>
<tr>
<td><code>\t</code></td>
<td>制表符，实现对齐</td>
</tr>
<tr>
<td><code>\r</code></td>
<td>一个回车</td>
</tr>
</tbody>
</table>
<h1 id="java注释"><a class="markdownIt-Anchor" href="#java注释"></a> JAVA注释</h1>
<ul>
<li>单行注释</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是单行注释</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多行注释</li>
</ul>
<p>多行注释不允许嵌套多行注释</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	这是多行注释</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文档注释</li>
</ul>
<p>里面是java doc标签</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 177411</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h1 id="java变量"><a class="markdownIt-Anchor" href="#java变量"></a> JAVA变量</h1>
<p>变量是程序的基本组成单位，有三要素（类型 + 名称 + 值），变量表示内存中的一个存储区域。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a;  <span class="comment">// 声明变量</span></span><br><span class="line">        a = <span class="number">1</span>;  <span class="comment">// 变量赋值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 声明赋值合并</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量类型"><a class="markdownIt-Anchor" href="#变量类型"></a> 变量类型</h2>
<ul>
<li><code>int</code> 整型，占4字节</li>
<li><code>double</code> 双精度浮点类型，占8字节</li>
<li><code>char</code> 字符型，占2字节</li>
<li><code>String</code> 字符串类型，</li>
</ul>
<h1 id="java数据类型"><a class="markdownIt-Anchor" href="#java数据类型"></a> JAVA数据类型 ⭐</h1>
<p>java 中定义数据必须指定明确的数据类型，可以看出java 是<strong>强类型语言</strong></p>
<h2 id="基本数据类型"><a class="markdownIt-Anchor" href="#基本数据类型"></a> 基本数据类型</h2>
<ul>
<li>数值型
<ul>
<li>整数类型，存放整数<code>byte[1], short[2], int[4], long[8]</code></li>
<li>浮点(小数)类型<code>float[4], double[8]</code></li>
</ul>
</li>
<li>字符型<code>char[2]</code>，存放单个字符</li>
<li>布尔型<code>boolean[1]</code></li>
</ul>
<h2 id="整数类型"><a class="markdownIt-Anchor" href="#整数类型"></a> 整数类型</h2>
<p>类型不同带来的是占用存储空间不同，进而带来的是数值范围不同。1个字节等于8位。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 4字节</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">1L</span>; <span class="comment">// 8字节</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">1F</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浮点数类型"><a class="markdownIt-Anchor" href="#浮点数类型"></a> 浮点数类型</h3>
<ul>
<li>浮点数 = 符号位 + 指数位 + 尾数位</li>
<li>尾数部分可能丢失，造成精度损失（小数都是近似值）</li>
</ul>
<p>陷阱：</p>
<p><code>2.7</code> 和 <code>8.1 / 3</code> 不相等，<code>8.1 / 3</code> 是接近<code>2.7</code>的小数，而不是<code>2.7</code>。所以需要判断时，应该是以两个数的差值的绝对值，在某个精度范围内进行判断。</p>
<h3 id="字符类型"><a class="markdownIt-Anchor" href="#字符类型"></a> 字符类型</h3>
<ul>
<li>必须用单引号<code>''</code></li>
<li>允许使用转义字符<code>\</code></li>
<li>允许进行运算  <code>'a' - 'a'</code></li>
<li>字符型存储到计算机中，需要将对应的码值(整数)找出来进行存储。</li>
<li>字符和整数的对应关系是通过字符编码表决定的，是规定好的。</li>
</ul>
<h3 id="基本数据类型的转换"><a class="markdownIt-Anchor" href="#基本数据类型的转换"></a> 基本数据类型的转换</h3>
<p><strong>自动类型转换</strong></p>
<ul>
<li><strong>精度小的类型自动转换为精度大的数据类型。</strong></li>
<li><code>char &lt; int &lt; long &lt; float &lt; double</code></li>
<li><code>byte &lt; short &lt; int &lt; long &lt; float &lt; double</code></li>
</ul>
<p>注意：</p>
<ol>
<li>有多种类型的数据类型进行混合运算时，系统首先将所有类型转为容量大的类型，然后再进行计算。</li>
<li>把容量大的数据类型赋值给容量小的数据类型时，会报错，反之则会进行自动类型转换。</li>
<li><code>（byte, short）</code>和 <code>char</code> 之间不会自动转换。</li>
</ol>
<p><strong>强制类型转换</strong></p>
<p>将容量大的类型转换为容量小的数据类型。使用时需要加上强制转换符<code>()</code>，但可能造成精度降低或溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ForceConvert</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">1.9</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基本数据类型和string类型的转换"><a class="markdownIt-Anchor" href="#基本数据类型和string类型的转换"></a> 基本数据类型和String类型的转换</h3>
<ul>
<li>基本类型转String类型：<code>基本类型值 + &quot;&quot;</code></li>
<li>String类型转基本类型：通过基本数据类型的包装类调用<code>parseXXX</code>进行转换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringToBasic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line">        str = <span class="string">&quot;89.0&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> Double.parseDouble(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">float</span> <span class="variable">c</span> <span class="operator">=</span> Float.parseFloat(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">short</span> <span class="variable">d</span> <span class="operator">=</span> Short.parseShort(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> Long.parseLong(str);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">fl</span> <span class="operator">=</span> Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<ul>
<li>在将String类型转换为基本数据类型时，需要确保String类型能够转换为有效的数据。如果格式不正确，则会抛出异常，程序就会终止。</li>
</ul>
<h2 id="引用数据类型"><a class="markdownIt-Anchor" href="#引用数据类型"></a> 引用数据类型</h2>
<ul>
<li>类<code>class</code>，例如<code>String</code></li>
<li>接口<code>interface</code></li>
<li>数组<code>[]</code></li>
</ul>
<h1 id="java-api文档"><a class="markdownIt-Anchor" href="#java-api文档"></a> JAVA API文档</h1>
<p><a href="https://www.matools.com/api/java8">中文在线文档</a></p>
<p><code>JDK &gt; Packages &gt; Interfaces + class + Exceptions &gt; function</code></p>
<h1 id="java-算数运算符"><a class="markdownIt-Anchor" href="#java-算数运算符"></a> JAVA 算数运算符</h1>
<p>运算符是一种特殊的符号，用于表示数据的运算，赋值和比较。</p>
<h2 id="算数运算符"><a class="markdownIt-Anchor" href="#算数运算符"></a> 算数运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">运算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">正号</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">负号</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">取模（取余）</td>
</tr>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center">自增</td>
</tr>
<tr>
<td style="text-align:center">–</td>
<td style="text-align:center">自减</td>
</tr>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">字符串相加</td>
</tr>
</tbody>
</table>
<h2 id="加号"><a class="markdownIt-Anchor" href="#加号"></a> 加号</h2>
<ul>
<li>当左右两边都是数值类型，则做加法。</li>
<li>当左右两边有一方是字符串类型，则做拼接。</li>
<li>运算顺序，从左到右，右括号除外。</li>
</ul>
<h2 id="赋值运算符"><a class="markdownIt-Anchor" href="#赋值运算符"></a> 赋值运算符</h2>
<p>基本赋值运算符：<code>=</code></p>
<p>复合运算符：<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code>。</p>
<h2 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h2>
<p>关系运算符的结果都是<code>boolean</code> 类型</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">运算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">相等于</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">不等于</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">小于等于</td>
</tr>
<tr>
<td style="text-align:center">&gt;=</td>
<td style="text-align:center">大于等于</td>
</tr>
<tr>
<td style="text-align:center">instanceof</td>
<td style="text-align:center">检查是否是类的对象</td>
</tr>
</tbody>
</table>
<h2 id="逻辑运算符"><a class="markdownIt-Anchor" href="#逻辑运算符"></a> 逻辑运算符</h2>
<p>用于连接多个条件（多个关系表达式），最终的结果也是一个<code>boolean</code>值</p>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">a&amp;b</th>
<th style="text-align:center">a&amp;&amp;b</th>
<th style="text-align:center">a|b</th>
<th style="text-align:center">a||b</th>
<th style="text-align:center">!a</th>
<th style="text-align:center">a^b(异或)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
<td style="text-align:center">T</td>
</tr>
<tr>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">F</td>
<td style="text-align:center">T</td>
<td style="text-align:center">F</td>
</tr>
</tbody>
</table>
<p><strong>&amp;&amp;和&amp;的区别</strong></p>
<ul>
<li><code>&amp;&amp;</code>当第一个条件为<code>false</code>时，不再判断第二个条件。效率高。</li>
<li><code>&amp;</code>当第一个条件为<code>false</code>时，仍需判断第二个条件。效率低。</li>
<li>同理 <code>||</code> 和<code>|</code> 的区别也是如此</li>
</ul>
<h2 id="位运算符"><a class="markdownIt-Anchor" href="#位运算符"></a> 位运算符</h2>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">运算</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">按位与</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">按位或</td>
</tr>
<tr>
<td style="text-align:center">~</td>
<td style="text-align:center">按位取反</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">按位异或</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;</td>
<td style="text-align:center">算数右移，地位溢出，符号位不变，并用符号位补溢出的高位</td>
</tr>
<tr>
<td style="text-align:center">&lt;&lt;</td>
<td style="text-align:center">算数左移，符号位不变，低位补</td>
</tr>
<tr>
<td style="text-align:center">&gt;&gt;&gt;</td>
<td style="text-align:center">逻辑右移</td>
</tr>
</tbody>
</table>
<h2 id="三元运算符"><a class="markdownIt-Anchor" href="#三元运算符"></a> 三元运算符</h2>
<p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2</code></p>
<ul>
<li>如果条件表达式结果为<code>true</code>，运算后的结果是表达式1；</li>
<li>如果条件表达式结果为<code>false</code>，运算后的结果是表达式2；</li>
</ul>
<h1 id="标识符"><a class="markdownIt-Anchor" href="#标识符"></a> 标识符</h1>
<p><strong>命名规则：（必须遵守）</strong></p>
<ul>
<li>由26个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头，</li>
<li>不可以使用关键字或保留字，但能包含关键字或保留字</li>
<li>严格区分大小写，长度无限制。</li>
<li>不能含有空格。</li>
</ul>
<p><strong>命名规范</strong></p>
<ul>
<li>包名：多个单词组成时所有字母都是小写。</li>
<li>类名、接口名：多单词组成时，所有单词的首字母大写。</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始后的所有单词首字母大写。</li>
<li>常量名：所有字母都大写。多单词时，每个单词用下划线连接。</li>
</ul>
<h1 id="键盘输入语句"><a class="markdownIt-Anchor" href="#键盘输入语句"></a> 键盘输入语句</h1>
<p>导入<code>java.util.Scanner</code>包，创建<code>Scanner</code>对象，调用方法进行输入。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Input</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">myScanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in); <span class="comment">// 创建Scanner 对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入名字&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> myScanner.next(); <span class="comment">// 接收用户的输入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> myScanner.nextInt();</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进制"><a class="markdownIt-Anchor" href="#进制"></a> 进制</h1>
<ul>
<li>二进制：以<code>0b</code>或<code>0B</code>开头</li>
<li>十进制：</li>
<li>八进制：以数字<code>0</code>开头</li>
<li>十六进制：以<code>0x</code>或<code>0X</code>开头表示。</li>
</ul>
<h2 id="进制的转换"><a class="markdownIt-Anchor" href="#进制的转换"></a> 进制的转换</h2>
<h3 id="其他进制转十进制"><a class="markdownIt-Anchor" href="#其他进制转十进制"></a> 其他进制转十进制</h3>
<ul>
<li>二进制转十进制</li>
</ul>
<p>从最低位(右边)开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和。</p>
<ul>
<li>八进制转十进制</li>
</ul>
<p>从最低位(右边)开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和。</p>
<ul>
<li>十六进制转十进制</li>
</ul>
<p>从最低位(右边)开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和。</p>
<h3 id="十进制转其他进制"><a class="markdownIt-Anchor" href="#十进制转其他进制"></a> 十进制转其他进制</h3>
<ul>
<li>十进制转二进制</li>
</ul>
<p>将该数不断除以2，指导商为0为止，然后将每步得到的余数倒过来。就是对应的二进制。</p>
<ul>
<li>十进制转八进制</li>
</ul>
<p>将该数不断除以8，指导商为0为止，然后将每步得到的余数倒过来。就是对应的八进制。</p>
<ul>
<li>十进制转十六进制</li>
</ul>
<p>将该数不断除以16，指导商为0为止，然后将每步得到的余数倒过来。就是对应的十六进制。</p>
<h3 id="其他进制相互转换"><a class="markdownIt-Anchor" href="#其他进制相互转换"></a> 其他进制相互转换</h3>
<ul>
<li>二进制转八进制</li>
</ul>
<p>从低位开始，将二进制数每三位一组，转成对应的八进制数即可。</p>
<ul>
<li>二进制转十六进制</li>
</ul>
<p>从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。</p>
<ul>
<li>八进制转二进制</li>
</ul>
<p>将八进制数的每一位转成对应的一个3位的二进制数即可。</p>
<ul>
<li>十六进制转二进制</li>
</ul>
<p>将十六进制数的每一位转成对应的一个4位的二进制数即可。</p>
<h1 id="控制结构"><a class="markdownIt-Anchor" href="#控制结构"></a> 控制结构</h1>
<h2 id="顺序控制"><a class="markdownIt-Anchor" href="#顺序控制"></a> 顺序控制</h2>
<p>程序从上到下逐行执行，中间没有任何判断和跳转。</p>
<h2 id="分支控制"><a class="markdownIt-Anchor" href="#分支控制"></a> 分支控制</h2>
<ul>
<li><code>if...else if...if...</code></li>
<li><code>switch...case...default...</code></li>
</ul>
<h2 id="循环控制"><a class="markdownIt-Anchor" href="#循环控制"></a> 循环控制</h2>
<ul>
<li><code>for(循环变量初始化; 循环条件; 循环变量迭代) &#123; 循环体 &#125;</code></li>
<li><code>while(循环条件) &#123; 循环体; 循环变量迭代&#125;</code></li>
<li><code>do&#123; 循环体; 循环变量迭代&#125; while(循环条件)</code></li>
</ul>
<h2 id="跳转控制"><a class="markdownIt-Anchor" href="#跳转控制"></a> 跳转控制</h2>
<ul>
<li><code>break</code>：结束最近的一层循环，推出该层循环</li>
<li><code>continue</code>：结束本次循环，继续下一层循环</li>
<li><code>return</code>：表示跳出所在方法</li>
</ul>
<h1 id="数组-排序-查找"><a class="markdownIt-Anchor" href="#数组-排序-查找"></a> 数组、排序、查找</h1>
<h2 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h2>
<p>数组可以存放<code>多个</code> <code>同一类型</code> 数据，数组也是一种数据类型，是引用类型。</p>
<p>数组下标是从0开始编号的。</p>
<h3 id="数组的定义"><a class="markdownIt-Anchor" href="#数组的定义"></a> 数组的定义</h3>
<ul>
<li>
<p>动态初始化：<code>数组类型 数组名[] = new 数据类型[大小]</code></p>
</li>
<li>
<p>动态初始化，先声明，在创建。</p>
</li>
<li>
<p>静态初始化，<code>数据类型 数组名[] = &#123;元素值, 元素值, ...&#125;</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 动态初始化数组</span></span><br><span class="line">        <span class="type">int</span> num[];</span><br><span class="line">        num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>]; <span class="comment">// 先声明，再分配</span></span><br><span class="line">        <span class="type">int</span> q[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 静态初始化数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组的注意事项"><a class="markdownIt-Anchor" href="#数组的注意事项"></a> 数组的注意事项</h3>
<ul>
<li>数组内的元素必须是相同类型，</li>
<li>数组中的元素类型可以是任何数据类型，包括基本数据类型或引用数据类型，但不能混。</li>
<li>数组创建后，没有赋值，有默认值。</li>
<li>数组下标是从0开始的。</li>
<li>数组下标必须在指定范围内使用。</li>
<li>数组属于引用类型，数组型数据是对象(object)。</li>
</ul>
<h3 id="数组的赋值机制"><a class="markdownIt-Anchor" href="#数组的赋值机制"></a> 数组的赋值机制</h3>
<ul>
<li>基本数据类型赋值，这个值就是具体的数据，而且相互不影响。</li>
<li><strong>数组在默认情况下，是阴影传递，赋的值是地址。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="type">int</span> num[] = arr; <span class="comment">// 引用赋值，此时num发生变化，则arr会发生变化。</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组拷贝"><a class="markdownIt-Anchor" href="#数组拷贝"></a> 数组拷贝</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">       	<span class="type">int</span> <span class="variable">arr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];  <span class="comment">// 数组拷贝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i ++)&#123;</span><br><span class="line">            arr2[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h2>
<h3 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h3>
<p>每次冒泡都将最大的数找出，并移动到后面。</p>
<ul>
<li>需要进行<code>arr.length - 1</code> 轮排序。</li>
<li>第<code>i</code>轮排序需要确定第<code>i</code>大数的位置。</li>
<li>每轮比较依次减少<code>i</code>次比较。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123;<span class="number">26</span>, <span class="number">90</span>, <span class="number">86</span>, <span class="number">45</span>, <span class="number">13</span>, <span class="number">72</span>, <span class="number">16</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = i; i &lt; arr.length; i ++) &#123;  <span class="comment">// 需要进行 arr.length - 1 次</span></span><br><span class="line">            <span class="comment">// 每次需要比较 arr.length - i - 1次</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; arr.length - i; j++) &#123; </span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;  <span class="comment">// 如果当前数比后一个数大，则进行交换</span></span><br><span class="line">                    <span class="type">int</span> a = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h2>
<ul>
<li>顺序查找：用目标值依次和数组中的元素进行比较，若相等，则查找到，若遍历结束仍没有找到，则不存在。</li>
<li>二分查找，需要保证原数组是有序的。</li>
</ul>
<h2 id="二维数组"><a class="markdownIt-Anchor" href="#二维数组"></a> 二维数组</h2>
<ul>
<li>动态初始化：<code>类型 数组名[][] = new 类型[大小][大小]</code></li>
<li>动态初始化：先声明，在分配空间</li>
<li>动态初始化：列数不确定</li>
<li>静态初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDef</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// 动态初始化数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> num[][];</span><br><span class="line">        num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>]; <span class="comment">// 先声明，再分配</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> arr[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][]; <span class="comment">// 列数不确定</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i ++)&#123; <span class="comment">// 给列分配空间。</span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> q[][] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;&#125;; <span class="comment">// 静态初始化数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="类与对象"><a class="markdownIt-Anchor" href="#类与对象"></a> 类与对象</h1>
<ul>
<li>类：就是数据类型，例如Cat</li>
<li>对象：就是一个具体的实例，<code>对象[属性, 行为]</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">cat</span>();  <span class="comment">// 对象</span></span><br><span class="line">        cat1.name = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line">        cat1.age = <span class="number">20</span>;</span><br><span class="line">        cat1.color = <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> cat1.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span>&#123; <span class="comment">// 类</span></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//行为</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h2>
<p><code>属性</code>也叫<code>成员变量</code>，也叫<code>field(字段)</code></p>
<ul>
<li>属性是类的一个组成部分，一般是数据类型，也可以是引用类型。</li>
</ul>
<p><strong>属性的定义方法：</strong></p>
<p><code>访问修饰符 属性类型 属性名</code></p>
<p>访问修饰符包括：<code>public</code>，<code>private</code>， <code>protected</code>，默认为<code>public</code></p>
<h2 id="成员方法"><a class="markdownIt-Anchor" href="#成员方法"></a> 成员方法</h2>
<p>某个类中的函数就是该类的成员方法或者叫成员函数。</p>
<p><strong>成员方法的定义：</strong></p>
<p><code>访问修饰符 返回类型 方法名(形参列表) &#123; 函数体 ; return 返回值;&#125;</code></p>
<ul>
<li>形参列表：代表成员方法的输入。</li>
<li>返回类型：表示成员方法的输出，若为<code>void</code>，则没有返回值</li>
<li><code>return</code>不是必须的</li>
</ul>
<p><strong>传参机制</strong></p>
<ul>
<li>值传递；方法运行后不会影响实参的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引用数据传递：接收数组，传递的是地址。</li>
</ul>
<p><strong>方法的递归调用</strong></p>
<ul>
<li>直接递归：方法自己本身直接调用自己。</li>
<li>简介递归</li>
</ul>
<h2 id="方法重载"><a class="markdownIt-Anchor" href="#方法重载"></a> 方法重载</h2>
<p>JAVA允许在同一个类中的成员方法中，有多个重名函数存在，但是要求形参列表不一样！</p>
<p><strong>重载的优点</strong></p>
<ul>
<li>减轻了起名的麻烦</li>
<li>减轻了记名的麻烦</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverLoad01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyCaculate</span> <span class="variable">myCaculate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCaculate</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">caculate</span> <span class="operator">=</span> myCaculate.Caculate(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">caculate1</span> <span class="operator">=</span> myCaculate.Caculate(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">caculate2</span> <span class="operator">=</span> myCaculate.Caculate(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCaculate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Caculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">Caculate</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Caculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>方法名必须一样</li>
<li>形参列表必须不同，形参类型不同 或者 个数不同 或者 顺序不同。</li>
<li>参数名没有要求</li>
<li>返回类型无要求，返回类型不是构成方法重载的条件。</li>
</ul>
<h2 id="可变参数"><a class="markdownIt-Anchor" href="#可变参数"></a> 可变参数</h2>
<p>JAVA允许将同一个类中多个同名同功能但参数个数不同的方法，封装成同一个方法。</p>
<p><code>for(参数类型... 参数名)</code>，此时参数名可以当做数组使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VarParameter01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HspMethod hspMethod=<span class="keyword">new</span> <span class="title class_">HspMethod</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> hspMethod.sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum1</span> <span class="operator">=</span> hspMethod.sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HspMethod</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span>... nums)</span>&#123;  <span class="comment">// 可以接受int类型的多个参数，可以将nums当作数组使用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cun</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i ++)&#123;</span><br><span class="line">            cun += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>可变参数的实参可以直接是数组</li>
<li>可变参数的实参可以是0个或多个</li>
<li><strong>可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后</strong></li>
<li><strong>一个形参列表只能出现一个可变参数</strong></li>
</ul>
<h2 id="作用域"><a class="markdownIt-Anchor" href="#作用域"></a> 作用域</h2>
<p>包括<strong>局部变量</strong>或者<strong>全局变量</strong></p>
<ul>
<li>局部变量：定义在某一个成员方法中的变量 或定义在某一个代码块中 。作用域仅在该成员方法中 或 该代码块中。</li>
<li>全局变量：直接定义在类中的变量，属性就是全局变量，在该类中的任何成员方法中都可以直接使用。作用域在整个类中。</li>
<li>全局变量可以不用赋值，有默认值，局部变量必须赋值后才可以使用，不会有默认值。</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>属性和局部变量可以重名，使用时遵守<code>就近原则</code></li>
<li>在同一个作用域内，两个局部变量不能重名</li>
<li>属性声明周期比较长，局部变量声明周期相对比较短</li>
</ul>
<p><strong>作用域范围</strong></p>
<ul>
<li>属性：可以被本类所有成员方法使用，也可以通过对象调用被其他类使用。</li>
<li>局部变量：只能在本成员方法中使用。</li>
</ul>
<p><strong>修饰符</strong></p>
<ul>
<li>属性：可以添加修饰符</li>
<li>局部变量：不可以添加修饰符</li>
</ul>
<h2 id="构造方法构造器"><a class="markdownIt-Anchor" href="#构造方法构造器"></a> 构造方法/构造器</h2>
<p><strong>基本语法：</strong><code>[修饰符] 方法名(形参列表) &#123; 方法体; &#125;</code></p>
<p>**作用：**在创建对象时，实现对对象的初始化。</p>
<ul>
<li>构造器的修饰符可以是默认的也可以是其他的。</li>
<li>构造器没有返回值</li>
<li>方法名和类名必须保持一致</li>
<li>构造器的调用是由系统完成的</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xzt&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(person.name + <span class="string">&quot;的年龄为&quot;</span> + person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Person() &#123;  <span class="comment">// 默认构造函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age) &#123;  <span class="comment">// 重写构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h3>
<ul>
<li>一个类可以构造多个构造器，即构造器的重载</li>
<li>若没有自定义构造器，则系统会自动给类生成一个默认无参构造器，但是若定义了一个新的构造器，则不会再自动生成一个默认无参构造器。</li>
</ul>
<h2 id="对象创建流程"><a class="markdownIt-Anchor" href="#对象创建流程"></a> 对象创建流程</h2>
<ul>
<li>加载类信息，只会加载一次</li>
<li>在堆中分配空间（地址）</li>
<li>完成对象初始化，
<ul>
<li>默认初始化</li>
<li>显式初始化</li>
<li>构造器初始化</li>
</ul>
</li>
<li>在对象堆中的地址，返回给创建的对象</li>
</ul>
<h2 id="this关键字"><a class="markdownIt-Anchor" href="#this关键字"></a> this关键字</h2>
<p><code>java</code>虚拟机给每个对象分配<code>this</code>，代表当前对象。</p>
<p>**作用：**在成员方法中，<code>this</code>主要用在当形参和属性名同名时，使用<code>this.属性名</code>代替属性名，来区分同名问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xzt&quot;</span>, <span class="number">22</span>);</span><br><span class="line">        System.out.println(person.name + <span class="string">&quot;的年龄为&quot;</span> + person.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    Person() &#123;  <span class="comment">// 默认构造函数</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age) &#123;  <span class="comment">// 重写构造函数</span></span><br><span class="line">        <span class="built_in">this</span>.age = age; <span class="comment">// 此时使用this.age 代替属性age</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本质</strong>：哪个对象调用，<code>this</code>就代表哪个对象</p>
<p><strong>注意事项</strong></p>
<ul>
<li><code>this</code>可以访问本类的属性、方法、构造器</li>
<li><code>this</code>用于区分当前类的属性和局部变量</li>
<li>访问成员方法时语法：<code>this.方法名(参数列表)</code></li>
<li>访问构造器语法：<code>this(参数列表)</code>；注意只能在构造器中使用</li>
<li><code>this</code>不能再类定义的外部使用，只能再类定义的方法中使用</li>
</ul>
<h1 id="intellij-idea"><a class="markdownIt-Anchor" href="#intellij-idea"></a> Intellij IDEA</h1>
<h2 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h2>
<table>
<thead>
<tr>
<th style="text-align:center">功能描述</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">删除当前行</td>
<td style="text-align:center"><code>ctrl + y</code></td>
</tr>
<tr>
<td style="text-align:center">复制当前行</td>
<td style="text-align:center"><code>ctrl + d</code></td>
</tr>
<tr>
<td style="text-align:center">代码格式化</td>
<td style="text-align:center"><code>ctrl + alt + L</code></td>
</tr>
<tr>
<td style="text-align:center">补全代码</td>
<td style="text-align:center">补全代码：<code>alt + /</code></td>
</tr>
<tr>
<td style="text-align:center">单行注释</td>
<td style="text-align:center"><code>ctrl + /</code></td>
</tr>
<tr>
<td style="text-align:center">多行注释</td>
<td style="text-align:center"><code>ctrl + shift + /</code></td>
</tr>
<tr>
<td style="text-align:center">显示错误</td>
<td style="text-align:center"><code>alt + Enter</code></td>
</tr>
<tr>
<td style="text-align:center">快速运行代码</td>
<td style="text-align:center"><code>ctrl + shift + F10</code></td>
</tr>
<tr>
<td style="text-align:center">生成构造器、get函数、set函数</td>
<td style="text-align:center"><code>alt + insert</code></td>
</tr>
<tr>
<td style="text-align:center">查看类的继承关系</td>
<td style="text-align:center"><code>ctrl + h</code></td>
</tr>
<tr>
<td style="text-align:center">定位到定义的方法</td>
<td style="text-align:center"><code>ctrl + b</code></td>
</tr>
<tr>
<td style="text-align:center">自动分配变量名</td>
<td style="text-align:center">在后面加<code>.var</code></td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<h2 id="模板"><a class="markdownIt-Anchor" href="#模板"></a> 模板</h2>
<p>查看模板：<code>file -&gt; settings -&gt; editor -&gt; Live templates -&gt; Java</code>，可以自定义自己的模板</p>
<table>
<thead>
<tr>
<th style="text-align:center">功能描述</th>
<th style="text-align:center">快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主函数</td>
<td style="text-align:center"><code>main + enter</code></td>
</tr>
<tr>
<td style="text-align:center">输出语句</td>
<td style="text-align:center"><code>sout + enter</code></td>
</tr>
<tr>
<td style="text-align:center">for循环语句</td>
<td style="text-align:center"><code>fori + enter</code></td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<h1 id="面向对象编程中"><a class="markdownIt-Anchor" href="#面向对象编程中"></a> 面向对象编程（中）</h1>
<h2 id="包"><a class="markdownIt-Anchor" href="#包"></a> 包</h2>
<p><strong>作用</strong></p>
<ul>
<li>可以区分相同名字的类</li>
<li>当类很多时，可以很好的管理类</li>
<li>控制访问范围</li>
</ul>
<p><strong>基本语法</strong>：<code>package.com.constructor</code></p>
<ul>
<li><code>package</code> 关键字，表示打包</li>
<li><code>com.constructor</code> 表示包名</li>
</ul>
<p><strong>原理：</strong> 创建不同的文件夹来保存类文件。</p>
<p><strong>命名规则</strong></p>
<ul>
<li>只能包含数字、字母、下划线、小圆点，但不能以数字开头，不能是数字或保留字</li>
</ul>
<p><strong>命名规范</strong></p>
<ul>
<li>一般是小写字母 + 小圆点，一般是<code>com.公司名.项目名.业务模块名</code></li>
</ul>
<h3 id="常用的包"><a class="markdownIt-Anchor" href="#常用的包"></a> 常用的包</h3>
<ul>
<li><code>java.lang.*</code> 默认引入，不需要再引入。例如<code>Mathl类</code></li>
<li><code>java.util.*</code> 系统提供的工具包，工具类，使用<code>Scanner</code></li>
<li><code>java.net.*</code> 网路包，网络开发</li>
<li><code>java.awt.*</code> Java界面开发，GUI</li>
</ul>
<h3 id="导入包"><a class="markdownIt-Anchor" href="#导入包"></a> 导入包</h3>
<p>基本语法：<code>import 包</code>，引入一个包的目的是使用该包下面的类。</p>
<ul>
<li><code>package</code>的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一个<code>package</code></li>
<li><code>import</code> 放在<code>package</code>和类之间，可以有多条且顺序没有要求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pkg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner; <span class="comment">// 只会导入java.util下面的Scanner类</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;  <span class="comment">// 导入java.util包下面的所有类， 不建议使用</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Import01</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;-<span class="number">1</span>, <span class="number">20</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(arr); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i ++)&#123;</span><br><span class="line">            System.out.println(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>
<h2 id="访问修饰符"><a class="markdownIt-Anchor" href="#访问修饰符"></a> 访问修饰符</h2>
<p>java提供四种访问修饰控制符，用于控制方法和属性（成员变量）的访问权限。</p>
<ul>
<li>公开级别：<code>public</code> 修饰，对外公开</li>
<li>受保护级别：<code>protected</code> 修饰，对子类和同一个包中的类公开</li>
<li>默认级别：没有修饰符，向同一个包的类公开，对子类不能访问</li>
<li>私有级别：<code>private</code> 修饰，只有类本身可以访问，不对外公开</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>修饰符可以用来修饰类中的属性，成员方法以及类</li>
<li>只有默认的和<code>public</code>才可以修饰类</li>
</ul>
<h2 id="三大特征"><a class="markdownIt-Anchor" href="#三大特征"></a> 三大特征 ⭐</h2>
<h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3>
<p><strong>定义：</strong> 把抽象出来数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。</p>
<p><strong>优点</strong></p>
<ul>
<li>隐藏实现细节，直接调用即可</li>
<li>可以对数据进行验证，保证安全合理</li>
</ul>
<p><strong>步骤</strong></p>
<ol>
<li>将属性私有化</li>
<li>提供一个<code>public 的 set</code>方法，对属性判断并赋值</li>
<li>提供一个<code>public 的 get</code>方法，用于获得属性值</li>
</ol>
<p>当使用构造器对属性赋值时，构造器函数体的编写方法需要进行改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.encapsulation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encapsulation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        person.setName(<span class="string">&quot;xzt&quot;</span>);</span><br><span class="line">        person.setAge(<span class="number">200</span>);</span><br><span class="line">        person.setSalary(<span class="number">30000</span>);</span><br><span class="line">        System.out.println(person.info());</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">smith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;smith&quot;</span>, <span class="number">30</span>, <span class="number">15000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有三个属性的构造器 并进行重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, <span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        setName(name);</span><br><span class="line">        setAge(age);</span><br><span class="line">        setSalary(salary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快捷键 alt + insert</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &gt;= <span class="number">1</span> &amp;&amp; age &lt;= <span class="number">120</span>)</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;年龄需要在1~120之间&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">(<span class="type">double</span> salary)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;信息为：名字是 &quot;</span> + getName() + <span class="string">&quot;, 年龄是：&quot;</span> + getAge() + <span class="string">&quot;，工资是：&quot;</span> + getSalary();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<p><strong>定义：</strong> 当两个类中有很多属性和方法是相同的，则可以使用继承来减少代码复用。</p>
<p><strong>基本语法：</strong></p>
<p><code>class 子类名 extends 父类名 &#123;&#125;</code></p>
<ul>
<li>子类会自动拥有父类定义的属性和方法</li>
<li>父类又叫超类或者基类</li>
<li>子类又叫派生类</li>
</ul>
<p><strong>优点：</strong> 代码的复用性、扩展性、维护性都得到很大提升</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>子类继承了所有的属性和方法，但是私有属性不能在子类中直接访问，要通过公共的方法去访问。</li>
<li><strong>子类必须调用父类的构造器，完成父类的初始化。</strong> 在子类的构造函数中会默认调用<code>super()</code>函数</li>
<li>当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会调用父类的无参构造器，如果父类中没有提供无参构造器，则必须在子类的构造器中用<code>super()</code>去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。</li>
<li>如果希望指定去调用父类的某个构造器，则显示的调用一下，<code>super(参数列表)</code></li>
<li><code>super()</code> 在使用时，需要放在构造器的第一行（<code>super()</code>只能在构造器中使用）</li>
<li><code>super()</code> 和 <code>this()</code> 都只能放在构造器的第一行，因此这两个方法不能共存在一个构造器</li>
<li>java所有类时<code>Object类</code>的子类，<code>Object类</code>是所有类的基类</li>
<li>父类构造器的调用不限于直接父类。将一直往上追溯直到<code>Object类</code>（顶级父类）</li>
<li>子类最多只能继承一个父类（指直接继承），即<strong>java中是单继承机制</strong></li>
<li>不能滥用继承，子类和父类之间必须满足<code>is-a</code>的逻辑关系（子类是父类中的一类）</li>
</ul>
<p><strong>super关键字：</strong> <code>super()</code> 代表父类的引用，用于访问父类的属性，方法，构造器。</p>
<ul>
<li>访问父类的属性/方法，但不能访问<code>private</code>私有属性/方法，<code>super.属性名</code></li>
<li>访问父类的构造器，<code>super(参数列表)</code>只能放在构造器的第一行</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>调用父类构造器，分工明确，父类属性由父类初始化，子类的属性由子类初始化</li>
<li>当子类中有和父类中成员（属性和方法）重名时，为了访问父类的成员，必须通过<code>super</code>关键字。</li>
<li>若多个上级类都有同名，则<code>super</code>访问遵循就近原则</li>
</ul>
<p><code>super</code>和<code>this</code><strong>的比较</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">No.</th>
<th style="text-align:center">区别点</th>
<th style="text-align:center">this</th>
<th style="text-align:center">super</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">访问属性</td>
<td style="text-align:center">访问本类中的属性，若本类中没有此属性，则从父类中继续查找</td>
<td style="text-align:center">访问父类中的属性</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">调查方法</td>
<td style="text-align:center">访问本类中的方法，若本类中没有此方法，则从父类中继续查找</td>
<td style="text-align:center">访问父类中的方法</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">调用构造器</td>
<td style="text-align:center">调用本类的构造器，必须放在构造器首行</td>
<td style="text-align:center">调用父类的构造器，必须放在子类构造器的首行</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">特殊</td>
<td style="text-align:center">表示当前对象</td>
<td style="text-align:center">子类中访问父类对象</td>
</tr>
</tbody>
</table>
<h4 id="方法重写覆盖"><a class="markdownIt-Anchor" href="#方法重写覆盖"></a> 方法重写/覆盖</h4>
<p>方法重写就是子类有一个方法，和父类的某个方法的名称、返回类型、参数一样，那么就说子类的这个方法覆盖了父类的方法。</p>
<p><strong>注意事项</strong></p>
<ul>
<li>子类的方法的参数、方法名称要和父类方法的参数、名称完全一样</li>
<li>子类的方法的返回类型要和父类方法的返回类型一样，或者是父类返回类型的子类。例如：父类返回类型为<code>Object</code>,子类方法的返回类型可以是<code>String</code>。</li>
<li>子类方法不能缩小父类方法的访问权限：<code>public &gt; protected &gt; 默认 &gt; private</code></li>
</ul>
<h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3>
<p>方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承的基础之上的。</p>
<p><strong>作用：</strong> 提高代码的复用性</p>
<ul>
<li>方法的多态：方法的<code>重载 和 重写</code>就体现多态</li>
<li><strong>对象的多态：【核心】</strong>
<ul>
<li>**一个对象的编译类型和运行类型可以不一致。**例如：<code>Animal animal = new Dog()</code>；可以让一个父类的引用指向子类的对象。<code>animal</code>的编译类型是<code>Animal</code>，运行类型是<code>Dog</code></li>
<li>编译类型在定义对象时，就确定了，不能改变</li>
<li>运行类型是可以变化的。</li>
<li>编译类型看定义时 <code>=</code> 左边，运行类型看 <code>=</code> 右边。</li>
</ul>
</li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>两个类存在继承关系</li>
<li>多态是向上转型
<ul>
<li>本质：父类的引用指向子类对象</li>
<li>语法：<code>父类类型 引用名 = new 子类类型()</code></li>
<li>特点：编译类型看左边，运行类型看右边</li>
</ul>
</li>
<li>多态的向下转型
<ul>
<li>语法：<code>子类类型 引用名 = (子类类型) 父类引用</code>；</li>
<li>只能强转父类的引用，不能强转父类的对象</li>
<li>要求父类的引用必须指向的是当前目标类型的对象</li>
<li>可以调用子类类型中所有的成员日</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 向上转型</span></span><br><span class="line"><span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) animal; <span class="comment">// 向下转型</span></span><br><span class="line"></span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) animal; <span class="comment">// 错误，animal原来是Dog类型，不能转为cat</span></span><br></pre></td></tr></table></figure>
<p><strong>属性重写：</strong></p>
<ul>
<li>属性没有重写之说，属性的值看编译类型。</li>
<li><code>instanceof</code> 比较操作符，用于判断对象的运行类型是否为XX类型或XX类型的子类型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Base</span> <span class="variable">base</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(base.count); <span class="comment">// 10，看编译类型</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(base <span class="keyword">instanceof</span> Sub); <span class="comment">// True</span></span><br><span class="line">        System.out.println(base <span class="keyword">instanceof</span> Base); <span class="comment">// True</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">Sub</span> <span class="variable">sub</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">        System.out.println(sub <span class="keyword">instanceof</span> Sub); <span class="comment">// True</span></span><br><span class="line">        System.out.println(sub <span class="keyword">instanceof</span> Base); <span class="comment">// True</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="java动态绑定机制"><a class="markdownIt-Anchor" href="#java动态绑定机制"></a> java动态绑定机制 ⭐</h4>
<ul>
<li>Java重要特性：<code>动态绑定机制</code></li>
<li>当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定</li>
<li>当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.poly._dynamic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicBinding</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        System.out.println(a.sum()); <span class="comment">// 30  动态绑定机制，所以调用父类的sum，所以 getI()是B的为20  20 + 10</span></span><br><span class="line">        System.out.println(a.sum1()); <span class="comment">// 20  属性没有动态绑定机制，所以调用父类的sum1，所以 i为10  10 + 10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getI() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    public int sum()&#123;</span></span><br><span class="line">    <span class="comment">//        return getI() + 20;</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    public int sum1()&#123;</span></span><br><span class="line"><span class="comment">//        return i + 20;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多态的应用"><a class="markdownIt-Anchor" href="#多态的应用"></a> 多态的应用</h4>
<ul>
<li>多态数组：数组的定义类型为父类型，里面保存的实际元素类型为子类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tes</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        Person[] person =  <span class="keyword">new</span> <span class="title class_">Person</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        Person[<span class="number">0</span>] = student;</span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line">        Person[<span class="number">1</span>] = teacher;</span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; person.length; i++)&#123;</span><br><span class="line">            <span class="comment">//person[i] 编译类型是Person，运行类型是根据实际情况由JVN来判断</span></span><br><span class="line">            System.out.println(person[i].say());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 因为teach() 和study() 不存在于Person类中，所以需要判断后进行向下强转</span></span><br><span class="line">            <span class="keyword">if</span>(person[i] <span class="keyword">instanceof</span> Student)&#123;</span><br><span class="line">                <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> (Student) person[i];</span><br><span class="line">                s.study();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(person[i] <span class="keyword">instanceof</span> Teacher)&#123;</span><br><span class="line">                ((Teacher) person[i]).teach();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 老师类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多态参数：方法定义的参数类型为父类，实参类型允许是子类类型。</li>
</ul>
<h2 id="object-类详解"><a class="markdownIt-Anchor" href="#object-类详解"></a> Object 类详解</h2>
<h3 id="equal方法"><a class="markdownIt-Anchor" href="#equal方法"></a> <code>equal</code>方法</h3>
<ul>
<li><code>==</code> 既可以判断基本类型，又可以判断引用类型</li>
<li><code>==</code> 如果判断基本类型，判断的是值是否相等，</li>
<li><code>==</code> 如果判断引用类型，判断的是地址是否相等，<strong>即判断的是否是同一个对象</strong></li>
<li><code>equal</code> 是<code>Object</code>类中的方法，只能判断引用类型</li>
<li>默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String类中重写的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hashcode方法"><a class="markdownIt-Anchor" href="#hashcode方法"></a> <code>hashCode</code>方法</h3>
<ul>
<li>提高具有哈希表结构的容器的效率</li>
<li>两个引用，如果指向的是同一个对象，则哈希值肯定是一样</li>
<li>两个引用，如果指向的是不同对象，则哈希值不一样</li>
<li>哈希值主要是根据地址号来的，不能完全将哈希值等价于地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa2</span> <span class="operator">=</span> aa;</span><br><span class="line">        System.out.println(aa.hashCode);</span><br><span class="line">        System.out.println(aa1.hashCode);  <span class="comment">//aa1 和 aa的hashcode相同</span></span><br><span class="line">        System.out.println(aa2.hashCode);  <span class="comment">// aa2 和 aa的hashcode相同</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tostring方法"><a class="markdownIt-Anchor" href="#tostring方法"></a> <code>toString</code>方法</h3>
<p>默认返回：<code>全类名 + @ + 哈希值的十六进制</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object 类中的toString方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Integer.toHexString(hashCode()); 将对象以hashcode值转成十六进制返回</span></span><br></pre></td></tr></table></figure>
<ul>
<li>重写<code>toString</code>方法，在类中使用快捷键<code>alt + insert</code> 然后选中<code>toString</code>即可</li>
<li>当直接输出一个对象时，<code>toString</code>方法会被默认调用</li>
</ul>
<h3 id="finalize方法"><a class="markdownIt-Anchor" href="#finalize方法"></a> <code>finalize</code>方法</h3>
<ul>
<li>当对象被回收时，系统会自动调用该对象的<code>finalize</code>方法。子类可以重写该方法，做一些释放资源的操作</li>
<li>什么时候被回收：当某个对象没有任何引用时，则<code>jvm</code>就认为该对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用<code>finalize</code>方法</li>
<li>垃圾回收机制的调用，是由系统来决定（即有自己的<code>GC算法</code>），也可以通过<code>System.gc()</code>主动触发垃圾回收机制。</li>
</ul>
<h2 id="断点调试"><a class="markdownIt-Anchor" href="#断点调试"></a> 断点调试</h2>
<p>在断点调试过程中，试运行状态，是以对象的运行类型来执行的。</p>
<ul>
<li>断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而会找到这个Bug</li>
</ul>
<h3 id="快捷键-2"><a class="markdownIt-Anchor" href="#快捷键-2"></a> 快捷键</h3>
<table>
<thead>
<tr>
<th style="text-align:center">快捷键</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>F7</code></td>
<td style="text-align:center">跳入方法内</td>
</tr>
<tr>
<td style="text-align:center"><code>F8</code></td>
<td style="text-align:center">跳过，逐行执行代码</td>
</tr>
<tr>
<td style="text-align:center"><code>shift + F8</code></td>
<td style="text-align:center">跳出方法</td>
</tr>
<tr>
<td style="text-align:center"><code>F9</code></td>
<td style="text-align:center">resume，执行到下一个断点</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing LeetCode究极班 Week1</title>
    <url>/2022/03/22/AcWing/LeetCode_Week1/</url>
    <content><![CDATA[<h2 id="学习平台"><a class="markdownIt-Anchor" href="#学习平台"></a> 学习平台</h2>
<p><strong><a href="https://www.acwing.com/activity/content/31/"> AcWing LeetCode究极班 </a></strong></p>
<p><strong><a href="https://leetcode-cn.com/"> LeetCode </a></strong></p>
<h2 id="let-1两数之和"><a class="markdownIt-Anchor" href="#let-1两数之和"></a> Let 1：两数之和</h2>
<p>给定一个整数数组<code>nums</code>和一个整数目标值<code>target</code>，请你在该数组中找出<strong>和为目标值</strong><code>target</code>的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<p>示例 1：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 104</code></li>
<li><code>109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>109 &lt;= target &lt;= 109</code></li>
<li><strong>只会存在一个有效答案</strong></li>
</ul>
<p>**进阶：**你可以想出一个时间复杂度小于 <code>O(n^2)</code> 的算法吗？</p>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>;j&lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j] == target)&#123;</span><br><span class="line">                    arr.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    arr.<span class="built_in">push_back</span>(j);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-2两数相加"><a class="markdownIt-Anchor" href="#let-2两数相加"></a> Let 2：两数相加</h2>
<p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="img" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 9</code></li>
<li>题目数据保证列表表示的数字不含前导零</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>); <span class="comment">// 生成一个新的头节点，指向结果</span></span><br><span class="line">        <span class="keyword">auto</span> cur = dummy; <span class="comment">// 一个指针，指向结果链表的尾节点</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">//用来保存进位</span></span><br><span class="line">        <span class="keyword">while</span>(l1 || l2 || t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1) t += l1 -&gt; val, l1 = l1 -&gt; next;</span><br><span class="line">            <span class="keyword">if</span>(l2) t += l2 -&gt; val, l2 = l2 -&gt; next;</span><br><span class="line">            cur -&gt; next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(t % <span class="number">10</span>); <span class="comment">// 取出个位加入生成新节点</span></span><br><span class="line">            cur = cur -&gt; next; <span class="comment">// 更新尾指针</span></span><br><span class="line">            t /= <span class="number">10</span>;  <span class="comment">// 去除进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-3无重复字符的最长子串"><a class="markdownIt-Anchor" href="#let-3无重复字符的最长子串"></a> Let 3：无重复字符的最长子串</h2>
<p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 最长子串 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>0 &lt;= s.length &lt;= 5 * 104</code></li>
<li><code>s</code>由英文字母、数字、符号和空格组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; head; <span class="comment">// hash map</span></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i ++)&#123;</span><br><span class="line">            head[s[i]]++;</span><br><span class="line">            <span class="keyword">while</span>(head[s[i]] &gt; <span class="number">1</span>) head[s[j++]]--;</span><br><span class="line">            res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-4寻找两个正序数组的中位数"><a class="markdownIt-Anchor" href="#let-4寻找两个正序数组的中位数"></a> Let 4：寻找两个正序数组的中位数</h2>
<p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m &lt;= 1000</code></li>
<li><code>0 &lt;= n &lt;= 1000</code></li>
<li><code>1 &lt;= m + n &lt;= 2000</code></li>
<li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; arr; <span class="comment">// 将两个数组合并后的数组</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt;= nums2[j])</span><br><span class="line">                arr.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                arr.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.<span class="built_in">size</span>()) arr.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.<span class="built_in">size</span>()) arr.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; arr.<span class="built_in">size</span>(); k++) cout &lt;&lt; arr[k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(len % <span class="number">2</span> != <span class="number">0</span>)&#123; <span class="comment">// 合并后的数组长度是奇数</span></span><br><span class="line">            <span class="keyword">return</span> arr[len / <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 合并后的数组长度是偶数</span></span><br><span class="line">            <span class="built_in">return</span> (arr[len / <span class="number">2</span>] + arr[len / <span class="number">2</span> - <span class="number">1</span>]) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-5最长回文子串"><a class="markdownIt-Anchor" href="#let-5最长回文子串"></a> Let 5：最长回文子串 *</h2>
<p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li>s 仅由数字和英文字母组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> l = i - <span class="number">1</span>, r = i + <span class="number">1</span>;<span class="comment">//回文串为偶数个的情况</span></span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() &lt; r - l - <span class="number">1</span>) res = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            l = i, r = i + <span class="number">1</span>; <span class="comment">//回文串为奇数个的情况</span></span><br><span class="line">            <span class="keyword">while</span>(l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= s.<span class="built_in">size</span>() &amp;&amp; s[l] == s[r]) l --, r ++;</span><br><span class="line">            <span class="keyword">if</span>(res.<span class="built_in">size</span>() &lt; r - l <span class="number">-1</span>) res = s.<span class="built_in">substr</span>(l + <span class="number">1</span>, r - l <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-6z-字形变换"><a class="markdownIt-Anchor" href="#let-6z-字形变换"></a> Let 6：Z 字形变换</h2>
<p>将一个给定字符串 <code>s</code> 根据给定的行数 <code>numRows</code> ，以从上往下、从左到右进行 Z 字形排列。</p>
<p>比如输入字符串为 <code>&quot;PAYPALISHIRING&quot;</code> 行数为 <code>3</code> 时，排列如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure>
<p>之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<code>&quot;PAHNAPLSIIGYIR&quot;</code>。</p>
<p>请你实现这个将字符串进行指定行数变换的函数：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">string convert(string s, int numRows);</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">输出：&quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">输出：&quot;PINALSIGYAHRPI&quot;</span><br><span class="line">解释：</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;A&quot;, numRows = 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 由英文字母（小写和大写）、<code>','</code> 和 <code>'.'</code> 组成</li>
<li><code>1 &lt;= numRows &lt;= 1000</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>)</span><br><span class="line">                    res += s[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * n - <span class="number">2</span> - i; j &lt; s.<span class="built_in">size</span>() || k &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * n - <span class="number">2</span>, k += <span class="number">2</span> * n - <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; s.<span class="built_in">size</span>()) res += s[j];</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) res += s[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-7整数反转"><a class="markdownIt-Anchor" href="#let-7整数反转"></a> Let 7：整数反转</h2>
<p>给你一个 32 位的有符号整数 <code>x</code> ，返回将 <code>x</code> 中的数字部分反转后的结果。</p>
<p>如果反转后整数超过 32 位的有符号整数的范围 <code>[−231, 231 − 1]</code> ，就返回 0。</p>
<p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 123</span><br><span class="line">输出：321</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = -123</span><br><span class="line">输出：-321</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 120</span><br><span class="line">输出：21</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">-9</span> &amp;&amp; x &lt;= <span class="number">9</span>) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans &lt; <span class="number">-2147483648</span> || ans &gt; <span class="number">2147483647</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-8字符串转换整数atoi"><a class="markdownIt-Anchor" href="#let-8字符串转换整数atoi"></a> Let 8：字符串转换整数(atoi) *</h2>
<p>请你来实现一个 <code>myAtoi(string s)</code> 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 <code>atoi</code> 函数）。</p>
<p>函数 <code>myAtoi(string s)</code> 的算法如下：</p>
<ol>
<li>读入字符串并丢弃无用的前导空格</li>
<li>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</li>
<li>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</li>
<li>将前面步骤读入的这些数字转换为整数（即，“123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为<code>0</code> 。必要时更改符号（从步骤 2 开始）。</li>
<li>如果整数数超过 32 位有符号整数范围 <code>[−231, 231 − 1]</code> ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 <code>−231</code> 的整数应该被固定为 <code>−231</code>，大于 <code>231 − 1</code> 的整数应该被固定为 <code>231 − 1</code> 。</li>
<li>返回整数作为最终结果。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>本题中的空白字符只包括空格字符<code>' '</code> 。</li>
<li>除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br><span class="line">解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><br><span class="line">第 1 步：&quot;42&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         <span class="built_in">^</span></span><br><span class="line">第 2 步：&quot;42&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         <span class="built_in">^</span></span><br><span class="line">第 3 步：&quot;42&quot;（读入 &quot;42&quot;）</span><br><span class="line">           <span class="built_in">^</span></span><br><span class="line">解析得到整数 42 。</span><br><span class="line">由于 &quot;42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;   -42&quot;（读入前导空格，但忽视掉）</span><br><span class="line">            <span class="built_in">^</span></span><br><span class="line">第 2 步：&quot;   -42&quot;（读入 &#x27;-&#x27; 字符，所以结果应该是负数）</span><br><span class="line">             <span class="built_in">^</span></span><br><span class="line">第 3 步：&quot;   -42&quot;（读入 &quot;42&quot;）</span><br><span class="line">               <span class="built_in">^</span></span><br><span class="line">解析得到整数 -42 。</span><br><span class="line">由于 &quot;-42&quot; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br><span class="line">解释：</span><br><span class="line">第 1 步：&quot;4193 with words&quot;（当前没有读入字符，因为没有前导空格）</span><br><span class="line">         <span class="built_in">^</span></span><br><span class="line">第 2 步：&quot;4193 with words&quot;（当前没有读入字符，因为这里不存在 &#x27;-&#x27; 或者 &#x27;+&#x27;）</span><br><span class="line">         <span class="built_in">^</span></span><br><span class="line">第 3 步：&quot;4193 with words&quot;（读入 &quot;4193&quot;；由于下一个字符不是一个数字，所以读入停止）</span><br><span class="line">             <span class="built_in">^</span></span><br><span class="line">解析得到整数 4193 。</span><br><span class="line">由于 &quot;4193&quot; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 200</code></li>
<li><code>s</code> 由英文字母（大写和小写）、数字<code>（0-9）</code>、<code>' '</code>、<code>'+'</code>、<code>'-'</code> 和 <code>'.'</code> 组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == <span class="string">&#x27; &#x27;</span>) k++; <span class="comment">//去掉前导空格</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> minus = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s[k] == <span class="string">&#x27;-&#x27;</span>) minus = <span class="number">-1</span>, k++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[k] == <span class="string">&#x27;+&#x27;</span>) k++;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[k] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> x = s[k] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(minus &gt; <span class="number">0</span> &amp;&amp; res &gt; (INT_MAX - x) / <span class="number">10</span>) <span class="keyword">return</span> INT_MAX; <span class="comment">//加上x后会超出上界</span></span><br><span class="line">            <span class="keyword">if</span>(minus &lt; <span class="number">0</span> &amp;&amp; -res &lt; (INT_MIN + x) / <span class="number">10</span>) <span class="keyword">return</span> INT_MIN; <span class="comment">//加上x后会超出下界</span></span><br><span class="line">            <span class="keyword">if</span> (-res * <span class="number">10</span> - x == INT_MIN) <span class="keyword">return</span> INT_MIN; <span class="comment">//加上x刚好等于下界</span></span><br><span class="line">            res = res * <span class="number">10</span> + x;</span><br><span class="line">            k++;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; INT_MAX) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= minus;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-9回文数"><a class="markdownIt-Anchor" href="#let-9回文数"></a> Let 9：回文数</h2>
<p>给你一个整数 <code>x</code> ，如果 <code>x</code>是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，<code>121</code> 是回文，而 <code>123</code> 不是。</li>
</ul>
<p>示例 1：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：x = 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = x;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + m % <span class="number">10</span>;</span><br><span class="line">            m /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-10正则表达式匹配"><a class="markdownIt-Anchor" href="#let-10正则表达式匹配"></a> Let 10：正则表达式匹配 *</h2>
<p>给你一个字符串 <code>s</code> 和一个字符规律 <code>p</code>，请你来实现一个支持<code>'.'</code>和<code>'*'</code> 的正则表达式匹配。</p>
<ul>
<li><code>'.'</code>匹配任意单个字符</li>
<li><code>'*'</code> 匹配零个或多个前面的那一个元素</li>
</ul>
<p>所谓匹配，是要涵盖 <strong>整个</strong> 字符串 <code>s</code>的，而不是部分字符串。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aa&quot;, p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab&quot;, p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 20</code></li>
<li><code>1 &lt;= p.length &lt;= 30</code></li>
<li><code>s</code> 只包含从 <code>a-z</code> 的小写字母。</li>
<li><code>p</code> 只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code>和<code>*</code>。</li>
<li>保证每次出现字符<code>*</code>时，前面都匹配到有效的字符</li>
</ul>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>AcWing</tag>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing LeetCode究极班 Week2</title>
    <url>/2022/03/24/AcWing/LeetCode_Week2/</url>
    <content><![CDATA[<h2 id="学习平台"><a class="markdownIt-Anchor" href="#学习平台"></a> 学习平台</h2>
<p><strong><a href="https://www.acwing.com/activity/content/31/"> AcWing LeetCode究极班 </a></strong></p>
<p><strong><a href="https://leetcode-cn.com/"> LeetCode </a></strong></p>
<h2 id="let-11盛水最多的容器"><a class="markdownIt-Anchor" href="#let-11盛水最多的容器"></a> Let 11：盛水最多的容器 *</h2>
<p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。</p>
<p>找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p>
<p>返回容器可以储存的最大水量。</p>
<p>**说明：**你不能倾斜容器。</p>
<p><strong>标签：</strong> <code>贪心</code>、<code>数组</code>、<code>双指针</code></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：height = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == height.length</code></li>
<li><code>2 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= height[i] &lt;= 104</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = len - <span class="number">1</span>; i &lt; j;)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j]) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-12整数转罗马数字"><a class="markdownIt-Anchor" href="#let-12整数转罗马数字"></a> Let 12：整数转罗马数字</h2>
<p>罗马数字包含以下七种字符： <code>I</code>，<code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code>+ <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给你一个整数，将其转为罗马数字。</p>
<p><strong>标签：</strong> <code>哈希表</code>  <code>数学</code>  <code>字符串</code></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: num = 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= num &lt;= 3999</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">intToRoman</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">1000</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">while</span>(a--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;M&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">900</span> &amp;&amp; num &lt; <span class="number">1000</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;CM&quot;</span>;</span><br><span class="line">                num %= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;=<span class="number">500</span> &amp;&amp; num &lt; <span class="number">900</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">100</span>;</span><br><span class="line">                res += <span class="string">&quot;D&quot;</span>;</span><br><span class="line">                <span class="type">int</span> sum = a - <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">while</span>(sum--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;C&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">400</span> &amp;&amp; num &lt; <span class="number">500</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;CD&quot;</span>;</span><br><span class="line">                num %= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">100</span> &amp;&amp; num &lt; <span class="number">400</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">while</span>(a--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;C&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">90</span> &amp;&amp; num &lt; <span class="number">100</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;XC&quot;</span>;</span><br><span class="line">                num %= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">50</span> &amp;&amp; num &lt; <span class="number">90</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">10</span>;</span><br><span class="line">                res += <span class="string">&quot;L&quot;</span>;</span><br><span class="line">                <span class="type">int</span> sum = a<span class="number">-5</span>;</span><br><span class="line">                <span class="keyword">while</span>(sum--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;X&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">40</span> &amp;&amp; num &lt; <span class="number">50</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;XL&quot;</span>;</span><br><span class="line">                num %= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt; <span class="number">40</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">while</span>(a--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;X&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span>(num &gt;= <span class="number">9</span> &amp;&amp; num &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;IX&quot;</span>;</span><br><span class="line">                num %= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">5</span> &amp;&amp; num &lt; <span class="number">9</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">1</span>;</span><br><span class="line">                res += <span class="string">&quot;V&quot;</span>;</span><br><span class="line">                <span class="type">int</span> sum = a<span class="number">-5</span>;</span><br><span class="line">                <span class="keyword">while</span>(sum--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;I&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">4</span> &amp;&amp; num &lt; <span class="number">5</span>)&#123;</span><br><span class="line">                res += <span class="string">&quot;IV&quot;</span>;</span><br><span class="line">                num %= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(num &gt;= <span class="number">1</span> &amp;&amp; num &lt; <span class="number">4</span>)&#123;</span><br><span class="line">                <span class="type">int</span> a = num / <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(a--)&#123;</span><br><span class="line">                    res += <span class="string">&quot;I&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                num %= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-13罗马数字转整数"><a class="markdownIt-Anchor" href="#let-13罗马数字转整数"></a> Let 13：罗马数字转整数</h2>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code>+ <code>II</code> 。 <code>27</code> 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code>+ <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。</p>
<p><strong>标签：</strong> <code>哈希表</code>  <code>数学</code>  <code>字符串</code></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 15</code></li>
<li><code>s</code> 仅含字符 <code>('I', 'V', 'X', 'L', 'C', 'D', 'M')</code></li>
<li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li>
<li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li>
<li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li>
<li>关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> value[] = &#123;</span><br><span class="line">            <span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        string reps[] = &#123;</span><br><span class="line">            <span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>; i &lt; s.<span class="built_in">length</span>(); i++, j++)&#123;</span><br><span class="line">            string stri = s.<span class="built_in">substr</span>(i, <span class="number">1</span>);</span><br><span class="line">            string strj = s.<span class="built_in">substr</span>(j, <span class="number">1</span>);</span><br><span class="line">            string str;</span><br><span class="line">            <span class="type">int</span> a, b;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">13</span>; k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(stri == reps[k]) a = k;</span><br><span class="line">                <span class="keyword">if</span>(strj == reps[k]) b = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b &lt; a)&#123; <span class="comment">// 需要截取两个</span></span><br><span class="line">                str = s.<span class="built_in">substr</span>(i, <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">13</span>; k ++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(str == reps[k])&#123;</span><br><span class="line">                        res += value[k];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i++; <span class="comment">// 跳过一位</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res += value[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-14最长公共前缀"><a class="markdownIt-Anchor" href="#let-14最长公共前缀"></a> Let 14：最长公共前缀</h2>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p><strong>标签：</strong> <code>字符串</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 200</code></li>
<li><code>0 &lt;= strs[i].length &lt;= 200</code></li>
<li><code>strs[i]</code> 仅由小写英文字母组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 寻找str 和 fl 最长公共前缀</span></span><br><span class="line">    <span class="function">string <span class="title">Juge</span><span class="params">(string str, string fl)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">min</span>(str.<span class="built_in">length</span>(), fl.<span class="built_in">length</span>());</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i ++)&#123;</span><br><span class="line">            string a = str.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            string b = fl.<span class="built_in">substr</span>(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span>(a != b &amp;&amp; i == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a != b &amp;&amp; i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                p = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(a == b &amp;&amp; i == len)&#123;</span><br><span class="line">                p = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">substr</span>(<span class="number">0</span>, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        string str = strs[<span class="number">0</span>]; <span class="comment">// str 存放最长公共子串;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            str = <span class="built_in">Juge</span>(str, strs[i]);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; str &lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">if</span>(str == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-15三数之和"><a class="markdownIt-Anchor" href="#let-15三数之和"></a> Let 15：三数之和</h2>
<p>给你一个包含 <code>n</code> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p>
<p>注意：答案中不可以包含重复的三元组。</p>
<p><strong>标签：</strong> <code>数组</code>  <code>双指针</code>  <code>排序</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 3000</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<p>对数组进行排序后，先确定其中一个值，然后使用双指针确定另外两个值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">3</span> ) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i ==<span class="number">0</span> || i != <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="type">int</span> a = <span class="number">0</span> - nums[i];</span><br><span class="line">                <span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[l] + nums[r] &lt; a)&#123;</span><br><span class="line">                        l ++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(nums[l] + nums[r] &gt; a)&#123;</span><br><span class="line">                        r --;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">                        arr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                        arr.<span class="built_in">push_back</span>(nums[l]);</span><br><span class="line">                        arr.<span class="built_in">push_back</span>(nums[r]);</span><br><span class="line">                        res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">                        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k = l + <span class="number">1</span>; k &lt; r; k++)&#123; <span class="comment">// 往后找到第一个不和左边界相等的点。</span></span><br><span class="line">                            <span class="keyword">if</span>(nums[k] != nums[l])&#123;</span><br><span class="line">                                l = k;</span><br><span class="line">                                flag = <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;  <span class="comment">//找到右边界仍然没有找到。</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-16最接近的三数之和"><a class="markdownIt-Anchor" href="#let-16最接近的三数之和"></a> Let 16：最接近的三数之和</h2>
<p>给你一个长度为 <code>n</code> 的整数数组 <code>nums</code> 和 一个目标值 <code>target</code>。请你从 <code>nums</code> 中选出三个整数，使它们的和与 <code>target</code> 最接近。</p>
<p>返回这三个数的和。</p>
<p>假定每组输入只存在恰好一个解。</p>
<p><strong>标签：</strong> <code>数组</code>  <code>双指针</code>  <code>排序</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0], target = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= nums.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> max = <span class="number">100010</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> cnt = nums[i] + nums[l] + nums[r]; <span class="comment">// 三数之和</span></span><br><span class="line">                cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(cnt - target) &lt; max)&#123; <span class="comment">// 若此时更接近目标值，则更新</span></span><br><span class="line">                    max = <span class="built_in">abs</span>(nums[i] + nums[l] + nums[r] - target);</span><br><span class="line">                    res = cnt;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cnt &lt; target)&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(cnt &gt; target)&#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">//刚好等于目标值，则直接输出目标值即可。</span></span><br><span class="line">                    <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-17电话号码的字母组合"><a class="markdownIt-Anchor" href="#let-17电话号码的字母组合"></a> Let 17：电话号码的字母组合</h2>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><strong>标签：</strong> <code>哈希表</code>  <code>字符串</code>  <code>回溯</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= digits.length &lt;= 4</code></li>
<li><code>digits[i]</code> 是范围 <code>['2', '9']</code> 的一个数字。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string str[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="built_in">dfs</span>(digits, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(string&amp; digits, <span class="type">int</span> u, string path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(u &gt;= digits.<span class="built_in">size</span>()) ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> t = digits[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> c : str[t])&#123;</span><br><span class="line">                <span class="built_in">dfs</span>(digits, u + <span class="number">1</span>, path + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-18四数之和"><a class="markdownIt-Anchor" href="#let-18四数之和"></a> Let 18：四数之和</h2>
<p>给你一个由 <code>n</code> 个整数组成的数组 <code>nums</code> ，和一个目标值 <code>target</code> 。请你找出并返回满足下述全部条件且不重复的四元组 <code>[nums[a], nums[b], nums[c], nums[d]]</code> （若两个四元组元素一一对应，则认为两个四元组重复）：</p>
<ul>
<li><code>0 &lt;= a, b, c, d &lt; n</code></li>
<li><code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 互不相同</li>
<li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li>
</ul>
<p>你可以按 <strong>任意顺序</strong> 返回答案 。</p>
<p><strong>标签：</strong> <code>数组</code>  <code>双指针</code>  <code>排序</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,-1,0,-2,2], target = 0</span><br><span class="line">输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,2,2,2], target = 8</span><br><span class="line">输出：[[2,2,2,2]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">4</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">3</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || i != <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j == i + <span class="number">1</span> || j != i + <span class="number">1</span> &amp;&amp; nums[j] != nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                        <span class="type">int</span> cnt = target - nums[i] - nums[j];</span><br><span class="line">                        <span class="type">int</span> l = j + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(nums[l] + nums[r] &lt; cnt)&#123;</span><br><span class="line">                                l++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(nums[l] + nums[r] &gt; cnt)&#123;</span><br><span class="line">                                r--;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">                                <span class="comment">// cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;&lt;&lt;nums[j]&lt;&lt;&quot; &quot;&lt;&lt; nums[l]&lt;&lt;&quot; &quot;&lt;&lt;nums[r]&lt;&lt;endl;</span></span><br><span class="line">                                vector&lt;<span class="type">int</span>&gt; arr&#123;nums[i], nums[j], nums[l], nums[r]&#125;;</span><br><span class="line">                                res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">                                <span class="keyword">for</span>(<span class="type">int</span> k = l + <span class="number">1</span>; k &lt; r; k++)&#123;</span><br><span class="line">                                    <span class="keyword">if</span>(nums[k] != nums[l])&#123;</span><br><span class="line">                                        l = k;</span><br><span class="line">                                        flag = <span class="literal">true</span>;</span><br><span class="line">                                        <span class="keyword">break</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// bool flag = false;</span></span><br><span class="line">                        <span class="comment">// for(int k = j + 1; k &lt; nums.size() - 2; k++)&#123;  // 跳转到下一个不重复的地方</span></span><br><span class="line">                        <span class="comment">//     if(nums[k] != nums[j])&#123;</span></span><br><span class="line">                        <span class="comment">//         j = k - 1; // 因为后面还要j++，所以需要先跳转到k-1；</span></span><br><span class="line">                        <span class="comment">//         flag = true;</span></span><br><span class="line">                        <span class="comment">//         break;</span></span><br><span class="line">                        <span class="comment">//     &#125;</span></span><br><span class="line">                        <span class="comment">// &#125;</span></span><br><span class="line">                        <span class="comment">// if(!flag) break;</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-19删除链表的倒数第n个节点"><a class="markdownIt-Anchor" href="#let-19删除链表的倒数第n个节点"></a> Let  19：删除链表的倒数第N个节点</h2>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>标签：</strong> <code>链表</code>  <code>双指针</code></p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img" /></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：head = [1], n = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], n = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 sz</li>
<li>1 &lt;= sz &lt;= 30</li>
<li>0 &lt;= Node.val &lt;= 100</li>
<li>1 &lt;= n &lt;= sz</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode *k = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            ListNode *p = head;  <span class="comment">// 最后要删除的就是p所指向的节点，他的后继节点就是k</span></span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next != k)&#123;</span><br><span class="line">                p = p -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            k = p;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *p = head;</span><br><span class="line">        <span class="keyword">if</span>(p == k)&#123;</span><br><span class="line">            head = k -&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p -&gt; next != k)&#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p-&gt;next = k-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="let-20有效的括号"><a class="markdownIt-Anchor" href="#let-20有效的括号"></a> Let 20：有效的括号</h2>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'&#123;'</code>，<code>'&#125;'</code>，<code>'['</code>，<code>']'</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br />
左括号必须以正确的顺序闭合。</p>
<p><strong>标签：</strong> <code>栈</code>  <code>字符串</code></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;([)]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 仅由括号 <code>'()[]&#123;&#125;'</code> 组成</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123; <span class="comment">//匹配到左括号</span></span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;  <span class="comment">//栈内有左括号</span></span><br><span class="line">                <span class="type">char</span> c = sta.<span class="built_in">top</span>();</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span> &amp;&amp; s[i] == <span class="string">&#x27;]&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; s[i] == <span class="string">&#x27;&#125;&#x27;</span> || c == <span class="string">&#x27;(&#x27;</span> &amp;&amp; s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sta.<span class="built_in">size</span>()==<span class="number">0</span>)&#123;  <span class="comment">//栈内已经没有左括号了，但是来了右括号。</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sta.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123; <span class="comment">// 还有左括号未匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>AcWing</tag>
        <tag>LeetCode</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing 算法基础课</title>
    <url>/2022/03/20/AcWing/Algorithm_Basic/</url>
    <content><![CDATA[<h2 id="学习平台"><a class="markdownIt-Anchor" href="#学习平台"></a> 学习平台</h2>
<p><strong><a href="https://www.acwing.com/activity/content/11/">AcWing 算法基础课 </a></strong></p>
<h2 id="基础算法"><a class="markdownIt-Anchor" href="#基础算法"></a> 基础算法</h2>
<h3 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h3>
<p><strong>算法思想</strong> <kbd>分治</kbd></p>
<p>分支算法可分为三步：</p>
<ul>
<li>分成子问题</li>
<li>递归处理子问题</li>
<li>子问题合并</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 快速排序：先排序后分治</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quick_sort</span><span class="params">(<span class="type">int</span> p[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;  <span class="comment">// 边界问题</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = p[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;  <span class="comment">// 分界点(哨兵)取中间值</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++ ;<span class="keyword">while</span>(p[i] &lt; x);  <span class="comment">// 在左边找到第一个比哨兵大的数</span></span><br><span class="line">        <span class="keyword">do</span> j-- ;<span class="keyword">while</span>(p[j] &gt; x);  <span class="comment">// 在右边找到第一个比哨兵小的数</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(p[i],p[j]);  <span class="comment">// 交换左右两边的两个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Quick_sort</span>(p, l, j);  <span class="comment">// 递归排序左边界</span></span><br><span class="line">    <span class="built_in">Quick_sort</span>(p, j + <span class="number">1</span>, r);  <span class="comment">// 递归排序有边界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3>
<p><strong>算法思想</strong> <kbd>分治</kbd></p>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序：线分治后排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="type">int</span> p[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)<span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的中间值不能取(l+r+1)/2</span></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">Merge_sort</span>(p,l,mid);</span><br><span class="line">    <span class="built_in">Merge_sort</span>(p,mid+<span class="number">1</span>,r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并两个有序数组，</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>,i = l,j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(p[i] &lt;= p[j]) tmp[k ++] = p[i ++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++] = p[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++]=p[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k ++]=p[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>;i &lt;= r; i ++, j ++) p[i]=tmp[j];</span><br><span class="line">    <span class="comment">//i=l是因为l永远是分组的左边界，不能写成i=0,同理r也永远是分组的右边界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a class="markdownIt-Anchor" href="#二分查找"></a> 二分查找</h3>
<p><strong>算法思想</strong> <kbd>二分</kbd></p>
<p><strong>实现思想</strong> 假定目标值在区间<kbd>[l, r]</kbd> 中，每次将区间长度缩小一半，当<kbd>l = r</kbd> 时，则可以取到目标值。</p>
<p>整数二分查找存在两个模板，取决于中间值的取值方法：</p>
<ul>
<li>当<kbd>mid = l + r &gt;&gt; 1</kbd> 时：</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当<kbd>mid = l + r + 1 &gt;&gt; 1</kbd> 时：</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度加法"><a class="markdownIt-Anchor" href="#高精度加法"></a> 高精度加法</h3>
<p><strong>算法思想</strong> <kbd>大数加法</kbd> ；</p>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B.<span class="built_in">size</span>() &gt; A.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B,A);  <span class="comment">// 让两个大数中长度相对较短的做B，相对较长的做A</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;  <span class="comment">// 用于存放结果</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>; <span class="comment">// 存放进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i]; <span class="comment">//如果B还没有遍历完，需要加上对应位置，若遍历完，则不需要加上了。</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>); <span class="comment">// 若有进位，则只存放个位数字</span></span><br><span class="line">        t /= <span class="number">10</span>; <span class="comment">//将进位保存</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(t); <span class="comment">//最后有进位的话（进位一定是个位数），将进位加入C</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度减法"><a class="markdownIt-Anchor" href="#高精度减法"></a> 高精度减法</h3>
<p><strong>算法思想</strong> <kbd>大数减法</kbd> ；</p>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A - B;需要首先使用bmp函数判断A是否大于B；若A大于B，则结果为正数并sub(A, B)；若A小于B，则结果为负数，需要先输出&#x27;-&#x27;并sub(B, A)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断A是否大于B，若是则返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)  <span class="comment">// 长度相同时，从后往前遍历比较大小</span></span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//相等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//高精度减法</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        t = A[i] - t; <span class="comment">// 若之前有借位，则需要先减去借位</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;<span class="comment">// t &lt; 0 证明有借位</span></span><br><span class="line">        <span class="keyword">else</span> t=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个判断是为了确保结果不是0，若结果是0，则最后一个0不需要去掉</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>(); <span class="comment">//取出前导0  若结果为003，则需要去掉00</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度乘低精度"><a class="markdownIt-Anchor" href="#高精度乘低精度"></a> 高精度乘低精度</h3>
<p><strong>算法思想</strong> <code>大数乘法</code></p>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度除以低精度"><a class="markdownIt-Anchor" href="#高精度除以低精度"></a> 高精度除以低精度</h3>
<p><strong>算法思想</strong> <code>大数除法</code></p>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前缀和"><a class="markdownIt-Anchor" href="#前缀和"></a> 前缀和</h3>
<p><strong>什么是前缀和</strong></p>
<p>原数组：<kbd>a[1], a[2], a[3], a[4], a[5], …, a[n]</kbd><br />
前缀和：<kbd>S[i]</kbd>为数组的前 i项和<br />
前缀和：<kbd>S[i] = a[1] + a[2] + a[3] + … + a[i]</kbd></p>
<p>为方便求解，以及后续方便计算，通常令<kbd>S[0] = 0</kbd> ,<kbd>原数组</kbd> 以及<kbd>前缀和数组</kbd> 的下标从1开始。</p>
<p><strong>前缀和的作用</strong></p>
<p>快速求出元素组中某段区间的和。</p>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pSum</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum[N];  <span class="comment">// 存放数组的前缀和</span></span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        sum[i] = arr[i] + sum[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>二维数组求解前缀和</strong></p>
<p><strong>计算过程</strong> <kbd>s[i, j] = s[i - 1, j] + s[i, j - 1] + s[i - 1, j - 1] + a[i, j]</kbd></p>
<p><img src="/img/AcWing/Basic/%E5%89%8D%E7%BC%80%E5%92%8C.png" alt="前缀和" /></p>
<p>同样的为了方便计算，二维数组下标也需要从 1 开始</p>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">            s[i][j] = s[i][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j]; <span class="comment">// 求前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="comment">// 算子矩阵的和</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x2][y1 - <span class="number">1</span>] - s[x1 - <span class="number">1</span>][y2] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="差分"><a class="markdownIt-Anchor" href="#差分"></a> 差分</h3>
<p><code>差分</code> 和 <code>前缀和</code> 是一对互逆运算</p>
<p><strong>定义</strong> 对于一个给定的数列A，他的差分序列B定义为：</p>
<p><code>B[1] = A[1], B[i] = A[i] - A[i - 1](2 &lt;= i &lt;= n)</code></p>
<hr />
<h2 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h2>
<h3 id="单链表"><a class="markdownIt-Anchor" href="#单链表"></a> 单链表</h3>
<p>这里采用<strong>数组模拟</strong>链表，因为采用new Node()的过程是比较慢的；</p>
<ul>
<li>单链表：可以用于实现邻接表(存储树或图)</li>
<li>双链表：优化某些问题</li>
</ul>
<p><strong>实现方法</strong> 单链表使用数组模拟的方法：使用两个数组<kbd>e[n]</kbd>; <kbd>ne[n]</kbd> 其中<kbd>e[i]</kbd>存放第i个元素的值，<kbd>ne[i]</kbd>存放第i个元素的后继下标。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//head 表示头节点的下标</span></span><br><span class="line"><span class="comment">//e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">//ne[n] 表示节点i的next的值</span></span><br><span class="line"><span class="comment">//idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头节点之前</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx;</span><br><span class="line">    idx ++；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除 下标是k的 后面的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];  <span class="comment">// 相当于 p-&gt;next = p-&gt;next-&gt;next</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在下标为k的节点后插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  	<span class="built_in">init</span>(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链表"><a class="markdownIt-Anchor" href="#双链表"></a> 双链表</h3>
<p>同样使用数组模拟双链表，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在下标是k的节点右边插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;  <span class="comment">//在k的左边插入的话，直接调用 add(l[k], x)</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[k] = idx;</span><br><span class="line">    l[r[idx]] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除下标为k的节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="栈"><a class="markdownIt-Anchor" href="#栈"></a> 栈</h3>
<p>采用<strong>数组模拟栈</strong></p>
<p><strong>实现方法</strong> <kbd>top</kbd>栈顶指针，当<kbd>top == 0</kbd>时栈空，<kbd>stk[N]</kbd>存放元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> top, stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)&#123;  <span class="comment">//入栈</span></span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            stk[++ top] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>) top --;  <span class="comment">// 出栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>) cout &lt;&lt; stk[top] &lt;&lt;endl;  <span class="comment">//输出栈顶元素</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; (top ? <span class="string">&quot;NO&quot;</span> : <span class="string">&quot;YES&quot;</span>) &lt;&lt; endl; <span class="comment">// 判断栈是否为空，top为0 则栈空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h3>
<p>采用<strong>数组模拟队列</strong></p>
<p><strong>实现方法</strong> <kbd>tail</kbd>队尾指针，<kbd>head</kbd>队头指针，当<kbd>head == 0 || head &gt; tail</kbd>时队空，<kbd>que[N]</kbd>存放元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head, que[N], tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            que[++tail] = x;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="number">0</span>) head++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>) head ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;query&quot;</span>) cout &lt;&lt; que[head] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head == <span class="number">0</span> || tail &lt; head) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kmp"><a class="markdownIt-Anchor" href="#kmp"></a> KMP</h3>
<p><strong>定义</strong> 是一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低，</p>
<p><strong>算法习惯</strong> 下标从1开始；存在一个<code>模式串</code>、一个<code>模板串</code></p>
<p><strong>算法精讲</strong></p>
<p><a href="https://www.acwing.com/solution/content/14666/"> KMP字符串 </a></p>
<p><strong>算法思路</strong></p>
<ul>
<li><code>s[n]</code>模式串：即比较长的字符串</li>
<li><code>p[m]</code>模板串：即比较短的字符串</li>
<li><code>ne[m]</code>部分匹配值表：存储的是每一个下标对应的部分匹配值</li>
</ul>
<p><kbd>p[1, j] == p[i - ne[j] + 1, i]</kbd></p>
<p><img src="/img/AcWing/Basic/KMP.png" alt="KMP" /></p>
<ul>
<li>核心思想：在每次匹配失败后，不是把p串向后移动一位，而是把p串往后移动至下一次可以和前面部分匹配的位置，这样就可以跳过大多数的失配步骤。而每次p串移动的步数就是通过查找<code>ne[ ]</code>数组确定的。</li>
</ul>
<p><strong>匹配思路和实现代码</strong></p>
<p>KMP主要分为两步：<kbd>求解ne数组</kbd> ；<kbd>匹配字符串</kbd></p>
<p><code>s[n]</code>和<code>p[m]</code>都是从1开始的，</p>
<ul>
<li><strong>求解ne数组</strong></li>
</ul>
<p>因为<code>p[m]</code>下标从1开始，所以<code>ne[1] = 0</code>，求解<code>ne[]</code>时直接从下标为2开始遍历，i 。j表示当前前面最多匹配了j个字符。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动模拟一遍更清楚。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i++) <span class="comment">// ne[1]默认为0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = next[j]; <span class="comment">//若已经匹配了字符，但是当前又不匹配了，则j需要返回起点。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line"></span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>匹配字符串</strong></li>
</ul>
<p>i 从1开始遍历s数组，j 从0开始遍历p数组。每次将<code>s[i]</code>和<code>p[j + 1]</code>进行比较。若相等，则匹配；若碰到第i个字符不匹配，则直接将<kbd>j = ne[j]</kbd>，i 不变。<strong>通过将遍历p的指针前移来达到p后移的效果。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span></span><br><span class="line">    <span class="comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//当前元素匹配，j移向p串下一位</span></span><br><span class="line">    <span class="keyword">if</span>(j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配成功，进行相关操作</span></span><br><span class="line">        j = next[j];  <span class="comment">//继续匹配下一个子串</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="trie-树"><a class="markdownIt-Anchor" href="#trie-树"></a> Trie 树</h3>
<p><strong>算法定义</strong> 用于快速存储和查找字符串集合的树。</p>
<p><strong>实现思想</strong></p>
<ul>
<li><code>son[N][26]</code> 存放小写字母，因此每个节点最多可以扩展出26边，每代表一个点，每列代表该节点扩展出一条边。</li>
<li><code>cnt[i]</code> 以当前第i个结尾的有单词则为1，否则为0。</li>
<li><code>idx</code> 下标，idx为0时，即代表根节点，又是空节点。</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组模拟的指针</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">//son[N][26]: 存放小写字母，因此每个节点最多可以扩展出26条边</span></span><br><span class="line"><span class="comment">//cnt[N]: 以当前节点扩展的节点有多少个。</span></span><br><span class="line"><span class="comment">//idx: 下标，idx为0是既代表根节点，又是空节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">   	<span class="type">int</span> p = <span class="number">0</span>;  <span class="comment">// 每个单词都是从第一行开始，</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">       	<span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 将小写字母转换为0~25的数字</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++idx;  <span class="comment">//如果p这个节点不存在u这个子节点</span></span><br><span class="line">        p = son[p][u];  <span class="comment">//跳转到p行</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;  <span class="comment">// </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//查询函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; str[i]; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果p后没有u节点，则直接输出0</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集"><a class="markdownIt-Anchor" href="#并查集"></a> 并查集</h3>
<p>**目的：**在近乎<code>O(1)</code>的时间复杂度内支持下面两个操作</p>
<p>​		1.将两个集合合并；</p>
<p>​		2.询问两个元素是否在一个集合中；</p>
<p>**原理：**每个集合用一颗树表示，树根的编号就是整个集合的编号，每个节点存储它的父节点，<code>p[x]</code>表示x的父节点。若<code>p[x] == x</code>，则x为根节点</p>
<p>**问题1：**如何判断树根节点： <kbd>if(p[x] == x)</kbd></p>
<p>**问题2：**如何求x的集合编号：<kbd>while(p[x] != x) x = p[x]</kbd> ；</p>
<p>**问题3：**如何合并两个集合： <code>p[x]</code>是x的集合编号，<code>p[y]</code>是y的集合编号，则<kbd>p[x] = y</kbd> ；</p>
<p>**优化：路径压缩：**当查询过一遍后，将路径上所有的节点直接指向根节点。</p>
<h3 id="代码模板"><a class="markdownIt-Anchor" href="#代码模板"></a> 代码模板</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存放每个节点的父节点，第i个节点的父节点为p[i]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点 + 路径压缩（优化）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) <span class="comment">// 如果不是根节点</span></span><br><span class="line">        p[x] = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;                                                                                                                                           </span><br><span class="line"><span class="comment">// 合并x，y所在的两个集合</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    p[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);  <span class="comment">//将x的祖宗节点的父节点设置为 y的祖宗节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断x，y是否在同一集合中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Judge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">find</span>(x) == <span class="built_in">find</span>(y))	<span class="comment">//祖宗节点是同一个</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h3>
<p><strong>作用</strong> 维护一个数据集合；</p>
<p><strong>需要实现的操作</strong></p>
<ul>
<li>插入一个数；<kbd>heap[++size] = x; up(size)</kbd></li>
<li>求集合当中的最小值；<kbd>heap[1];</kbd></li>
<li>删除最小值；<kbd>heap[1] = heap[size]; size–; down(1);</kbd></li>
<li>删除任意元素；<kbd>heap[k] = heap[size]; size–; down(k); up(k);</kbd></li>
<li>修改任意元素；<kbd>heap[k] = x; down(size); up(size);</kbd></li>
</ul>
<p><strong>基本结构</strong> 是一颗<code>完全二叉树</code>（除了最后一层节点之外，上层节点都是非空，最后一层节点是从左到右依次排布）</p>
<ul>
<li>小根堆：每个节点都满足小于等于左右两边的节点。</li>
</ul>
<p><strong>存储数据结构</strong> 使用数组存储，1号节点是根节点（下标从1开始），左儿子是<code>2x</code> ；右儿子是<code>2x+1</code></p>
<ul>
<li><code>h[N]</code>存储堆中的值, h[1]是堆顶，x的左儿子是<code>2x</code>, 右儿子是<code>2x + 1</code></li>
<li><code>ph[k]</code>存储第k个插入的点在堆中的位置</li>
<li><code>hp[k]</code>存储堆中下标是k的点是第几个插入的</li>
<li><code>size</code> 堆中元素的个数</li>
</ul>
<p><strong>需要的操作</strong></p>
<ul>
<li><code>down(x)</code> 将x节点往下移</li>
<li><code>up(x)</code> 将x节点往上移</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;  <span class="comment">// 存在左孩子并且左孩子比较小</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;  <span class="comment">// 存在右孩子并且有孩子比较小</span></span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t); <span class="comment">// 交换父亲节点 和 相对较小的子节点 </span></span><br><span class="line">        <span class="built_in">down</span>(t);  <span class="comment">//递归遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="stl简介"><a class="markdownIt-Anchor" href="#stl简介"></a> STL简介</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="搜索与图论"><a class="markdownIt-Anchor" href="#搜索与图论"></a> 搜索与图论</h2>
<h3 id="dfs与bfs"><a class="markdownIt-Anchor" href="#dfs与bfs"></a> DFS与BFS</h3>
<p><strong>对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>数据结构</th>
<th>空间</th>
<th>性质</th>
</tr>
</thead>
<tbody>
<tr>
<td>DFS</td>
<td>stack</td>
<td>O(h)</td>
<td>不具有最短性</td>
</tr>
<tr>
<td>BFS</td>
<td>queue</td>
<td>O(2<sup>h</sup>)</td>
<td>“最短路”</td>
</tr>
</tbody>
</table>
<h4 id="深度优先搜索-dfs"><a class="markdownIt-Anchor" href="#深度优先搜索-dfs"></a> 深度优先搜索 DFS</h4>
<p><strong>算法：</strong> <code>回溯</code>、<code>剪枝</code></p>
<h4 id="宽度优先搜索-bfs"><a class="markdownIt-Anchor" href="#宽度优先搜索-bfs"></a> 宽度优先搜索 BFS</h4>
<p>类似于层序遍历</p>
<h3 id="树与图的遍历拓扑排序"><a class="markdownIt-Anchor" href="#树与图的遍历拓扑排序"></a> 树与图的遍历：拓扑排序</h3>
<p>树是一种特殊的图</p>
<h4 id="树与图的存储"><a class="markdownIt-Anchor" href="#树与图的存储"></a> 树与图的存储</h4>
<ul>
<li>有向图
<ul>
<li>邻接矩阵：二维数组，适用于稠密图，<code>T(n) = O(n ^ 2)</code></li>
<li>邻接表：n个节点对应n个单链表，适用于稀疏图。</li>
</ul>
</li>
</ul>
<p><strong>邻接表</strong></p>
<ul>
<li><code>h[N]</code>：所有头节点的集合</li>
<li><code>e[N]</code>：存每个节点的值</li>
<li><code>ne[N]</code>：存每个节点的next值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ; <span class="comment">// 头插</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure>
<h4 id="树与图的深度优先遍历"><a class="markdownIt-Anchor" href="#树与图的深度优先遍历"></a> 树与图的深度优先遍历</h4>
<p>只考虑有向图即可。</p>
<ul>
<li>时间复杂度：<code>O(n + m)</code>，n表示点数，m表示边数</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="树与图的宽度优先遍历"><a class="markdownIt-Anchor" href="#树与图的宽度优先遍历"></a> 树与图的宽度优先遍历</h4>
<ul>
<li>需要使用到队列，在对二叉树使用宽度有点遍历时，其实就是对二叉树进行层序遍历。</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拓扑排序"><a class="markdownIt-Anchor" href="#拓扑排序"></a> 拓扑排序</h4>
<ul>
<li>时间复杂度：<code>O(n + m)</code>，n表示点数，m表示边数</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路径问题"><a class="markdownIt-Anchor" href="#最短路径问题"></a> 最短路径问题</h3>
<p><font color='orange'>常见的<code>最短路径</code>问题</font> ：n点的数量，m边的数量。</p>
<ul>
<li><code>单源最短路径</code>
<ul>
<li>所有边权都是正数
<ul>
<li>朴素<code>Dijkstra</code>算法 ：<code>O(n^2)</code> 适用于稠密图</li>
<li>堆优化版的<code>Dijkstra</code>算法：<code>O(m * logn)</code> 适用于稀疏图</li>
</ul>
</li>
<li>存在负权边
<ul>
<li><code>Bellman-Ford</code> ： <code>O(nm)</code></li>
<li><code>SPFA</code> :  一般是<code>O(m)</code>，最坏是<code>O(nm)</code></li>
</ul>
</li>
</ul>
</li>
<li><code>多源汇最短路径</code> ：
<ul>
<li><code>Floyd</code>算法：<code>O(n^3)</code></li>
</ul>
</li>
</ul>
<p><img src="/img/AcWing/Basic/shortLoad.png" alt="shortLoad" /></p>
<h4 id="朴素dijkstra"><a class="markdownIt-Anchor" href="#朴素dijkstra"></a> 朴素<code>Dijkstra</code></h4>
<ul>
<li>使用<code>邻接矩阵</code>存储，有向图：无向图是一种特殊的有向图。</li>
<li><code>s[i]</code> ：当前已确定最短路径的点。</li>
<li><code>dist[i]</code> ：第<code>i</code>个节点距离起点(1号点)的距离。初始化<code>dist[1] = 0</code>、<code>disst[i] = +Max</code></li>
<li><code>g[N][N]</code> ：存储每条边，下标从1开始</li>
</ul>
<p><img src="/img/AcWing/Basic/Dijkstra.png" alt="Dijkstra" /></p>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定，false:未确定，true：已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist); <span class="comment">// 初始化dist数组，将每个元素初始化为正无穷大。</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ ) <span class="comment">// 循环前n-1个节点即可，最后一个节点不用判断。</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j])) <span class="comment">//在所有st[j] == false 中找到dist最下的点。</span></span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 第一个节点和n不连通</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆优化版的dijkstra"><a class="markdownIt-Anchor" href="#堆优化版的dijkstra"></a> 堆优化版的<code>Dijkstra</code></h4>
<ul>
<li>使用堆对朴素<code>Dijkstra</code>算法进行优化</li>
<li>堆：使用c++里面的优先队列。</li>
<li>数据结构：因为针对稀疏图，所以采用<code>邻接表</code>的方式存储。</li>
</ul>
<p><strong>代码模板</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap; <span class="comment">// 定义优先队列代替堆，这样定义是小根堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="数学知识"><a class="markdownIt-Anchor" href="#数学知识"></a> 数学知识</h2>
<h3 id="数论"><a class="markdownIt-Anchor" href="#数论"></a> 数论</h3>
<h4 id="质数"><a class="markdownIt-Anchor" href="#质数"></a> 质数</h4>
<p><strong>Def</strong> 在大于1的整数中，如果只包含1和整数这两个约数，就被称为质数，或者素数。</p>
<p><strong>质数的判定—试除法</strong></p>
<p>实现思想 ：i 从 2 枚举到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mi>n</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.23972em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8002800000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathdefault">n</span></span></span><span style="top:-2.76028em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.23972em;"><span></span></span></span></span></span></span></span></span> 会缩减循环，但是<code>sqrt(n)</code>执行较慢，所以不使用。<code>O(sqrt(n))</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分解质因数—试除法</strong></p>
<p>实现思想：从小到大枚举所有数，<code>O(sqrt(n))</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// i 一定是质数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>朴素筛法求素数—埃氏筛法</strong></p>
<p>实现思想：从2遍历到n，遍历到第i个数的时候，若该数没有被删除，则加入质数数组，然后删除该数的所有倍数。<code>O(n * loglogn)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>; <span class="comment">//如果第i个数已经被删掉，跳过</span></span><br><span class="line">        primes[cnt ++ ] = i; <span class="comment">// 如果第i个数还没有被删掉，则说明从2~i-1没有值是i的因子</span></span><br><span class="line">        <span class="comment">// 删除 质数i 的所有倍数，这里仅删除质数的倍数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线性筛法求素数</strong></p>
<p><img src="/img/AcWing/Basic/%E7%BA%BF%E6%80%A7%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0.png" alt="线性筛法求素数" /></p>
<p>相较于<code>埃氏筛法</code>快将近一倍。</p>
<p>实现思想：n只会被它的最小质因子筛掉。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i; <span class="comment">// 如果是质数，加入至质数数组</span></span><br><span class="line">        <span class="comment">// 从小到大枚举所有的质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// primes[j] 一定是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="约数"><a class="markdownIt-Anchor" href="#约数"></a> 约数</h4>
<p><strong>试除法求所有约数</strong></p>
<p>实现思想类似于试除法求质数。<code>O(sqrt(n))</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//使用vector数组存放所有约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>约数个数</strong></p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">如果 N = p1<span class="built_in">^</span>c1 * p2<span class="built_in">^</span>c2 * ... *pk<span class="built_in">^</span>ck</span><br><span class="line">约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)</span><br><span class="line">约数之和： (p1<span class="built_in">^</span>0 + p1<span class="built_in">^</span>1 + ... + p1<span class="built_in">^</span>c1) * ... * (pk<span class="built_in">^</span>0 + pk<span class="built_in">^</span>1 + ... + pk<span class="built_in">^</span>ck)</span><br></pre></td></tr></table></figure>
<h3 id="组合计数"><a class="markdownIt-Anchor" href="#组合计数"></a> 组合计数</h3>
<h3 id="高斯消元"><a class="markdownIt-Anchor" href="#高斯消元"></a> 高斯消元</h3>
<h3 id="简单博弈论"><a class="markdownIt-Anchor" href="#简单博弈论"></a> 简单博弈论</h3>
]]></content>
      <categories>
        <category>AcWing</category>
        <category>Course</category>
      </categories>
      <tags>
        <tag>AcWing</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>故障注入&amp;检测流程</title>
    <url>/2022/03/22/LLVM/01faultInjection/</url>
    <content><![CDATA[<h1 id="故障注入检测流程"><a class="markdownIt-Anchor" href="#故障注入检测流程"></a> 故障注入&amp;检测流程</h1>
<h2 id="cpu故障注入检测流程"><a class="markdownIt-Anchor" href="#cpu故障注入检测流程"></a> CPU故障注入&amp;检测流程</h2>
<h3 id="处理源程序"><a class="markdownIt-Anchor" href="#处理源程序"></a> 处理源程序</h3>
<ol>
<li><strong>将源代码转换成中间代码，划分了基本块</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang -S -g -emit-llvm dm_dist.c -o dm_dist.ll</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>**给中间代码添加全局变量：**调用<code>Pass</code> <code>AddGlobalSig.so</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../AddGlobalSig.so -AddGlobalSig -S dm_dist.ll -o dm_dist.ll</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>**对每个基本块进行脆弱性分析；**并将结果输出至<code>allindex.txt</code>文件中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../Index.so -Index -disable-output dm_dist.ll 2&gt; allindex.txt</span><br></pre></td></tr></table></figure>
<p><code>allindex.txt</code>文件里面的内容为（基本块号，每个基本块里的指令数量）</p>
<ol start="4">
<li>**执行排序程序，**将<code>allindex.txt</code>文件的内容按照基本块指令数量从小到大排序，并输出前n/3-1个基本块的块号至<code>index.txt</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pthon3 sort.py &gt; index.txt</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><strong>将脆弱性高的基本块进行再拆分.</strong> 这里的<code>$line</code>是 <code>index.txt</code> 里面存放的值</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> `<span class="built_in">cat</span> index.txt`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	/home/yy2/Desktop/llvm/build/bin/opt -load /home/yy2/Desktop/llvm/build/lib/SplitBlock.so -SplitBlock -S -index <span class="variable">$line</span> dm_dist.ll -o dm_dist.ll</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><strong>使用<code>CFCSS</code>对中间代码进行插桩</strong> 使用<code>Pass：CFCSS.so</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../CFCSS.so -CFCSS -S dm_dist.ll -o cfcss.ll</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><strong>编译.ll文件生成可执行程序</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang cfcss.ll -o dm_dist/dm_dist_cf</span><br></pre></td></tr></table></figure>
<h3 id="故障注入"><a class="markdownIt-Anchor" href="#故障注入"></a> 故障注入</h3>
<p><strong>调用<code>auto.sh</code>进行自动化注入</strong></p>
<p>$1 待注入程序    $2 程序的输入文件(不懂)    $3 运行次数   $4 p/r 故障注入方式  $5 守护进程检测时间间隔</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./auto.sh ../qt/TestProgram/dm_dist/dm_dist_cf input_small.dat <span class="string">&quot;2500&quot;</span> <span class="string">&quot;r&quot;</span> <span class="string">&quot;3&quot;</span></span><br></pre></td></tr></table></figure>
<p>在<code>auto.sh</code>里面调用<code>gdb</code>工具进行故障注入。<code>start.py</code></p>
<h3 id="结果分析"><a class="markdownIt-Anchor" href="#结果分析"></a> 结果分析</h3>
<p>调用python文件进行结果分析:使用了<code>statistics.py</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 ../qt/CPUControl/fault_inject/statistics.py inject.output inject.correct</span><br></pre></td></tr></table></figure>
<h2 id="寄存器故障注入检测流程"><a class="markdownIt-Anchor" href="#寄存器故障注入检测流程"></a> 寄存器故障注入&amp;检测流程</h2>
<h3 id="标签扩展"><a class="markdownIt-Anchor" href="#标签扩展"></a> 标签扩展</h3>
<ol>
<li><strong>使用clang将源程序转化为中间代码</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang dm.cpp --target=arm-v7-linux-gnueabi -emit-llvm -g -S -o dm.ll</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>加固程序,给中间代码添加编号</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../pass/build/libgenLLFIIndex/libgenLLFIIndex.so -genllfiindexpass -S dm.ll -o dm_id.ll</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><strong>加固，通过冗余进行程序加固</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../pass/build/libdmr/libdmr.so -eddi -select_set_file=../xzt_jcq/index.txt -S dm_id.ll -o dm_df.ll</span><br></pre></td></tr></table></figure>
<h3 id="交叉编译"><a class="markdownIt-Anchor" href="#交叉编译"></a> 交叉编译</h3>
<ol>
<li><strong>编译程序，生成链接文件</strong> 生成.o文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang dm_df.ll --target=arm-v7-linux-gnueabi -c -o dm_df.o</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>链接程序，生成可执行文件</strong></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-gcc dm_df.o exec.o -static -o dm_df</span><br></pre></td></tr></table></figure>
<h3 id="故障注入-2"><a class="markdownIt-Anchor" href="#故障注入-2"></a> 故障注入</h3>
<p>通过<code>gem5</code>对可执行程序进行故障注入</p>
<p>通过for循环执行n次命令，从而进行n次故障注入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../res/gemFI/build/ARM/gem5.opt ../res/gemFI/configs/example/se.py -c dm_df</span><br></pre></td></tr></table></figure>
<h3 id="结果分析-2"><a class="markdownIt-Anchor" href="#结果分析-2"></a> 结果分析</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ./.statistics.py</span><br></pre></td></tr></table></figure>
<h2 id="io故障注入检测流程"><a class="markdownIt-Anchor" href="#io故障注入检测流程"></a> IO故障注入&amp;检测流程</h2>
<h3 id="加固"><a class="markdownIt-Anchor" href="#加固"></a> 加固</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arm-linux-gnueabi-g++ ../qt/IO/benchmark/dm/ManagerTask.cpp ../Desktop/qt/IO/benchmark/dm/dm.cpp -static -g -o /../Desktop/qt/IO/benchmark/dm/IOFaultTolerance</span><br><span class="line">arm-linux-gnueabi-g++ ../Desktop/qt/IO/benchmark/dm/dm_dist.cpp ../Desktop/qt/IO/benchmark/dm/exec.cpp -static -g -o ../Desktop/qt/IO/benchmark/dm/dm_dist.out</span><br></pre></td></tr></table></figure>
<h3 id="故障注入-3"><a class="markdownIt-Anchor" href="#故障注入-3"></a> 故障注入</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../home/yy2/res/gemFI/build/ARM/gem5.opt /home/yy2/res/gemFI/configs/example/se.py -c </span><br><span class="line">../Desktop/qt/IO/benchmark/dm/dm.out</span><br><span class="line">../res/gemFI/build/ARM/gem5.opt /gemFI/configs/example/se.py -c ../Desktop/qt/IO/benchmark/dm/IOFaultTolerance</span><br></pre></td></tr></table></figure>
<h3 id="结果分析-3"><a class="markdownIt-Anchor" href="#结果分析-3"></a> 结果分析</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python statistic.py <span class="comment">#调用的是/home/yy2/Desktop/qt/IO/benchmark/dm/fiwork/fi/golden/out.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="llvm-ir"><a class="markdownIt-Anchor" href="#llvm-ir"></a> LLVM IR</h2>
<p>生成.ll文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">../Desktop/llvm/build/bin/clang -S -g -emit-llvm dm_dist.c -o dm_dist.ll</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>故障注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础入门 Java8</title>
    <url>/2022/05/01/JAVA/03JavaBasic/</url>
    <content><![CDATA[<div class="note info simple"><p>Java 8是Java语言开发的一个主要版本</p>
</div>
<h1 id="java-8新特性"><a class="markdownIt-Anchor" href="#java-8新特性"></a> Java 8新特性</h1>
<ul>
<li>速度更快</li>
<li>代码更少，增加了新的语法，<strong>Lambda表达式</strong></li>
<li>强大的<code>Stream API</code></li>
<li>便于并行</li>
<li>最大化减少空指针异常：<code>Optional</code>类</li>
<li><code>Nashorn</code>引擎，允许在JVM上运行JS应用</li>
</ul>
<h1 id="lambda表达式"><a class="markdownIt-Anchor" href="#lambda表达式"></a> Lambda表达式</h1>
<blockquote>
<p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
</blockquote>
<h2 id="本质"><a class="markdownIt-Anchor" href="#本质"></a> 本质</h2>
<p>作为接口的实例</p>
<h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2>
<ul>
<li><code>-&gt;</code>lambda操作符，或箭头操作符</li>
<li><code>-&gt;</code>左边：lambda形参列表，其实就是接口中的抽象方法的形参列表</li>
<li><code>-&gt;</code>右边：lambda体，其实就是重写的抽象方法的方法体</li>
</ul>
<h2 id="语法格式"><a class="markdownIt-Anchor" href="#语法格式"></a> 语法格式</h2>
<ul>
<li>语法格式一：无参，无返回值</li>
</ul>
<p><code>Runnable r2 = () -&gt; &#123; System.out.println(&quot;Hello world&quot;); &#125;</code></p>
<ul>
<li>语法格式二：lambda需要一个参数，但是没有返回值</li>
</ul>
<p><code>Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;</code></p>
<ul>
<li>语法格式三：数据类型可以省略，因为可由编译器推断得出，称为<strong>类型推断</strong></li>
</ul>
<p><code>Consumer&lt;String&gt; con1 = (s) -&gt; &#123; System.out.println(s); &#125;</code></p>
<ul>
<li>语法格式四：lambda若只需要一个参数时，参数的小括号可以省略</li>
</ul>
<p><code>Consumer&lt;String&gt; con1 = s -&gt; &#123; System.out.println(s); &#125;</code></p>
<ul>
<li>语法格式五：lambda需要两个或以上的参数，多条执行语句，并且可以有返回值</li>
</ul>
<p><code>Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123; return Integer.compare(o1, o2); &#125;;</code></p>
<ul>
<li>语法格六：当lambda体只有一条语句时， return 与大括号若有，都可以省略</li>
</ul>
<p><code>Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);</code></p>
<p><code>Consumer&lt;String&gt; con1 = s -&gt; System.out.println(s);</code></p>
<p><strong>总结</strong></p>
<ul>
<li><code>-&gt;</code> 左边：lambda形参列表的参数类型可以省略（类型推断）；如果lambda形参列表只有一个参数，其一对<code>()</code>也可以省略</li>
<li><code>-&gt;</code> 右边：lambda体应该使用一对<code>&#123;&#125;</code>包裹；如果lambda体只有一条执行语句（可能是 <code>return</code> 语句），则可以省略 <code>&#123;&#125;</code> 和 <code>return</code> 关键字</li>
</ul>
<h2 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h2>
<p>以前使用匿名实现类表示的现在都可以用 Lambda 表达式来写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.lambda_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * Lambda表达式的使用举例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lambda_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  <span class="comment">// 接口中只有一个方法，则可以写为lambda表达式</span></span><br><span class="line">                System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        r1.run();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式进行优化</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 语法格式三</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> com1.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda进行优化</span></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; Integer.compare(o1, o2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com2.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare1);</span><br><span class="line">        <span class="comment">// 方法引用</span></span><br><span class="line">        Comparator&lt;Integer&gt; com3 = Integer::compare;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">compare2</span> <span class="operator">=</span> com2.compare(<span class="number">12</span>, <span class="number">21</span>);</span><br><span class="line">        System.out.println(compare2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 语法格式二</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;abcdefd&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用lambda表达式进行优化</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = (String s) -&gt; System.out.println(s);</span><br><span class="line">        con1.accept(<span class="string">&quot;abcdefd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="函数式function接口"><a class="markdownIt-Anchor" href="#函数式function接口"></a> 函数式(Function)接口</h1>
<blockquote>
<p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口</p>
</blockquote>
<p>可以使用<code>@FunctionalInterface</code>注解，不加也是函数式接口，加上可以帮助校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.functioninterface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.functioninterface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FunctionalInterface_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">myInterface</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hell world&quot;</span>);</span><br><span class="line">        myInterface.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<ul>
<li>只包含一个抽象方法的接口，称为<strong>函数式接口</strong></li>
<li>你可以通过Lambda表达式来创建该接口的对象。（若Lambda表达式抛出一个受检异常（即：非运行时异常），那么该异常需要在目标接口的抽象方法上进行声明）</li>
<li>我们可以在一个接口上使用<code>@FunctionalInterface</code>注解，这样做可以检查它是否在一个函数是接口。同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口</li>
<li>在<code>java.util.function</code>包下定义了 Java 8 的丰富的函数式接口</li>
</ul>
<h2 id="内置核心函数式接口"><a class="markdownIt-Anchor" href="#内置核心函数式接口"></a> 内置核心函数式接口、</h2>
<p><strong>四大核心内置核心函数式接口</strong></p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Consumer&lt;T&gt;</code> 消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型为T的对象应用操作，包含方法：<code>void accept(T t)</code></td>
</tr>
<tr>
<td><code>supplier&lt;T&gt;</code> 供给型接口</td>
<td>T</td>
<td>T</td>
<td>返回类型为T的对象，包含方法：<code>T get()</code></td>
</tr>
<tr>
<td><code>Function&lt;T, R&gt;</code> 函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型为T的对象应用此操作，并返回结果。结果是R类型的对象。包含方法<code>R apply(T t)</code></td>
</tr>
<tr>
<td><code>Predicate&lt;T&gt;</code> 断定型接口</td>
<td>T</td>
<td>Boolean</td>
<td>确定类型为T的对象是否满足某约束，并返回Boolean值，包含方法：<code>boolean test(T t)</code></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.functioninterface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainFunctionalInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Consumer&lt;Integer&gt; consumer = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;数 = &quot;</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Consumer&lt;Integer&gt; consumer1 = (integer) -&gt; System.out.println(<span class="string">&quot;数 = &quot;</span> + integer);  <span class="comment">// 转为Lambda表达式</span></span><br><span class="line"></span><br><span class="line">        Supplier&lt;Integer&gt; supplier = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Supplier&lt;Integer&gt; supplier1 = () -&gt; <span class="number">20</span>;  <span class="comment">// &#123;&#125; 和 return 都省略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;南京&quot;</span>, <span class="string">&quot;普京&quot;</span>, <span class="string">&quot;天津&quot;</span>, <span class="string">&quot;东京&quot;</span>);</span><br><span class="line">        List&lt;String&gt; filterStrs = filterString(list, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> s.contains(<span class="string">&quot;京&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(filterStrs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转换为 Lambda 表达式</span></span><br><span class="line">        List&lt;String&gt; filterStrs1 = filterString(list, s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(filterStrs1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span> &#123;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre.test(s)) &#123;</span><br><span class="line">                strings.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strings;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="方法引用和构造器引用"><a class="markdownIt-Anchor" href="#方法引用和构造器引用"></a> 方法引用和构造器引用</h1>
<h2 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h2>
<blockquote>
<p>当要传递给Lambda 体的操作，已经有实现的方法了，可以使用方法引用</p>
</blockquote>
<ul>
<li>方法引用可以看作是Lambda表达式深层次的表达，换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法堂。</li>
<li><strong>要求</strong>：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致。</li>
<li><strong>格式</strong>：使用操作符 <code>::</code> 将类或对象与方法名分割开来</li>
</ul>
<h3 id="使用情况"><a class="markdownIt-Anchor" href="#使用情况"></a> 使用情况</h3>
<ul>
<li><code>对象::实例化方法名</code></li>
<li><code>类::静态方法名</code></li>
<li><code>类::实例化方法名</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.methodreference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; consumer = str -&gt; System.out.println(str);</span><br><span class="line">        consumer.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 方法引用 类::静态方法名</span></span><br><span class="line">        Consumer&lt;String&gt; consumer1 = System.out::println;</span><br><span class="line"></span><br><span class="line">        consumer1.accept(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; name;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用方法引用 对象名::实例化方法名</span></span><br><span class="line">        Supplier&lt;String&gt; supplier1 = name::toString;</span><br><span class="line">        System.out.println(supplier1.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构造器引用"><a class="markdownIt-Anchor" href="#构造器引用"></a> 构造器引用</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.methodreference;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodReference01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lambda 表达式</span></span><br><span class="line">        Supplier&lt;Employee&gt; sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造器引用</span></span><br><span class="line">        Supplier&lt;Employee&gt; sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="强大的stream-api"><a class="markdownIt-Anchor" href="#强大的stream-api"></a> 强大的Stream API</h1>
<blockquote>
<p>把真正的函数式编程风格引入到Java中，这是目前为止对Java类库最好的补充，因为 Stream API可以极大的提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
</blockquote>
<ul>
<li>Stream API 对集合数据进行操作，就类似于使用SQL执行的数据库查询，也可以使用Stream API来并行执行操作。</li>
<li>Stream API 提供了一种高效且易于使用的处理数据的方式。</li>
</ul>
<h2 id="stream-和-collection集合的区别"><a class="markdownIt-Anchor" href="#stream-和-collection集合的区别"></a> Stream 和 Collection集合的区别</h2>
<ul>
<li>Collection 是一种面向静态的内存数据结构，而 Stream 是有关计算的。前者主要是面向内存的，存储在内存中，后者主要是面向CPU，通过CPU实现计算。</li>
</ul>
<h2 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意</h2>
<ul>
<li>Stream 自己不会存储元素</li>
<li>Stream 不会改变源对象，相反，他们会返回一个持有结果的新Stream</li>
<li>Stream 操作是延迟执行的，这意味者他们会等到需要结果的时候才执行</li>
</ul>
<h2 id="操作步骤"><a class="markdownIt-Anchor" href="#操作步骤"></a> 操作步骤</h2>
<ol>
<li><strong>创建 Stream</strong></li>
</ol>
<p>一个数据源（如：集合、数组），获取一个流</p>
<ol start="2">
<li>中间操作</li>
</ol>
<p>一个中间操作链，对数据员的数据进行处理</p>
<ol start="3">
<li><strong>终止操作</strong>（终端操作）</li>
</ol>
<p>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再使用</p>
<h2 id="创建对象的方式"><a class="markdownIt-Anchor" href="#创建对象的方式"></a> 创建对象的方式</h2>
<h3 id="通过集合"><a class="markdownIt-Anchor" href="#通过集合"></a> 通过集合</h3>
<p>Java 8中的 <code>Collection</code> 接口被扩展，提供两个获取流的方法：</p>
<ul>
<li><code>default Stream&lt;E&gt; stream()</code> 返回一个顺序流</li>
<li><code>default Stream&lt;E&gt; parallelStream()</code> 返回一个并行流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个顺序流</span></span><br><span class="line">    Stream&lt;String&gt; stream = strings.stream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个并行流</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = strings.parallelStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过数组"><a class="markdownIt-Anchor" href="#通过数组"></a> 通过数组</h3>
<p>Java 8中的 <code>Arrays</code>的静态方法 <code>stream()</code> 可以获取数组流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    Arrays.stream(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过-stream-的-of"><a class="markdownIt-Anchor" href="#通过-stream-的-of"></a> 通过 Stream 的 of</h3>
<p>可以调用Stream 类的静态方法 <code>of()</code> ，通过显示值创建一个流。它可以接受任意数量的参数。</p>
<ul>
<li><code>public static&lt;T&gt; Stream&lt;T&gt; of(T...values)</code> 返回一个流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="创建无限流"><a class="markdownIt-Anchor" href="#创建无限流"></a> 创建无限流</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历前 10 个偶数</span></span><br><span class="line">    Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 随机生成10 个随机数</span></span><br><span class="line">    Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stream-的中间操作"><a class="markdownIt-Anchor" href="#stream-的中间操作"></a> Stream 的中间操作</h2>
<p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为”惰性求值“</p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>LLVM Pass编写及运行</title>
    <url>/2022/03/22/LLVM/02PassWriteProcess/</url>
    <content><![CDATA[<h1 id="pass编写运行"><a class="markdownIt-Anchor" href="#pass编写运行"></a> Pass编写运行</h1>
<h2 id="编写pass"><a class="markdownIt-Anchor" href="#编写pass"></a> 编写Pass</h2>
<ol>
<li>在<code>llvm/lib/Transforms/</code>目录下新建文件夹，命名为<code>MyPass</code></li>
</ol>
<p><img src="/img/LLVM/Pass1.png" alt="Pass1" /></p>
<ol start="2">
<li>在<code>MyPass</code> 文件夹下创建两个文件，分别为<code>MyPass.cpp</code>、<code>CMakeLists.txt</code></li>
</ol>
<p><img src="/img/LLVM/Pass2.png" alt="image-20220102144652248" /></p>
<ol start="3">
<li>对<code>MyPass.cpp</code>以及<code>CMakeLists.txt</code>文件进行编写。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#MyPass.cpp</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Analysis/LoopInfo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_TYPE <span class="string">&quot;hello&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">MyPass</span> : <span class="keyword">public</span> FunctionPass&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">        <span class="built_in">MyPass</span>() : <span class="built_in">FunctionPass</span>(ID)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            LoopInfo *LI = &amp;<span class="built_in">getAnalysis</span>&lt;LoopInfoWrapperPass&gt;().<span class="built_in">getLoopInfo</span>();</span><br><span class="line">            <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;Function &quot;</span>&lt;&lt;F.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span>(Loop *L : *LI)</span><br><span class="line">                <span class="built_in">countBlocksInLoop</span>(L,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">countBlocksInLoop</span><span class="params">(Loop *L,<span class="type">unsigned</span> nest)</span></span>&#123;</span><br><span class="line">            <span class="type">unsigned</span> num_Blocks=<span class="number">0</span>;</span><br><span class="line">            Loop::block_iterator bb;</span><br><span class="line">            <span class="keyword">for</span>(bb = L-&gt;<span class="built_in">block_begin</span>();bb!=L-&gt;<span class="built_in">block_end</span>();++bb)</span><br><span class="line">                num_Blocks++;</span><br><span class="line">            <span class="built_in">errs</span>()&lt;&lt;<span class="string">&quot;Loop level &quot;</span>&lt;&lt; nest &lt;&lt;<span class="string">&quot;has&quot;</span>&lt;&lt;num_Blocks&lt;&lt;<span class="string">&quot; blocks\n&quot;</span>;</span><br><span class="line">            std::vector&lt;Loop*&gt; subLoops = L-&gt;<span class="built_in">getSubLoops</span>();</span><br><span class="line">            Loop::iterator j,f;</span><br><span class="line">            <span class="keyword">for</span>(j = subLoops.<span class="built_in">begin</span>(),f=subLoops.<span class="built_in">end</span>();j!=f;++j)</span><br><span class="line">                <span class="built_in">countBlocksInLoop</span>(*j, nest+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp;AU)</span> <span class="type">const</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">            AU.<span class="built_in">addRequired</span>&lt;LoopInfoWrapperPass&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> MyPass::ID=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;MyPass&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;MyPass&quot;</span>,<span class="string">&quot;Function Block Count&quot;</span>,<span class="literal">false</span>,<span class="literal">false</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="params">#</span>CMakeLists.txt</span><br><span class="line">cmake<span class="built_in">_</span>minimum<span class="built_in">_</span>required(VERSION 3.5)</span><br><span class="line"></span><br><span class="line">add<span class="built_in">_</span>llvm<span class="built_in">_</span>loadable<span class="built_in">_</span>module(MyPass</span><br><span class="line">	MyPass.cpp</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>对Transforms/文件夹下面的CMakeLists.txt文件进行修改。</li>
</ol>
<p><img src="/img/LLVM/Pass3.png" alt="image-20220102145118378" /></p>
<h2 id="编译生成so文件"><a class="markdownIt-Anchor" href="#编译生成so文件"></a> 编译生成.so文件</h2>
<p>在<code>llvm/build/</code>目录下面执行<code>make</code>指令，则会编译生成动态链接库<code>.so</code>文件，生成的文件在<code>llvm/build/lib/</code>目录下面。</p>
<h2 id="编写测试程序"><a class="markdownIt-Anchor" href="#编写测试程序"></a> 编写测试程序</h2>
<p>编写<code>.c</code>或<code>.cpp</code>文件，然后用<code>clang</code>工具对源程序进行编译，生成<code>LLVM IR</code>中间代码。</p>
<h2 id="运行pass"><a class="markdownIt-Anchor" href="#运行pass"></a> 运行Pass</h2>
<p>通过调用测试程序运行<code>Pass</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">opt -load ../Desktop/llvm/build/lib/MyPass.so -MyPass -disable-output testPra.ll</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LLVM</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>Pass</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 基础入门 阶段3</title>
    <url>/2022/04/18/JAVA/02JavaBasic/</url>
    <content><![CDATA[<h1 id="类变量和类方法"><a class="markdownIt-Anchor" href="#类变量和类方法"></a> 类变量和类方法</h1>
<h2 id="类变量"><a class="markdownIt-Anchor" href="#类变量"></a> 类变量</h2>
<p>也叫静态变量/静态属性，用<code>static</code> 修饰，可以被本类的所有对象实例共享。任何对象去访问它时访问的都是同一个变量</p>
<ul>
<li>语法：<code>访问修饰符 static 变量类型 变量名</code></li>
<li>访问方法：<code>类名.类变量名</code>、<code>对象名.类变量名</code>，推荐使用：<code>类名.类变量名</code></li>
<li>类变量是随着类的加载而创建，所以即使没有创建对象实例也可以访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt._static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VisitStatic</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> A.name; <span class="comment">// 通过类名访问</span></span><br><span class="line">        System.out.println(name);  <span class="comment">//xzt</span></span><br><span class="line"></span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(a.name); <span class="comment">//xzt</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;xzt&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>当需要让某个类变量都共享一个变量时，可以使用类变量(静态变量)</li>
<li>类变量时所有对象共享的，而实例变量时每个对象独享的</li>
<li>加上<code>static</code>成为类变量或静态变量，否则成为实例变量/普通变量</li>
</ul>
<h2 id="类方法"><a class="markdownIt-Anchor" href="#类方法"></a> 类方法</h2>
<p>也叫静态方法，用<code>static</code>修饰</p>
<ul>
<li>语法：<code>访问修饰符 static 返回类型 方法名(参数列表) &#123;&#125;</code></li>
<li>访问方法：<code>类名.类方法名</code>、<code>对象名.类方法名</code>，推荐使用：<code>类名.类方法名</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt._static;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Stu</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        tom.payFee(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Stu</span> <span class="variable">jack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Stu</span>(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        jack.payFee(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">        Stu.showFee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">double</span> <span class="variable">fee</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 学费</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stu</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法可以使用静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">payFee</span><span class="params">(<span class="type">double</span> fee)</span>&#123;</span><br><span class="line">        Stu.fee += fee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showFee</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;总学费有&quot;</span> + Stu.fee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**使用场景：**当方法中不涉及任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率，例如工具类：<code>Math 类</code></p>
<p><strong>注意事项</strong></p>
<ul>
<li>类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区
<ul>
<li>类方法中不能使用<code>this</code>关键字</li>
</ul>
</li>
<li>类方法可以通过类名调用，普通方法不能通过类名调用。</li>
</ul>
<h3 id="main-方法"><a class="markdownIt-Anchor" href="#main-方法"></a> <code>main</code> 方法</h3>
<p>语法：<code>public static void main(String[] args) &#123;&#125;</code></p>
<ul>
<li><code>main</code>是java虚拟机调用，所以类方法需要是<code>public</code></li>
<li>java虚拟机在执行<code>main</code>方法时不需要创建对象，所以需要是<code>static</code></li>
<li>该方法接收<code>String</code>类型的数组参数，该数组中保存执行java命令时传递给所运行的类的参数</li>
<li><code>java 执行的程序 参数1 参数2 参数3</code>，参数组成<code>String[] args</code></li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>在<code>main</code> 方法中可以直接调用<code>main</code>方法所在类的静态方法或静态属性。</li>
<li>但是不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的静态成员</li>
</ul>
<h1 id="代码块"><a class="markdownIt-Anchor" href="#代码块"></a> 代码块</h1>
<p>代码块又称初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过<code>&#123;&#125;</code>包围起来。但和方法不同，没有方法名，没有参数，只有方法体，而且不用通过对象或类显式调用，二十加载类时，或创建对象时隐士调用。</p>
<ul>
<li>基本语法：<code>[修饰符] &#123; 代码 &#125;;</code></li>
<li>修饰符可选，要写的话，也只能写<code>static</code></li>
<li>代码块分为两类，使用<code>static</code>修饰的叫静态代码块，没有<code>static</code>修饰的叫普通代码块</li>
<li>逻辑语句可以为任何逻辑语句，（输入、输出、方法调用、循环、判断等）</li>
<li><code>;</code>可以写上，也可以省略</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>相当于另一种形式的构造器，可以做初始化的操作</li>
<li>场景：如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的重用性</li>
<li><strong>代码块的调用优先于构造器的调用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.codeblock_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeBlock01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">private</span> String director;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;屏幕开启&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;广告开始&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;电影开始&quot;</span>);</span><br><span class="line">    &#125;;  <span class="comment">// 代码块，当任何一个构造器被调用时都会优先调用构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price, String director)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.director = director;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Movie</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>用<code>static</code>修饰的代码块也叫静态代码块，作用就是对类进行初始化，而且它<strong>随着类的加载而执行</strong>，并且<strong>只会执行一次</strong>，如果是普通代码块，每创建一个对象，就执行。</li>
<li><strong>类什么时候被加载</strong> ⭐
<ul>
<li>创建对象实例时<code>(new)</code></li>
<li>创建子类对象实例时，父类也会被加载</li>
<li>使用类的静态成员时（静态属性、静态方法）</li>
</ul>
</li>
<li>普通代码块，会在创建对象实例时被隐士调用，创建一次则执行一次，如果使用类的静态成员时，普通代码块并不会执行。</li>
<li>**创建一个对象时，在一个类调用顺序是：**⭐⭐
<ol>
<li><strong>调用静态代码块和静态属性初始化</strong>（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的先后顺序调用）</li>
<li><strong>调用普通代码块和普通属性的初始化</strong>（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通变量初始化，则按他们定义的先后顺序调用）</li>
<li><strong>调用构造方法</strong></li>
</ol>
</li>
<li>构造器最前面其实隐含了<code>super()</code>和 调用普通代码块，</li>
<li>**创建一个子类时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：**⭐⭐
<ol>
<li>父类的静态代码块和静态属性初始化（优先级一样，按定义顺序执行）</li>
<li>子类的静态代码块和静态属性初始化（优先级一样，按定义顺序执行）</li>
<li>父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>
<li>父类的构造方法</li>
<li>子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）</li>
<li>子类的构造方法</li>
</ol>
</li>
<li>静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员</li>
</ul>
<h1 id="单例设计模式"><a class="markdownIt-Anchor" href="#单例设计模式"></a> 单例设计模式</h1>
<p><strong>设计模式</strong>：设计模式是在大量的实践中总结和理论化之后的优选的代码结构、编程风格、以及解决问题的思考方式。</p>
<h2 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h2>
<p>就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得对象实例的方法。</p>
<h3 id="饿汉式"><a class="markdownIt-Anchor" href="#饿汉式"></a> 饿汉式</h3>
<p>没有使用对象，但是加载类的时候就会创建对象。可能造成创建了对象，但没有使用，造成资源的浪费。</p>
<ol>
<li>构造器私有化</li>
<li>类内部创建对象（该对象时<code>static</code>）</li>
<li>向外暴露一个静态的公共方法，<code>getInstance()</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.single_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTone01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> GirlFriend.getInstance();  <span class="comment">// 创建对象</span></span><br><span class="line">        System.out.println(gf);</span><br><span class="line">        </span><br><span class="line">        <span class="type">GirlFriend</span> <span class="variable">gf2</span> <span class="operator">=</span> GirlFriend.getInstance();  <span class="comment">// 创建对象 和 上面的gf其实是同一个对象</span></span><br><span class="line">        System.out.println(gf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GirlFriend</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">GirlFriend</span> <span class="variable">gf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GirlFriend</span>(<span class="string">&quot;qqy&quot;</span>);  <span class="comment">// 2.对象在类内部创建</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">GirlFriend</span><span class="params">(String name)</span> &#123;   <span class="comment">//1.构造方法私有化</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GirlFriend <span class="title function_">getInstance</span><span class="params">()</span>&#123;  <span class="comment">//3.向外暴露一个公共的静态方法</span></span><br><span class="line">        <span class="keyword">return</span> gf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GirlFriend&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="懒汉式"><a class="markdownIt-Anchor" href="#懒汉式"></a> 懒汉式</h3>
<p>在使用时创建对象，只有在用户使用<code>getInstance()</code>方法时才返回对象，后面再次调用时会返回上次创建的对象，从而保证了单例。</p>
<ol>
<li>构造器私有化</li>
<li>定义一个<code>static</code>静态属性对象</li>
<li>定义一个<code>public</code>的<code>static</code>方法可以返回Cat对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//懒汉式的单例模式</span></span><br><span class="line"><span class="keyword">package</span> com.xzt.single_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示懒汉式的单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleTon02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> Cat.getInstance();</span><br><span class="line">        System.out.println(cat.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望在程序运行过程中只能创建一个Cat对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cat cat; <span class="comment">// 2.定义一个static静态属性对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123; <span class="comment">// 1.构造器私有化</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title function_">getInstance</span><span class="params">()</span>&#123;  <span class="comment">//3.定义一个public的static方法可以返回Cat对象</span></span><br><span class="line">        <span class="keyword">if</span>(cat == <span class="literal">null</span>)&#123; <span class="comment">// 如果还没有创建Cat对象</span></span><br><span class="line">            cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;xzt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Cat&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="饿汉式和懒汉式的区别"><a class="markdownIt-Anchor" href="#饿汉式和懒汉式的区别"></a> 饿汉式和懒汉式的区别</h3>
<ul>
<li>最主要的区别是创建对象的<strong>时机不同</strong>，饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建</li>
<li>饿汉式不存在线程安全问题，<strong>懒汉式存在线程安全问题</strong></li>
<li><strong>饿汉式存在浪费资源的问题</strong>，懒汉式则不存在这个问题。和对象的创建时机有很大的关系</li>
<li>在<code>javaSE</code>标准类中，<code>java.lang.Runtime</code>就是经典的单例模式</li>
</ul>
<h1 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> <code>final</code>关键字</h1>
<p><code>final</code>可以修饰类、属性、方法和局部变量</p>
<h2 id="使用场景"><a class="markdownIt-Anchor" href="#使用场景"></a> 使用场景</h2>
<ul>
<li>当不希望类被继承时，可以使用<code>final</code>修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.final_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Final01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;  <span class="comment">// 报错，不能被继承</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当不希望父类的某个方法被子类重写/覆盖(<code>override</code>)时，可以使用<code>final</code>关键字修饰</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> <span class="keyword">extends</span> <span class="title class_">C</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>&#123;  <span class="comment">// 报错 不能被重写</span></span><br><span class="line">        System.out.println(<span class="string">&quot;重写了hi方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当不希望类的某个属性的值被修改，可以使用<code>final</code>修饰</li>
<li>当不希望某个局部变量被修改。可以使用<code>final</code>修饰</li>
</ul>
<h2 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项</h2>
<ul>
<li><code>final</code>修饰的属性又叫常量，一般用<code>XX_XX_XX</code>来命名</li>
<li><code>final</code>修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以再如下位置之一：
<ul>
<li>定义时，例如：<code>public final double PI = 3.1415926;</code></li>
<li>在构造器中</li>
<li>在代码块中</li>
</ul>
</li>
<li>如果<code>final</code>修饰的属性是静态的，则初始化的位置只能是：
<ul>
<li>定义时</li>
<li>在静态代码块中，不能在构造器中赋值</li>
</ul>
</li>
<li><code>final</code>类不能被继承，但可以实例化对象。</li>
<li>如果类不是<code>final</code>类，但是含有<code>final</code>方法，则该方法虽然不能被重写，但是可以被继承。</li>
<li>一般来说，如果一个类是<code>final</code>类了，就没必要再将方法修饰成<code>final</code>方法</li>
<li><code>final</code>不能修饰构造器（构造方法）</li>
<li><code>final</code>和<code>static</code>往往搭配使用，效率更高，底层编译器做了优化处理。调用类中的该属性时，不会加载类。</li>
<li>包装类（<code>Integer</code>，<code>Double</code>，<code>Float</code>，<code>Boolean</code>等都是<code>final</code>类），<code>String</code>也是<code>final</code>类</li>
</ul>
<h1 id="抽象类"><a class="markdownIt-Anchor" href="#抽象类"></a> 抽象类</h1>
<p>**定义：**当父类的某些方法需要声明，但是又不能确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类</p>
<ul>
<li>用<code>abstract</code>修饰的方法</li>
<li>所谓抽象方法就是没有实现的方法，没有实现就是指没有函数体</li>
<li>当一个类中存在抽象方法时，需要将该类声明为<code>abstract</code>类</li>
<li>一般来说抽象类会被继承，由其子类实现抽象方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Abstract01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里实现了，但没什么意义，即父类方法不确定性问题</span></span><br><span class="line"><span class="comment">//    public void eat()&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;这是一个动物，不知道吃什么&quot;);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 所谓抽象类就是没有函数体的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;  <span class="comment">// 当一个类中存在抽象方法时,需要将该类声明为抽象类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>抽象类不能被实例化</li>
<li>抽象类不一定要包含<code>abstract</code>方法，</li>
<li>一旦类中包含了<code>abstract</code>方法，则这个类必须声明为<code>abstract</code></li>
<li><code>abstract</code>只能修饰类和方法，不能修饰属性和其它的。</li>
<li>抽象类可以有任意成员【抽象类的本质还是类】</li>
<li>抽象方法不能有主体，即不能实现。</li>
<li>如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为<code>abstract</code>类</li>
<li>⭐<code>final</code>不能被继承，<code>static</code>不能被重写，所以<code>abstract</code>不能和<code>final</code>或者<code>static</code>组合使用</li>
<li>⭐<code>private</code>不能被重写，所以<code>abstract</code>也不能时<code>private</code>的</li>
</ul>
<h2 id="抽象类的最佳实践-模板设计模式"><a class="markdownIt-Anchor" href="#抽象类的最佳实践-模板设计模式"></a> 抽象类的最佳实践-模板设计模式</h2>
<p>编写模板类，例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Template</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calculateTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        job();  <span class="comment">// 实际调用了子类中重写的job()方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">800000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">job</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            num += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.abstract_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.calculateTime();</span><br><span class="line"></span><br><span class="line">        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        b.calculateTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h1>
<p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来。</p>
<ul>
<li><strong>基本语法：</strong><code>interface 接口名&#123; //属性 // 方法&#125;</code></li>
<li><strong>实现方法：</strong><code>class 类名 implements 接口名 &#123; // 自己的属性 // 自己的方法 //必须实现的接口的抽象方法&#125;</code></li>
</ul>
<p><strong>总结：</strong></p>
<ul>
<li>在<code>Jdk7.0</code>前，接口里的所有方法都没有方法体，即都是抽象方法</li>
<li><code>Jdk8.0</code>后接口可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在接口中抽象方法可以省略abstract</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Interface01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">AInterface</span>&#123;  <span class="comment">// 实现接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现接口后，需要将该接口中所有的抽象方法全部实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>接口不能被实例化</li>
<li>接口中所有方法时<code>public</code>方法，接口中抽象方法，可以不用<code>abstract</code>修饰</li>
<li>一个普通类实现接口，就必须将该接口的所有方法都是实现</li>
<li>抽象了实现接口，可以不用实现接口的方法</li>
<li><strong>一个类可以同时实现多个接口</strong></li>
<li>接口中的属性只能时<code>final</code>，而且时<code>public static final</code>修饰符；例如：<code>int a = 1</code>实际上是<code>public static final int a = 1</code></li>
<li>接口中的属性的访问形式：<code>接口名.属性名</code></li>
<li>接口中不能继承其他的类，但是<strong>可以继承多个别的接口</strong>。<code>interface A extends B, C &#123;&#125;</code></li>
<li>接口的修饰符只能是<code>public</code>和默认，这点和类的修饰符是一样的</li>
</ul>
<h2 id="实现接口-vs-继承类"><a class="markdownIt-Anchor" href="#实现接口-vs-继承类"></a> 实现接口 VS 继承类</h2>
<ul>
<li><strong>实现接口是对单继承机制的补充</strong></li>
<li>继承：先天拥有，当子类继承了父类，则自动拥有了父类的能力，</li>
<li>实现：后天学习，如果子类需要扩展某些功能，则需要实现接口的方式进行获取。</li>
<li>接口和问题解决的问题不同：
<ul>
<li>继承的价值在于<strong>解决代码的复用性和可维护性</strong></li>
<li>接口的价值在于：设计，设计好各种规范（方法），让其他类去实现这些方法</li>
</ul>
</li>
<li>接口比继承更加灵活</li>
<li>接口在一定程度上可以实现代码解耦【即：接口规范 + 动态绑定机制】</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsVSInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LittleMonkey</span> <span class="variable">wukong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LittleMonkey</span>(<span class="string">&quot;悟空&quot;</span>);</span><br><span class="line">        wukong.climbing();</span><br><span class="line"></span><br><span class="line">        wukong.swimming();</span><br><span class="line">        </span><br><span class="line">        wukong.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monkey</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Monkey</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">climbing</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;猴子会爬树&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Fish</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LittleMonkey</span> <span class="keyword">extends</span> <span class="title class_">Monkey</span> <span class="keyword">implements</span> <span class="title class_">Fish</span>, Bird &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LittleMonkey</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swimming</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; 通过学习会游泳了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot; 通过学习会飞翔了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口的多态"><a class="markdownIt-Anchor" href="#接口的多态"></a> 接口的多态</h2>
<ul>
<li><strong>多态参数</strong>，可以接受实现了该接口的所有类的实例对象，接口类型的变量可以指向实现了该接口的对象。和继承体现的多态类似。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyParameter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">IF</span> <span class="variable">if01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">IF</span> <span class="variable">if02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>(); <span class="comment">// 体现了接口的多态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IF</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> <span class="keyword">implements</span> <span class="title class_">IF</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> <span class="keyword">implements</span> <span class="title class_">IF</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>多态数组</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyArr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Usb[] usbs = <span class="keyword">new</span> <span class="title class_">Usb</span>[<span class="number">2</span>]; <span class="comment">// 接口类型的数组</span></span><br><span class="line"></span><br><span class="line">        usbs[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Camera</span>();  <span class="comment">// 接口数组实现多态</span></span><br><span class="line">        usbs[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; usbs.length; i++) &#123;</span><br><span class="line">            usbs[i].work();  <span class="comment">// 动态绑定</span></span><br><span class="line">            <span class="keyword">if</span>(usbs[i] <span class="keyword">instanceof</span> Phone)&#123;  <span class="comment">// 判断其运行类型是否为 Phone</span></span><br><span class="line">                ((Phone) usbs[i]).call();  <span class="comment">// 进行类型向下转型并调用方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;手机工作中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Camera</span> <span class="keyword">implements</span> <span class="title class_">Usb</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;相机工作中&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>多态传递</strong>：如果接口A继承了接口B，而类C仅仅实现了接口A，则相当于类C也实现了接口B。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.interface_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示多态传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterfacePolyPass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 接口类型的变量可以指向实现了该接口的类的对象</span></span><br><span class="line">        <span class="type">IG</span> <span class="variable">ig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">IH</span> <span class="variable">ih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>();  <span class="comment">// 因为IG继承了IH，所以Teacher对象实例也实现了IH</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IH</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IG</span> <span class="keyword">extends</span> <span class="title class_">IH</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">implements</span> <span class="title class_">IG</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**当类C继承了类A，实现了接口B，并且类A和接口B中有同名的属性，直接调用时则会造成模糊，所以调用父类的可以使用 <code>super.属性名</code>,调用接口的可以使用<code>接口名.属性名</code>。</p>
<p>**类的五大成员：**属性、方法、构造器、代码块、内部类。</p>
<h1 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h1>
<p>一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类（<code>inner class</code>），嵌套其他类的类称为外部类（<code>outer class</code>）。是我们类的第五大成员。<strong>内部类最大的特点就是可以访问私有属性，并且可以体现类与类之间的包含关系。</strong></p>
<ul>
<li><strong>基本语法：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;  <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123; <span class="comment">// 内部类</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123; <span class="comment">// 外部其他类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InnerClass01</span> &#123;  <span class="comment">// 外部其他类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;  <span class="comment">// 外部其他类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span>;   <span class="comment">// 属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">(<span class="type">int</span> n1)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n1 = n1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;  <span class="comment">// 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;m1()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;  <span class="comment">// 代码块</span></span><br><span class="line">        System.out.println(<span class="string">&quot;代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">inner</span> &#123;  <span class="comment">//内部类</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内部类的分类"><a class="markdownIt-Anchor" href="#内部类的分类"></a> 内部类的分类</h2>
<ul>
<li>定义在外部类局部位置上（比如方法内）：
<ul>
<li>局部内部类（有类名）</li>
<li>匿名内部类（没有类名，重点！！！）⭐⭐</li>
</ul>
</li>
<li>定义在外部类的成员位置上
<ul>
<li>成员内部类（没用<code>static</code>修饰）</li>
<li>静态内部类（用<code>static</code>修饰）</li>
</ul>
</li>
</ul>
<h2 id="局部内部类"><a class="markdownIt-Anchor" href="#局部内部类"></a> 局部内部类</h2>
<p>定义在外部类的局部位置，比如方法中，并且有类名。</p>
<ul>
<li>可以直接访问外部类的所有成员，包含私有的。</li>
<li>不能添加访问修饰符，局部变量不能添加访问修饰符，可以使用<code>final</code>修饰，局部变量可以使用<code>final</code>修饰</li>
<li>**作用域：**仅仅在定义它的方法或代码块中。</li>
<li>局部内部类 <strong>直接访问</strong> 外部类成员</li>
<li>外部类 访问 局部内部类的成员，访问方式：创建对象，再访问（注意：必须在作用域内）</li>
<li>外部其他类 <strong>不能访问</strong> 局部内部类（因为局部内部类是一个局部变量）</li>
<li>如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果像访问外部类的成员，则可以使用（<code>外部类.this.成员</code>）去访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示局部内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer02</span> <span class="variable">outer02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer02</span>();</span><br><span class="line">        outer02.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer02</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner02</span> &#123;  <span class="comment">// 局部内部类的本质还是类</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">            <span class="comment">//可以直接访问外部类的所有成员，包含私有的</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 直接访问外部类的成员</span></span><br><span class="line">                System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1);  <span class="comment">// 100,内部类的n1</span></span><br><span class="line">                System.out.println(Outer02.<span class="built_in">this</span>.n1);  <span class="comment">// 10  ,外部类的n1,  Outer02.this 本质是调用了m1方法的对象</span></span><br><span class="line">                m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 外部类访问内部类成员，通过创建对象来进行访问</span></span><br><span class="line">        <span class="type">Inner02</span> <span class="variable">inner02</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner02</span>();</span><br><span class="line">        inner02.f1();</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;  <span class="comment">// 代码块</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner03</span>&#123;  <span class="comment">// 内部类</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类 ⭐⭐⭐</h2>
<p>匿名内部类是定义在外部类的局部位置，比如方法中，并且没有名字。</p>
<ul>
<li>本质：是一个<code>类</code>，且是一个<code>内部类</code>,该类没有名字，同时还是一个对象。</li>
<li>基本语法：<code>new 类或接口(参数列表) &#123;&#125;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示匿名内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnonymousInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer04</span> <span class="variable">outer04</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer04</span>();</span><br><span class="line">        outer04.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer04</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 基于接口的匿名内部类,</span></span><br><span class="line">        <span class="comment">// Tiger 编译类型为 A，运行类型为匿名内部类</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">Tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;老虎&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Tiger.cry(); <span class="comment">// 调用方法1，通过对象名调用</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Tiger的运行类型 = &quot;</span> + Tiger.getClass()); <span class="comment">// Outer04$1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于类的匿名内部类</span></span><br><span class="line">        <span class="comment">// father 的编译类型为Father，运行类型为 Outer04$2</span></span><br><span class="line">        <span class="comment">// class Outer04$2 extends Father &#123;&#125;</span></span><br><span class="line">        <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&quot;jack&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类重写了Test()方法&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.Test();   <span class="comment">// 调用方法2，因为是对象所以可以直接调用</span></span><br><span class="line">        System.out.println(<span class="string">&quot;father的运行类型 = &quot;</span> + father.getClass()); <span class="comment">// Outer04$1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;  <span class="comment">// 接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;  <span class="comment">// 类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义的特征，也有创建对象的特征。所以调用方法有两种，看上面的示例。</li>
<li>可以直接访问外部类的所有成员，包括私有成员。</li>
<li>不能添加访问修饰符，因为它是一个局部变量</li>
<li>作用域：仅仅在定义它的方法或代码块中</li>
<li>匿名内部类 <strong>直接访问</strong> 外部类成员</li>
<li>外部其它类 <strong>不能访问</strong> 匿名内部类，因为匿名内部类是一个局部变量，</li>
<li>如果外部类的成员和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则，如果像访问外部类的成员，则可以使用<code>外部类名.this.成员</code>去访问。</li>
</ul>
<h2 id="成员内部类"><a class="markdownIt-Anchor" href="#成员内部类"></a> 成员内部类</h2>
<p>定义在外部类的成员位置，并且没有<code>static</code>修饰，</p>
<ul>
<li>可以直接访问外部类的所有成员，包含私有的</li>
<li>可以添加访问修饰符（<code>public</code>、<code>private</code>、<code>默认</code>、<code>protected</code>），因为他的地位就是一个成员。</li>
<li>作用域：和外部类的其他成员一样，为整个类体。</li>
<li>成员内部类 <strong>直接访问</strong> 外部类（比如：属性）【访问方式：直接访问】</li>
<li>外部类 <strong>简介访问</strong> 内部类，访问方式：创建对象，再访问</li>
<li>外部其他类 访问 内部类，有两种访问方式：
<ul>
<li><code>Outer08.Inner08 inner08 = outer08.new Inner08();</code></li>
<li><code>Outer08.Inner08 inner081 = outer08.getInner08Instance();</code></li>
</ul>
</li>
<li>如果外部类和内部类中的成员重名时吗，内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(<code>外部类.this.成员</code>)去访问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenberInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Outer08</span> <span class="variable">outer08</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer08</span>();</span><br><span class="line">        outer08.t1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 外部其他类访问内部类 的方式1</span></span><br><span class="line">        Outer08.<span class="type">Inner08</span> <span class="variable">inner08</span> <span class="operator">=</span> outer08.<span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式2：在外部类中，编写一个方法，可以返回Inner08 对象</span></span><br><span class="line">        Outer08.<span class="type">Inner08</span> <span class="variable">inner081</span> <span class="operator">=</span> outer08.getInner08Instance();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer08</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner08</span> &#123;  <span class="comment">// 成员内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Outer08 的 n1 = &quot;</span> + n1 + <span class="string">&quot;Outer08 的 name = &quot;</span> + name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回Inner08对象实例</span></span><br><span class="line">    <span class="keyword">public</span> Inner08 <span class="title function_">getInner08Instance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">t1</span><span class="params">()</span>&#123;  <span class="comment">// 调用内部类的方法。</span></span><br><span class="line">        <span class="type">Inner08</span> <span class="variable">inner08</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner08</span>();</span><br><span class="line">        inner08.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h2>
<p>静态内部类是定义在外部类的成员位置，并且有<code>static</code>修饰</p>
<ul>
<li>可以直接访问外部类的所有静态成员，包括私有的，<strong>但不能直接访问非静态成员</strong></li>
<li>可以添加任意的访问修饰符，因为它是成员</li>
<li>作用域：同其他成员，为整个类体</li>
<li>静态内部类 <strong>直接访问</strong> 外部类的所有静态成员</li>
<li>外部类 <strong>访问</strong> 静态内部类 需要创建对象，再访问。</li>
<li>外部其他类 使用 静态内部类：三种方式
<ul>
<li><code>Outer10.Inner10 inner10 = new Outer10.Inner10();</code></li>
<li><code>Outer10.Inner10 inner10Instance = new Outer10().getInner10Instance();</code>创建对象，调用方法</li>
<li><code>Outer10.Inner10 inner10Instance1 = Outer10.getInner10Instance();</code>直接使用类名调用静态方法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 方式一：</span></span><br><span class="line">        <span class="comment">// 因为静态内部类，是可以通过类名直接进行访问。</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>.Inner10();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式二：</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner10Instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>().getInner10Instance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方式三：</span></span><br><span class="line">        Outer10.<span class="type">Inner10</span> <span class="variable">inner10Instance1</span> <span class="operator">=</span> Outer10.getInner10Instance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer10</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner10</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Inner10 <span class="title function_">getInner10Instance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Inner10</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="枚举和注解"><a class="markdownIt-Anchor" href="#枚举和注解"></a> 枚举和注解</h1>
<h2 id="枚举类"><a class="markdownIt-Anchor" href="#枚举类"></a> 枚举类</h2>
<ul>
<li>枚举是一组常量的集合</li>
<li>枚举属于一种特殊的类，里面只包含一组有限的特定的对象</li>
</ul>
<p>两种实现方式：</p>
<ul>
<li>自定义类实现枚举</li>
<li>使用<code>enum</code>关键字实现枚举</li>
</ul>
<h3 id="自定义类实现枚举"><a class="markdownIt-Anchor" href="#自定义类实现枚举"></a> 自定义类实现枚举</h3>
<ol>
<li>将构造器私有化，目的是防止直接new</li>
<li>去掉<code>setXXX</code>方法，防止属性被修改，因为枚举对象通常为只读</li>
<li>在类内部直接创建固定的对象</li>
<li>对枚举对象/属性使用<code>static + final</code>共同修饰，实现底层优化</li>
<li>枚举对象名通常使用全部大写，常量的命名规范</li>
<li>枚举对象根据需要，也可以有多个属性</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.enum_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enumeration01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.SPRING);</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示自定义枚举</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;  <span class="comment">// 季节类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc; <span class="comment">// 描述</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义了四个对象。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;酷热&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将构造器私有化，目的是防止直接new</span></span><br><span class="line">    <span class="comment">// 2. 去掉setXXX方法，防止属性被修改</span></span><br><span class="line">    <span class="comment">// 3. 在Season内部直接创建固定的对象</span></span><br><span class="line">    <span class="comment">// 4. 加入final修饰符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*public void setName(String name) &#123;</span></span><br><span class="line"><span class="comment">        this.name = name;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public void setDesc(String desc) &#123;</span></span><br><span class="line"><span class="comment">        this.desc = desc;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enum关键字实现枚举"><a class="markdownIt-Anchor" href="#enum关键字实现枚举"></a> <code>enum</code>关键字实现枚举</h3>
<p><strong>实现步骤：</strong></p>
<ul>
<li>使用<code>enum</code>关键字替换<code>class</code>关键字</li>
<li><code>SPRING(&quot;春天&quot;, &quot;温暖&quot;);</code>代替 <code>public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);</code>创建对象</li>
<li>如果有多个常量（对象），使用<code>,</code>间隔</li>
<li>如果使用<code>enum</code>来实现枚举，要求将定义常量对象，写在最前面。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.enum_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enumeration02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season02.AUTUMN);</span><br><span class="line">        System.out.println(Season02.SPRING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示使用enum关键字实现枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season02</span> &#123;</span><br><span class="line">    <span class="comment">// 定义了四个对象。</span></span><br><span class="line"><span class="comment">//    public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);</span></span><br><span class="line"><span class="comment">//    public static final Season WINTER = new Season(&quot;冬天&quot;, &quot;寒冷&quot;);</span></span><br><span class="line"><span class="comment">//    public static final Season SUMMER = new Season(&quot;夏天&quot;, &quot;酷热&quot;);</span></span><br><span class="line"><span class="comment">//    public static final Season AUTUMN = new Season(&quot;秋天&quot;, &quot;凉爽&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.使用enum 代替class</span></span><br><span class="line">    <span class="comment">// 2.SPRING(&quot;春天&quot;, &quot;温暖&quot;); 代替 public static final Season SPRING = new Season(&quot;春天&quot;, &quot;温暖&quot;);创建对象</span></span><br><span class="line">    <span class="comment">// 3.如果有多个常量（对象），使用, 间隔</span></span><br><span class="line">    <span class="comment">// 4.如果使用enum来实现枚举，要求将定义常量对象，写在最前面。</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>), WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>), SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;酷热&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>), WHAT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc; <span class="comment">// 描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season02</span><span class="params">(String name, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season02</span><span class="params">()</span> &#123;&#125;  <span class="comment">//无参构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season02&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, desc=&#x27;&quot;</span> + desc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>当我我们<code>enum</code>关键字开发一个枚举类时，默认会继承<code>Enum</code>类，而且是一个<code>final</code>类，使用<code>javap</code>工具进行验证</li>
<li>定义对象时被简化</li>
<li>如果使用的是无参构造器 创建 枚举对象，则实参列表和小括号都可以省略。</li>
<li>当有多个枚举对象时，使用<code>,</code>间隔，最后一个分号结束</li>
<li><strong>枚举对象必须放在枚举类的行首</strong></li>
<li><strong>当使用<code>enum</code>关键字后，就不能继承其他类，因为<code>enum</code>会隐式继承<code>Enum</code>类</strong></li>
<li><strong><code>enum</code>实现的枚举类，仍然是一个类，所以还是可以实现接口的</strong></li>
</ul>
<h4 id="enum类中的方法"><a class="markdownIt-Anchor" href="#enum类中的方法"></a> <code>Enum</code>类中的方法</h4>
<ul>
<li><code>toString()</code> : <code>Enum</code>类已经重写过了，返回的时当前对象名</li>
<li><code>name()</code>：输出枚举对象的名称</li>
<li><code>ordinal()</code>：输出该枚举对象的次序，从0开始编号</li>
<li><code>values()</code>：将所有定义的所有枚举对象以数组形式返回</li>
<li><code>valueOf()</code>：将字符串转成枚举对象，但要求字符串必须为已有的常量名，否则报异常。</li>
<li><code>compareTo()</code>：比较两个枚举常量，比较就是编号 <code>retrun self.ordinal - other.ordinal;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.enum_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 演示Enum类的各种方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season02</span> <span class="variable">autumn</span> <span class="operator">=</span> Season02.AUTUMN;</span><br><span class="line">        <span class="comment">// name()：输出枚举对象的名称</span></span><br><span class="line">        System.out.println(autumn.name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ordinal()：输出该枚举对象的次序，从0开始编号</span></span><br><span class="line">        System.out.println(autumn.ordinal());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// values():将所有定义的所有枚举对象以数组形式返回</span></span><br><span class="line">        Season02[] values = Season02.values();</span><br><span class="line">        <span class="keyword">for</span> (Season02 season: values) &#123;  <span class="comment">// 增强for循环， foreach</span></span><br><span class="line">            System.out.println(season);  <span class="comment">// 调用toString方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// valueOf(): 将字符串转成枚举对象，但要求字符串必须为已有的常量名，否则报异常。</span></span><br><span class="line">        <span class="type">Season02</span> <span class="variable">summer</span> <span class="operator">=</span> Season02.valueOf(<span class="string">&quot;SUMMER&quot;</span>);</span><br><span class="line">        System.out.println(summer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compareTo(): 比较两个枚举常量，比较就是编号 retrun self.ordinal - other.ordinal;</span></span><br><span class="line">        <span class="comment">// 用AUTUMN的编号减去SUMMER的编号，所以当等于0时，则相等</span></span><br><span class="line">        System.out.println(Season02.AUTUMN.compareTo(Season02.SUMMER));  <span class="comment">// -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h2>
<p>注解（<code>Annotation</code>）也被称为元数据（<code>Metadata</code>），用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息。</p>
<p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。</p>
<p>在<code>JavaSE</code>中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在<code>JavaEE</code>中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替<code>Java EE</code>旧版中所遗留的繁冗代码和XML配置等。</p>
<p>使用<code>Annotation</code>时要在其前面增加<code>@</code>符号，并把该<code>Annotation</code>当成一个修饰符使用。用于修饰它支持的程序元素。</p>
<h3 id="三个基本的annotation"><a class="markdownIt-Anchor" href="#三个基本的annotation"></a> 三个基本的<code>Annotation</code></h3>
<ul>
<li>
<p><code>@Override</code>：限定某个方法，是重写父类方法，该注解只能用于方法。</p>
<ul>
<li>
<p><code>@Override</code>可写可不写</p>
</li>
<li>
<p>如果写了<code>@Override</code>注解，编译器就会检查该方法是否真的重写了父类的方法，如果的确重写了，则编译通过，否则，则编译错误。</p>
</li>
<li>
<pre class="highlight"><code class="java"><span class="hljs-meta">@Target</span>(ElementType.METHOD)
<span class="hljs-meta">@Retention</span>(RetentionPolicy.SOURCE)
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Override &#123;  <span class="hljs-comment">// @interface 表示这个是一个注解</span>
&#125;
&lt;!--code￼<span class="hljs-number">27</span>--&gt;

</code></pre>
</li>
</ul>
</li>
<li>
<p><code>@SuppressWarnings</code>：抑制编译器警告</p>
</li>
</ul>
<h3 id="jdk的元注解了解"><a class="markdownIt-Anchor" href="#jdk的元注解了解"></a> JDK的元注解（了解）</h3>
<p>JDK的元Annotation用于修饰其它Annotation</p>
<h1 id="异常-exception"><a class="markdownIt-Anchor" href="#异常-exception"></a> 异常 Exception</h1>
<blockquote>
<p>Java语言中将程序执行中发生的不正常情况称为&quot;异常&quot;。（语法错误和逻辑错误不是异常）</p>
</blockquote>
<p>执行过程中异常可以分为两类：</p>
<ul>
<li><code>Error</code>（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等情况，</li>
<li><code>Exception</code>：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。
<ul>
<li>运行时异常：程序运行时发生的异常</li>
<li>编译时异常：程序编程时，由编译器检查出的异常。</li>
</ul>
</li>
</ul>
<p><img src="/img/Java/Error.png" alt="Error" /></p>
<h2 id="运行时异常"><a class="markdownIt-Anchor" href="#运行时异常"></a> 运行时异常</h2>
<p>编译器不要求强制处置的异常。一般是指编程时的逻辑错误没事成簇元应该避免其出现的异常。<code>java.lang.RuntimeException</code>类及它的子类都是运行时异常。</p>
<p>对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能对程序的可读性和运行效率产生影响。</p>
<h3 id="五大运行时异常"><a class="markdownIt-Anchor" href="#五大运行时异常"></a> 五大运行时异常</h3>
<ul>
<li><code>NullPointerException</code>空指针异常，当应用程序试图在需要对象的地方使用null时，抛出该异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.exception_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NullPointerException_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(name.length());  <span class="comment">// 存在空指针异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ArithmeticException</code>数学运算异常，当出现异常的运算条件时，抛出此异常。</li>
<li><code>ArryIndexOutOfBoundsException</code>数组越界异常，用非法索引访问数组时抛出异常。</li>
<li><code>ClassCastException</code>类型转换异常，当试图将对象强制转换成不是实例的子类时抛出异常。</li>
<li><code>NumberFormatException</code>数字格式不正确异常，当应用程序试图将字符串转换成一种数值类型，但该字符串必能准换为适当格式时，抛出异常。</li>
</ul>
<h2 id="编译时异常"><a class="markdownIt-Anchor" href="#编译时异常"></a> 编译时异常</h2>
<p>是编译器要求必须处置的异常。</p>
<h2 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h2>
<blockquote>
<p>当异常发生时，对异常处理的方式</p>
</blockquote>
<h3 id="try-catch-finally"><a class="markdownIt-Anchor" href="#try-catch-finally"></a> <code>try - catch - finally</code></h3>
<p>程序员在代码中捕获发生的异常，自行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//代码可能有异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//捕获到异常</span></span><br><span class="line">    <span class="comment">//1.当异常发生时，系统将异常封装给Exception对象e，传递给catch</span></span><br><span class="line">    <span class="comment">//2.得到异常对象后，程序员自己处理。</span></span><br><span class="line">    <span class="comment">//注意：如果没有发生异常，catch代码块不会执行。</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块是否有异常发生，始终要执行finally</span></span><br><span class="line">    <span class="comment">//通常将关闭释放资源的代码放在finally里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>如果异常发生了，则异常后买你的代码不会执行，直接进入到<code>catch</code>块，</li>
<li>如果异常没有发生，则顺序执行<code>try</code>的代码块，不会进入到<code>catch</code></li>
<li>如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等）则使用<code>finally</code></li>
</ul>
<h3 id="throws"><a class="markdownIt-Anchor" href="#throws"></a> <code>throws</code></h3>
<p>将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是JVM</p>
<p>当下层方法出现异常时，可以将异常抛出至上层调用自己的方法。直至抛出至JVM，JVM处理异常方法：输出异常信息，中断程序，退出程序。</p>
<p>如果程序员没有显示的处理异常，默认使用<code>throws</code>处理异常</p>
<p><strong>注意事项</strong></p>
<ul>
<li>对于编译异常，程序中必须处理，比如<code>try - catch</code>或者<code>throws</code></li>
<li>对于运行异常，程序中如果没有处理，默认就是<code>throws</code>方式处理</li>
<li>子类重写父类方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类。</li>
<li>在<code>throws</code>过程中，如果有方法<code>try-catch</code>，就相当于处理异常，就可以不必<code>throws</code></li>
</ul>
<h2 id="自定义异常"><a class="markdownIt-Anchor" href="#自定义异常"></a> 自定义异常</h2>
<blockquote>
<p>当程序中出现了某些“错误”，但该错误信息并没有在Trowable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。</p>
</blockquote>
<p><strong>步骤</strong></p>
<ol>
<li>定义类：自定义异常类名（程序员自己写），继承<code>Exception</code>或<code>RuntimeException</code></li>
<li>如果继承<code>Exception</code>，属于编译异常。</li>
<li>如果继承<code>RuntimeException</code>，属于运行异常（一般来说，继承<code>RuntimeException</code>）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.customexception;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在 18~120之间&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;你的年龄范围正确。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义运行时异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="throw-和-throws-的区别"><a class="markdownIt-Anchor" href="#throw-和-throws-的区别"></a> <code>throw</code> 和 <code>throws</code> 的区别</h3>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody>
</table>
<h1 id="常用类"><a class="markdownIt-Anchor" href="#常用类"></a> 常用类</h1>
<h2 id="包装类"><a class="markdownIt-Anchor" href="#包装类"></a> 包装类</h2>
<blockquote>
<p>针对八种基本数据类型相应的引用类型——包装类</p>
<p>有了类的特点，就可以调用类中的方法</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">基本数据类型</th>
<th style="text-align:center">包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean</td>
<td style="text-align:center">Boolean</td>
</tr>
<tr>
<td style="text-align:center">char</td>
<td style="text-align:center">Character</td>
</tr>
<tr>
<td style="text-align:center">byte</td>
<td style="text-align:center">Byte</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">Short</td>
</tr>
<tr>
<td style="text-align:center">int</td>
<td style="text-align:center">Integer</td>
</tr>
<tr>
<td style="text-align:center">long</td>
<td style="text-align:center">Long</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">Float</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">Double</td>
</tr>
</tbody>
</table>
<h3 id="包装类和基本数据的转换"><a class="markdownIt-Anchor" href="#包装类和基本数据的转换"></a> 包装类和基本数据的转换</h3>
<ul>
<li><code>jdk5</code>前的手动装箱和拆箱方式，装箱：基本类型-&gt;包装类，反之为拆箱</li>
<li><code>jdk5</code>以后的自动装箱和拆箱方式</li>
<li>自动装箱底层调用的是<code>valueOf()</code>方法，自动拆箱底层调用的是<code>intValue()</code>方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.wrapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperType</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 演示int 和Integer的装箱和拆箱</span></span><br><span class="line">        <span class="comment">//手动装箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n1);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> Integer.valueOf(n1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jdk5 后就可以自动装箱和自动拆箱</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="comment">// 自动装箱 int-&gt; Integer</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer2</span> <span class="operator">=</span> n2; <span class="comment">// 底层使用的是 Interger.valueOf()</span></span><br><span class="line">        <span class="comment">// 自动拆箱</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> integer2; <span class="comment">// 底层仍然使用的是intValue()方法。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包装类型和string类型的相互转换"><a class="markdownIt-Anchor" href="#包装类型和string类型的相互转换"></a> 包装类型和String类型的相互转换</h3>
<p>以<code>Integer</code>和<code>String</code>类型的相互转换为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.wrapper;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WrapperVSString</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 包装类Integer - &gt; String</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">100</span>;  <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> integer + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> integer.toString();</span><br><span class="line">        <span class="comment">// 方式3</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(integer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String -&gt; 包装类</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="comment">// 方式1</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str); <span class="comment">// 自动装箱</span></span><br><span class="line">        <span class="comment">// 方式2</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str); <span class="comment">// 构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="包装类常用的方法"><a class="markdownIt-Anchor" href="#包装类常用的方法"></a> 包装类常用的方法</h3>
<p><code>Integer</code>类和<code>String</code>类为例</p>
<ul>
<li><code>Integer.MIN_VALUE</code>，返回最小值</li>
<li><code>Integer.MAX_VALUE</code>，返回最大值</li>
<li><code>Character.isDigit('a')</code>，判断是不是数字</li>
<li><code>Character.isLetter('a')</code>，判断是不是字母</li>
<li><code>Character.isUpperCase('a')</code>，判断是不是大写</li>
<li><code>Character.isLowerCase('a')</code>，判断是不是小写</li>
<li><code>Character.isLowerCase('a')</code>，判断是不是小写</li>
<li><code>Character.isWhitespace('a')</code>，判断是不是空格</li>
<li><code>Character.toLowerCase('a')</code>，转成小写</li>
<li><code>Character.toUpperCase('a')</code>，转成大写</li>
</ul>
<h2 id="string类"><a class="markdownIt-Anchor" href="#string类"></a> String类</h2>
<ul>
<li><code>String</code>对象适用于保存字符串，也就是一组字符序列</li>
<li>字符串常量对象是用双引号括起来的字符序列。如：“jack”</li>
<li>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节。</li>
<li><code>String</code>类有很多构造器，构造器的重载。</li>
<li><code>String</code> 类实现了接口<code>Serializable</code>，则String可以串行化（数据可以在网络传输），还实现了<code>Comparable</code>接口，对象可以比较大小。</li>
<li><code>String</code> 是<code>final</code>类，不能被继承</li>
<li><code>String</code> 有属性 <code>private final char value[]</code>用于存放字符串内容。因为是<code>final</code>类型，所以不可以修改（指代地址不能够修改）</li>
</ul>
<h3 id="创建string对象的两种方式"><a class="markdownIt-Anchor" href="#创建string对象的两种方式"></a> 创建String对象的两种方式</h3>
<ul>
<li>直接赋值<code>String str = &quot;xzt&quot;;</code></li>
<li>调用构造器<code>String str = new String(&quot;xzt&quot;);</code></li>
</ul>
<h3 id="字符串的特性"><a class="markdownIt-Anchor" href="#字符串的特性"></a> 字符串的特性</h3>
<ul>
<li><code>String</code>类是一个<code>final</code>类，代表不可变的字符序列</li>
<li>字符串不可变，一个字符串对象一旦被分配，其内容是不可变的。</li>
</ul>
<h3 id="string类的常见方法"><a class="markdownIt-Anchor" href="#string类的常见方法"></a> String类的常见方法</h3>
<p>String类是保存字符串常量的，每次更新都需要重新开辟空间，效率低，因此java设计者还提供了<code>StringBuilder</code>和<code>StringBuffer</code>来增强String的功能，并提高效率。</p>
<ul>
<li><code>equals()</code>区分大小写，判断内容是否相等</li>
<li><code>length()</code> 获取字符的个数，字符串的长度</li>
<li><code>indexOf()</code>获取第i个字符</li>
<li><code>substring(x)</code>，截取索引x后面的内容</li>
<li><code>substring(start, end)</code>，从索引start开始，一直到索引end-1的位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.string_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;jack&quot;</span>;</span><br><span class="line">        System.out.println(str.equals(<span class="string">&quot;JACK&quot;</span>)); <span class="comment">//False 区分大小写</span></span><br><span class="line">        System.out.println(str.equalsIgnoreCase(<span class="string">&quot;JACK&quot;</span>)); <span class="comment">// True，不区分大小写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            System.out.println(str.indexOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abcdfsadfrf&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> s1.indexOf(<span class="string">&#x27;a&#x27;</span>);<span class="comment">// 返回第一次出现&#x27;a&#x27;的位置</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> s1.substring(<span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stringbuffer类"><a class="markdownIt-Anchor" href="#stringbuffer类"></a> <code>StringBuffer</code>类</h2>
<p><code>java.lang.StringBuffer</code>代表可变的字符序列，可以对字符串内容进行增删。很多方法和String相同，但<code>StringBuffer</code><strong>是可变长度的</strong>。</p>
<ul>
<li><code>StringBuffer</code>是一个容器</li>
</ul>
<p><strong>类结构</strong></p>
<ul>
<li>直接父类是<code>AbstractStringBuilder</code>类</li>
<li>实现了<code>Serializable</code>，即<code>StringBuffer</code>的对象可以串行化</li>
<li>在父类中 有属性 <code>char[] value</code>，不是<code>final</code>，该value数组存放字符串的内容。存放在堆中。</li>
<li><code>StringBuffer</code>是一个<code>final</code>类，不能被继承。</li>
</ul>
<h3 id="stringbuffer-vs-string"><a class="markdownIt-Anchor" href="#stringbuffer-vs-string"></a> <code>StringBuffer</code> VS <code>String</code></h3>
<ol>
<li><code>String</code>保存的是字符串常量，里面的值不能更改，每次<code>String</code>类的更新实际上就是更改地址，效率低。</li>
<li><code>StringBuffer</code>保存的是字符串变量，里面的值可以更改，每次<code>StringBuffer</code>的更新实际上可以更新内容，不用更新地址，效率高。</li>
</ol>
<h3 id="构造器"><a class="markdownIt-Anchor" href="#构造器"></a> 构造器</h3>
<ul>
<li><code>StringBuffer stringBuffer = new StringBuffer();</code>创建一个大小为16的<code>char[]</code>，用于存放字符内容</li>
<li><code>StringBuffer stringBuffer = new StringBuffer(100);</code>，通过构造器指定<code>char[]</code> 大小</li>
<li><code>StringBuffer stringBuffer = new StringBuffer(&quot;Hello&quot;);</code> 通过构造器给一个<code>String</code>创建<code>StringBuffer</code>，<code>char[]</code>大小为String的长度 + 16</li>
</ul>
<h3 id="stringbuffer的转换"><a class="markdownIt-Anchor" href="#stringbuffer的转换"></a> <code>StringBuffer</code>的转换</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.StringBuffer_;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringAndStringBuffer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello Xzt&quot;</span>;</span><br><span class="line">        <span class="comment">//String -&gt; StringBuffer</span></span><br><span class="line">        <span class="comment">// 1. 使用构造器，返回的才是StringBuffer对象，对String本身没有对象。</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 使用append方法</span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        stringBuffer1.append(str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//StringBuffer -&gt; String</span></span><br><span class="line">        <span class="comment">// 1. 使用StringBuffer提供的toString方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer.toString();</span><br><span class="line">        <span class="comment">// 2. 使用构造器转换</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stringbuilder类"><a class="markdownIt-Anchor" href="#stringbuilder类"></a> <code>StringBuilder</code>类</h2>
<p>一个可变的字符序列，此类提供一个与<code>StringBuffer</code>兼容的API，但不保证同步。该类被设计用作<code>StringBuffer</code>的一个简易替换，<strong>用在字符串缓冲区被单个线程使用的时候</strong>。如果可能，建议优先采用该类，因为在大多数实现中，它比<code>StringBuffer</code>要快。</p>
<p>在<code>StringBuilder</code>上主要操作的是<code>append()</code>和<code>insert()</code>方法，可重载这些方法，以接受任意类型的数据。</p>
<h2 id="math类"><a class="markdownIt-Anchor" href="#math类"></a> Math类</h2>
<blockquote>
<p>Math类包含于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。</p>
<p>均是静态方法，因此可以直接使用<code>Math.</code>调用。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>abs(x)</code></td>
<td style="text-align:center">计算x的绝对值</td>
</tr>
<tr>
<td style="text-align:center"><code>pow(x, y)</code></td>
<td style="text-align:center">计算幂，x的y次方</td>
</tr>
<tr>
<td style="text-align:center"><code>ceil(x)</code></td>
<td style="text-align:center">返回大于等于x的最小整数，向上取整</td>
</tr>
<tr>
<td style="text-align:center"><code>floor(x)</code></td>
<td style="text-align:center">返回小于等于x的最小整数，向下取整</td>
</tr>
<tr>
<td style="text-align:center"><code>round(x)</code></td>
<td style="text-align:center">将x进行四舍五入并返回</td>
</tr>
<tr>
<td style="text-align:center"><code>sqrt(x)</code></td>
<td style="text-align:center">求x的开方</td>
</tr>
<tr>
<td style="text-align:center"><code>random()</code></td>
<td style="text-align:center">返回的是0&lt;= x &lt; 1之间的一个随机小数</td>
</tr>
<tr>
<td style="text-align:center"><code>max(x, y)</code></td>
<td style="text-align:center">求两个数的最大值</td>
</tr>
<tr>
<td style="text-align:center"><code>min(x, y)</code></td>
<td style="text-align:center">求两个数的最小值</td>
</tr>
</tbody>
</table>
<h2 id="arrays类"><a class="markdownIt-Anchor" href="#arrays类"></a> Arrays类</h2>
<p><code>Arrays</code>l里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）</p>
<p><strong>常用的方法</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">函数</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Arrays.toString(arr)</code></td>
<td style="text-align:center">遍历（显示）数组</td>
</tr>
<tr>
<td style="text-align:center"><code>Arrays.sort(arr);</code></td>
<td style="text-align:center">默认从小到大将数组进行排序，可以通过<code>Conparator</code>接口实现定制排序，排序不会改变原本的数组</td>
</tr>
<tr>
<td style="text-align:center"><code>Arrays.binarySearch(arr, x)</code></td>
<td style="text-align:center">通过二分搜索进行查找，要求数组必须排好序</td>
</tr>
<tr>
<td style="text-align:center"><code>Arrays.copyOf(arr, x)</code></td>
<td style="text-align:center">将arr数组中的x个元素拷贝至一个新数组中</td>
</tr>
<tr>
<td style="text-align:center"><code>Arrays.fill(arr, x)</code></td>
<td style="text-align:center">使用x填充arr数组</td>
</tr>
<tr>
<td style="text-align:center"><code>Arrays.equals(arr, tem)</code></td>
<td style="text-align:center">比较两个数组，如果数组中的元素一样，返回<code>true</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Arrays.asList(1,2,3,4)</code></td>
<td style="text-align:center">会将数据转成一个<code>List</code>集合并返回。</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.arrays_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] integers = &#123;<span class="number">1</span>, <span class="number">20</span>, <span class="number">90</span>&#125;;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; integers.length; i++) &#123;</span><br><span class="line">            System.out.println(integers[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接受用toString方法</span></span><br><span class="line">        System.out.println(Arrays.toString(integers));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 演示sort方法的使用</span></span><br><span class="line">        Integer[] arrs = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">89</span>&#125;;</span><br><span class="line">        Arrays.sort(arrs);</span><br><span class="line">        System.out.println(Arrays.toString(arrs));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定制排序, 变为从大到小， 体现了接口编程的方法。</span></span><br><span class="line">        Arrays.sort(arrs, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arrs));</span><br><span class="line">        System.out.println(Arrays.binarySearch(arrs, -<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>冒泡排序 + <code>Comparator</code>定制</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.arrays_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArraysSortCustom</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">20</span>&#125;;</span><br><span class="line"></span><br><span class="line">        bubbleSort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (Integer) o1;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> (Integer) o2;</span><br><span class="line">                <span class="keyword">return</span> i1 - i2; <span class="comment">// 从小到大</span></span><br><span class="line"><span class="comment">//                return i2 - i1; // 从大到小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通冒泡排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 从小到大</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">                    arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 冒泡排序 + 定制，重载方法。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr, Comparator c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c.compare(arr[i], arr[i + <span class="number">1</span>]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[i + <span class="number">1</span>];</span><br><span class="line">                    arr[i + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="system类"><a class="markdownIt-Anchor" href="#system类"></a> System类</h2>
<p><strong>常用方法</strong></p>
<ul>
<li><code>System.exit(0)</code> 退出当前程序</li>
<li><code>arraycopy()</code>：赋值数组元素，比较适合底层调用，一般使用<code>Arrays.copyOf</code>完成复制数组</li>
<li><code>System.currentTimeMillens()</code>：返回当前时间距离1970-1-1的毫秒数</li>
<li><code>System.gc()</code>：运行垃圾回收机制。</li>
</ul>
<h2 id="biginteger-和-bigdecimal-类"><a class="markdownIt-Anchor" href="#biginteger-和-bigdecimal-类"></a> BigInteger 和 BigDecimal 类</h2>
<blockquote>
<p>BigInteger 适合保存比较大的整型</p>
<p>BigDecimal 适合保存精度更高的浮点型（小数）</p>
</blockquote>
<h3 id="biginteger-类"><a class="markdownIt-Anchor" href="#biginteger-类"></a> BigInteger 类</h3>
<ul>
<li>不能直接进行加减乘除，需要使用提供的相应方法进行操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.biginteger_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigInteger_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;123456789987654321&quot;</span>);</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">bigInteger1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(bigInteger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">add</span> <span class="operator">=</span> bigInteger.add(bigInteger1);</span><br><span class="line">        System.out.println(add);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//减</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">subtract</span> <span class="operator">=</span> bigInteger.subtract(bigInteger1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乘</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">multiply</span> <span class="operator">=</span> bigInteger.multiply(bigInteger1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 除</span></span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">divide</span> <span class="operator">=</span> bigInteger.divide(bigInteger1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bigdecimal-类"><a class="markdownIt-Anchor" href="#bigdecimal-类"></a> BigDecimal 类</h3>
<ul>
<li>使用方法和<code>BigInteger</code>类似，</li>
<li>除法可能会产生异常，因为可能会产生无线循环小数，所以需要在后面指定精度。会保留分子精度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.bigdecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigDecimal_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12.15626498411494692196496265965269560000&quot;</span>);</span><br><span class="line">        System.out.println(bigDecimal);</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">bigDecimal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1.1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(bigDecimal.add(bigDecimal1));</span><br><span class="line">        System.out.println(bigDecimal.subtract(bigDecimal1));</span><br><span class="line">        System.out.println(bigDecimal.multiply(bigDecimal1));</span><br><span class="line">        <span class="comment">// 出发，保留分子精度</span></span><br><span class="line">        System.out.println(bigDecimal.divide(bigDecimal1, BigDecimal.ROUND_CEILING));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="日期类"><a class="markdownIt-Anchor" href="#日期类"></a> 日期类</h2>
<h3 id="第一代日期类"><a class="markdownIt-Anchor" href="#第一代日期类"></a> 第一代日期类</h3>
<blockquote>
<p>​	Date : 可以精确到毫秒，代表特定的瞬间</p>
</blockquote>
<ul>
<li><code>SimpleDateFormat</code>：格式和解析日期的类。它允许进行格式化（日期-&gt;文本）解析（文本-&gt;日期）</li>
<li><code>Date date = new Date()</code>，这里的<code>Date</code>类是在<code>java.util</code>包</li>
<li>默认输出的日期格式是国外的方式，因此需要对格式进行转换。</li>
<li><code>SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;);</code> 用于将日期格式化为自定义格式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.date_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.SimpleFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Date_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 获取当前日期</span></span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将日期转为自定义格式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">        System.out.println(format);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将毫秒数转为具体日期</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">9234567</span>);</span><br><span class="line">        System.out.println(date1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将字符串转换为Date，输出形式仍为国外格式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1997年01月01日 10:20:30 星期五&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;  <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sdf.parse(s);</span><br><span class="line">            System.out.println(sdf.format(parse));  <span class="comment">// 将日期格式转为自定义格式</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二代日期类"><a class="markdownIt-Anchor" href="#第二代日期类"></a> 第二代日期类</h3>
<blockquote>
<p>主要就是Calendar类（日历） ，Calendar类是一个抽象类，为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法。</p>
</blockquote>
<ul>
<li><code>Calendar</code>是一个抽象类，并且构造器是<code>private</code>，可以通过<code>getInstance</code>方法来获取实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.date_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calendar_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(instance.get(Calendar.YEAR));</span><br><span class="line">        <span class="comment">// 月是按照从0开始编号的</span></span><br><span class="line">        System.out.println(instance.get(Calendar.MONTH) + <span class="number">1</span>);</span><br><span class="line">        System.out.println(instance.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">        System.out.println(instance.get(Calendar.HOUR));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三代日期类"><a class="markdownIt-Anchor" href="#第三代日期类"></a> 第三代日期类</h3>
<p><code>Calendar</code>类存在的问题：</p>
<ul>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：<code>Date</code>中的年份是从1900年开始的，而月份都从0开始</li>
<li>格式化：格式化支队<code>Date</code>有用，<code>Calendar</code>则不行</li>
<li>此外，他们也不是线程安全的；不能处理闺秒等（每隔两天，多出一秒）</li>
</ul>
<p><strong>第三代日期类常见方法</strong></p>
<ul>
<li><code>LocalDate</code>(日期/年月日)、<code>LocalTime</code>（时间/时分秒）、<code>LocalDateTime</code>（日期时间，JDK8加入）</li>
<li><code>LocalDateTime now = LocalDateTime.now();</code>获得当前时间</li>
<li>使用<code>DateTimeFormatter</code>格式日期类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.date_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDateTime_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获得当前时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        System.out.println(now);</span><br><span class="line"></span><br><span class="line">        System.out.println(now.getMonthValue());</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(now);</span><br><span class="line">        System.out.println(format);  <span class="comment">// 格式化时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="集合"><a class="markdownIt-Anchor" href="#集合"></a> 集合</h1>
<p><strong>优点</strong></p>
<ul>
<li>可以动态保存任意多个对象，使用比较方便</li>
<li>提供了一系列方便的操作对象的方法：add、remove、set、get等</li>
<li>使用集合添加，删除新元素的示意代码简洁</li>
</ul>
<p><strong>集合的框架体系⭐⭐</strong></p>
<blockquote>
<p>​	Java 的集合类很多，主要分为两大类：单列集合、双列集合(键值对类型)</p>
</blockquote>
<h2 id="单列集合-collection"><a class="markdownIt-Anchor" href="#单列集合-collection"></a> 单列集合 Collection</h2>
<p><img src="/img/Java/Collection.png" alt="Collection" /></p>
<h3 id="collection接口实现类的特点"><a class="markdownIt-Anchor" href="#collection接口实现类的特点"></a> <code>Collection</code>接口实现类的特点</h3>
<p><code>public interface Collection&lt;E&gt; extends iterable&lt;E&gt;</code></p>
<ul>
<li><code>Collection</code>实现子类可以存放多个元素，每个元素可以是<code>Object</code></li>
<li>有些<code>Collection</code>的实现类，可以存放重复的元素，有些不可以</li>
<li>有些<code>Collection</code>的实现类，有些是有序的（<code>List</code>），有些是无序的（<code>Set</code>）</li>
<li><code>Collection</code>接口没有直接的实现子类，是通过它的子接口<code>Set</code>和<code>List</code>来实现的</li>
</ul>
<h3 id="常用的方法"><a class="markdownIt-Anchor" href="#常用的方法"></a> 常用的方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>add(x)</code></td>
<td style="text-align:center">添加元素</td>
</tr>
<tr>
<td style="text-align:center"><code>remove(x)</code></td>
<td style="text-align:center">删除元素</td>
</tr>
<tr>
<td style="text-align:center"><code>contains(x)</code></td>
<td style="text-align:center">查找某个元素是否存在</td>
</tr>
<tr>
<td style="text-align:center"><code>size()</code></td>
<td style="text-align:center">返回元素的个数</td>
</tr>
<tr>
<td style="text-align:center"><code>isEmpty()</code></td>
<td style="text-align:center">判断是否为空</td>
</tr>
<tr>
<td style="text-align:center"><code>clear()</code></td>
<td style="text-align:center">清空列表</td>
</tr>
<tr>
<td style="text-align:center"><code>addAll(结合)</code></td>
<td style="text-align:center">添加多个元素</td>
</tr>
<tr>
<td style="text-align:center"><code>containsAll(集合)</code></td>
<td style="text-align:center">查看多个元素是否都存在</td>
</tr>
<tr>
<td style="text-align:center"><code>removeAll(集合)</code></td>
<td style="text-align:center">删除多个元素</td>
</tr>
</tbody>
</table>
<h3 id="遍历元素的方式"><a class="markdownIt-Anchor" href="#遍历元素的方式"></a> 遍历元素的方式</h3>
<p><strong>使用<code>iterator</code>迭代器进行遍历</strong></p>
<ul>
<li><code>Iterator iterator = list.iterator();</code>生成一个迭代器</li>
<li><code>iterator.hashNext()</code>判断是否还存在下一个元素</li>
<li><code>Object next = iterator.next();</code>返回下一个元素，以<code>Object</code>类型返回</li>
<li>遍历一遍后，如果需要进行再次遍历，需要重置迭代器<code>iterator = list.iterator();</code></li>
</ul>
<p><strong>增强<code>for循环</code>进行遍历</strong></p>
<ul>
<li>底层仍然是迭代器，是简化版的迭代器。</li>
<li><code>for(Object obj : list) &#123;&#125;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.collection_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="comment">// add 添加元素</span></span><br><span class="line">        list.add(<span class="string">&quot;xzt&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;qqy&quot;</span>);</span><br><span class="line">        list.add(<span class="number">20</span>);</span><br><span class="line">        list.add(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历集合</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;  <span class="comment">// 判断是否还有数据</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();  <span class="comment">// 返回下一个元素，类型是Object</span></span><br><span class="line">            System.out.println(next);   <span class="comment">// 动态绑定，调用相应对象的toString方法</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        iterator = list.iterator();  <span class="comment">// 重置迭代器</span></span><br><span class="line">        <span class="comment">//快捷键实现： itit + Enter</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增强for循环进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Object obj: list) &#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="list"><a class="markdownIt-Anchor" href="#list"></a> List</h3>
<ul>
<li><code>List</code>集合类中元素有序（即添加顺序和取出顺序一致）、且可重复</li>
<li><code>List</code>集合中的每个元素都有其对应的顺序索引，即支持索引，索引是从0开始</li>
<li><code>List</code>的实现类有很多，例如：<code>ArrayList</code>、<code>Vector</code>、<code>Stack</code>、<code>LinkedList</code>等等</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>add(int index, Object obj)</code></td>
<td style="text-align:center">在index位置插入obj</td>
</tr>
<tr>
<td style="text-align:center"><code>addAll(int index, Collection col)</code></td>
<td style="text-align:center">在index位置开始插入col中的所有元素</td>
</tr>
<tr>
<td style="text-align:center"><code>get(int index)</code></td>
<td style="text-align:center">获得index位置的元素</td>
</tr>
<tr>
<td style="text-align:center"><code>indexOf(Onject obj)</code></td>
<td style="text-align:center">返回obj在集合中首次出现的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>lastIndexOf(Object obj)</code></td>
<td style="text-align:center">返回obj在当前集合中最后出现的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>remove(int index)</code></td>
<td style="text-align:center">移除index位置的元素</td>
</tr>
<tr>
<td style="text-align:center"><code>set(int index, Object obj)</code></td>
<td style="text-align:center">设置指定位置的元素为obj，相当于是替换</td>
</tr>
</tbody>
</table>
<p><strong>三种遍历方式</strong></p>
<p>使用于所有的<code>List</code>子类，前两种和上面<code>Collection</code>类的遍历方法相同</p>
<ul>
<li>使用<code>iterator</code>迭代器遍历</li>
<li>使用<code>增强for循环</code>进行遍历</li>
<li>使用<code>for循环</code>进行遍历</li>
</ul>
<h4 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> <code>ArrayList</code></h4>
<p><strong>注意事项</strong></p>
<ul>
<li>可以存放各种类型的元素，甚至包括空元素<code>null</code></li>
<li>是由数组来实现数据存储的</li>
<li>基本等同于<code>Vector</code>，但<code>ArrayList</code>是线程不安全的（执行效率高），在多线程情况下，不建议使用<code>ArrayList</code></li>
</ul>
<p><strong>底层操作机制</strong>⭐⭐</p>
<p>查看源码，进行分析</p>
<ul>
<li><code>ArrayList</code>中维护的是一个<code>Object</code>类型数组<code>elementData</code>，<code>transient Object[] elementData</code>，<strong>transient 表示该属性不会被序列化</strong></li>
<li>当创建<code>ArrayList</code>时，如果使用的是无参构造器，则初始<code>elementData</code>容量为0，第一次添加，则扩容至10，如需再次扩容，则扩容为之前的1.5倍。</li>
<li>如果使用的是指定大小的构造器，则初始化<code>elementData</code>的容量为指定大小，如果需要扩容，则直接扩容至1.5倍</li>
</ul>
<h4 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> <code>Vector</code></h4>
<ul>
<li><code>Vector</code>底层也是一个对象数组，<code>protected Object[] elementData</code></li>
<li><code>Vector</code>是线程同步的，即线程安全的，<code>Vector</code>类的操作方法带有<code>synchronized</code>，若需要线程同步，则考虑使用<code>Vector</code></li>
</ul>
<h4 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> <code>LinkedList</code></h4>
<ul>
<li>底层实现了<strong>双向链表</strong>和<strong>双端队列</strong>特点</li>
<li>可以添加任意元素（元素可以重复），包括null</li>
<li>线程不安全，没有实现同步</li>
</ul>
<p><strong>底层操作机制</strong>⭐⭐</p>
<ul>
<li>底层维护了一个双向链表</li>
<li>维护了两个属性<code>first</code>和<code>last</code>分别指向首节点和尾节点</li>
<li>每个节点（Node对象），里面又维护了<code>prev</code>、<code>next</code>、<code>item</code>三个属性，其中通过<code>prev</code>指向前一个节点，通过<code>next</code>指向后一个节点，最终实现了双向链表。</li>
<li>所以<code>LinkedList</code>的元素的添加和删除，不是通过数组完成的，相对来说效率较高</li>
</ul>
<h4 id="arraylist和linkedlist比较"><a class="markdownIt-Anchor" href="#arraylist和linkedlist比较"></a> <code>ArrayList</code>和<code>LinkedList</code>比较</h4>
<table>
<thead>
<tr>
<th></th>
<th>底层结构</th>
<th>增删的效率</th>
<th>改查的效率</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ArrayList</code></td>
<td>可变数组</td>
<td>较低，数组扩容</td>
<td>较高</td>
</tr>
<tr>
<td><code>LinkedList</code></td>
<td>双向链表</td>
<td>较高，通过链表追加</td>
<td>较低</td>
</tr>
</tbody>
</table>
<p><strong>如何选择<code>ArrayList</code>和<code>LinkedList</code></strong></p>
<ol>
<li>如果我们改查的操作多，选择<code>ArrayList</code></li>
<li>如果我们增删的操作多，选择<code>LinkedList</code></li>
<li>一般来说，在程序中，80%~90%都是查询，因此大部分情况选择<code>ArrayList</code></li>
<li>在一个项目中，根据业务灵活选择，也可能这样，一个模块使用<code>ArrayList</code>，另一个模块是<code>LinkedList</code></li>
</ol>
<h3 id="set"><a class="markdownIt-Anchor" href="#set"></a> Set</h3>
<ul>
<li>无序（添加和取出的顺序不一致），没有索引，取出的顺序虽然不是添加的顺序，但是是固定的。</li>
<li>不允许重复元素，所以最多包含一个<code>null</code></li>
<li>JDK API中<code>Set</code>接口的实现类有：<code>HashSet</code>、<code>TreeSet</code>等等</li>
</ul>
<p><code>set</code><strong>接口常用的方法</strong></p>
<p>和<code>List</code>接口一样，<code>Set</code>接口也是<code>Collection</code>的子接口，因此，常用方法和<code>Collection</code>接口一样。</p>
<p><code>Set</code><strong>接口的遍历方式</strong></p>
<ul>
<li>使用<code>iterator</code>迭代器遍历</li>
<li>使用<code>增强for循环</code>进行遍历</li>
<li><strong>不能使用</strong>索引的方式来获取</li>
</ul>
<h4 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> <code>HashSet</code></h4>
<ul>
<li><code>HashSet</code>实现了<code>Set</code>接口</li>
<li><code>HashSet</code>底层实际上是<code>HashMap</code></li>
<li>可以存放<code>null</code>，但最多只能存放一个</li>
<li>不保证元素是有序的，取决于hash后，在确定索引的结果，即不保证存放元素的顺序和取出顺序一致</li>
<li>不能有重复元素，</li>
</ul>
<p><strong>扩容机制</strong>⭐⭐</p>
<ul>
<li>底层是<code>HashMap</code></li>
<li>添加一个元素时，先得到hash值，会转成索引值</li>
<li>找到存储数据表table，看这个索引位置是否已经存放的有元素,如果没有，直接加入，如果有，调用<code>equals</code>比较，如果相同，就放弃添加，反之，则添加到最后。</li>
<li>在Java 8中，如果一条链表的元素个数超过<code>TREEIFY_THRESHOLD</code>（默认是8），并且table的大小 &gt;= <code>MIN_TREEIFY_CAPACITY</code>(默认是64)，就会进行树化（红黑树）</li>
</ul>
<h4 id="linkedhashset"><a class="markdownIt-Anchor" href="#linkedhashset"></a> <code>LinkedHashSet</code></h4>
<ul>
<li>继承了<code>HashSet</code>,是<code>HashSet</code>的子类</li>
<li>底层是一个<code>LinkedHashMap</code>，底层维护的是一个 数组 + 双向链表</li>
<li><code>LinkedHashSet</code> 根据元素的<code>hashCode</code>值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</li>
<li><code>LinkedHashSet</code>不允许添加重复元素</li>
</ul>
<h4 id="treeset"><a class="markdownIt-Anchor" href="#treeset"></a> <code>TreeSet</code></h4>
<ul>
<li>当使用无参构造器创建<code>TreeSet</code>时，它默认按字典序进行排序。</li>
<li>使用<code>TreeSet</code>提供的一个构造器，可以传入一个比较器（匿名内部类），并指定排序规则。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.set_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSet_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="comment">// 调用字符串的compareTo方法进行字符串大小比较</span></span><br><span class="line">                <span class="keyword">return</span> ((String) o1).compareTo((String) o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 添加数据</span></span><br><span class="line">        treeSet.add(<span class="string">&quot;jack&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;xzt&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;qqy&quot;</span>);</span><br><span class="line">        treeSet.add(<span class="string">&quot;z&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双列集合-k-v"><a class="markdownIt-Anchor" href="#双列集合-k-v"></a> 双列集合 （K - V）</h2>
<blockquote>
<p>​	双列集合里面存放的是键值对类型（Key - Value）</p>
</blockquote>
<p><img src="/img/Java/Map.png" alt="Map" /></p>
<h3 id="map"><a class="markdownIt-Anchor" href="#map"></a> Map</h3>
<p><strong>特点</strong></p>
<ul>
<li><code>Map</code>与<code>Collection</code>并列存在，用于保存具有映射关系的数据：Key - Value</li>
<li><code>Map</code>中的 key 和 value 可以是任何引用类型的数据， 会封装在<code>HashMap$Node</code> 对象中</li>
<li><code>Map</code>中的 key 不允许重复，当有相同的 key 时，就等价于替换value</li>
<li><code>Map</code>中的 value 可以重复</li>
<li><code>Map</code>中的 key 可以为null，value 也可以为 null ，注意 key 为 null 只能有一个。value为null 可以有多个</li>
<li>常用String类作为<code>Map</code> 的 key</li>
<li>key 和 value 是一对一的关系，所以根据指定 key 能找到对应的 value</li>
</ul>
<p><strong>常用方法</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>put(K, V)</code></td>
<td style="text-align:center">添加元素，存入键值对</td>
</tr>
<tr>
<td style="text-align:center"><code>remove(K)</code>、<code>remove(K, V)</code></td>
<td style="text-align:center">根据键删除映射关系</td>
</tr>
<tr>
<td style="text-align:center"><code>get(K)</code></td>
<td style="text-align:center">根据键获取对应的值</td>
</tr>
<tr>
<td style="text-align:center"><code>size()</code></td>
<td style="text-align:center">获取元素个数</td>
</tr>
<tr>
<td style="text-align:center"><code>isEmpty()</code></td>
<td style="text-align:center">判断是否为空</td>
</tr>
<tr>
<td style="text-align:center"><code>clear()</code></td>
<td style="text-align:center">清楚</td>
</tr>
<tr>
<td style="text-align:center"><code>containsKey(K)</code></td>
<td style="text-align:center">查找键是否存在</td>
</tr>
</tbody>
</table>
<p><strong>遍历方式</strong></p>
<ul>
<li>先通过 <code>keySet</code> 取出所有的 Key 再根据 Key 取出相对应的 Value</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一组：先取出所有的 Key 再根据 Key 取出相对应的 Value</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();  <span class="comment">// 获取所有的Key</span></span><br><span class="line"><span class="comment">// 第一种，使用增强for循环进行遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object obj : set) &#123;  <span class="comment">// 增强for循环</span></span><br><span class="line">    System.out.println(obj + <span class="string">&quot;-&quot;</span> + map.get(obj));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种，使用迭代器进行遍历</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;  <span class="comment">// 使用迭代器</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(next + <span class="string">&quot;-&quot;</span> + map.get(next));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>把所有的 Value 取出</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第二组：把所有的values取出</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">// 第一种：使用迭代器进行遍历</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二中：使用增强for循环</span></span><br><span class="line"><span class="keyword">for</span> (Object obj : values) &#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>entrySet</code> 来获取 K - V</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第三组 ：通过 entrySet 来获取 k-v</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">// 第一种：使用增强for循环进行遍历</span></span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;  <span class="comment">// 转换类型</span></span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：使用iterator迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">    Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) next;</span><br><span class="line">    System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> <code>HashMap</code></h4>
<ul>
<li>与<code>HashSet</code>一样，不保证映射的顺序，因为底层是以hash表的方式来存储的，JDK 8的<code>hashMap</code>底层是数组 + 链表 + 红黑树</li>
<li><code>HashMap</code>没有实现同步，因此是线程不安全的。方法上没有做同步互斥的操作，没有<code>synchronized</code>关键字</li>
</ul>
<p><strong>底层机制</strong></p>
<ul>
<li><code>HashMap</code>的扩容机制和<code>HashSet</code>完全一样</li>
<li><code>HashMap</code>底层维护了Node类型的数组table，默认为<code>null</code></li>
<li>当创建对象时，将加载因子（load factor）初始化为0.75</li>
<li>当添加 key - value 时，通过key的哈希值的到再table表中的索引，然后判断该索引处是否有元素，如果没有元素直接添加，如果该索引处有元素，继续判断该元素的key是否和准备加入的key相等，如果相等，则直接替换value；如果不相等则需要判断是树结构还是链表结构，做出相应的处理。如果添加时发现容量不够，则需要扩容。</li>
<li>第一次添加，则需要扩容table容量为16，临界值（threshold）为12</li>
<li>以后再扩容，指责需要扩容table容量为原来的2倍，临界值为原来的2倍，即24，依此类推。</li>
<li>在Java 8中，如果一条链表的元素个数超过<code>TREEIFY_THRESHOLD</code>（默认是8），并且table的大小 &gt;= <code>MIN_TREEIFY_CAPACITY</code>(默认是64)，就会进行树化（红黑树）</li>
</ul>
<h4 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> <code>HashTable</code></h4>
<ul>
<li>存放的元素是键值对：即 K - V</li>
<li><code>HashTable</code>的键和值都不能为<code>null</code>，否则会抛出<code>NullPointerException</code></li>
<li><code>HashTable</code>使用方法基本上和<code>HashMap</code>一样</li>
<li>是线程安全的。有<code>synchronized</code>修饰</li>
</ul>
<h4 id="properties"><a class="markdownIt-Anchor" href="#properties"></a> <code>Properties</code></h4>
<ol>
<li>继承自<code>HashTable</code>类，并且实现了Map接口，也是使用一种键值对的形式来保存数据</li>
<li>它的使用特点和<code>HashTable</code>类似</li>
<li>还可以用于从<code>XXX.properties</code>文件中，加载数据到<code>Properties</code>类对象，并进行读取和修改</li>
<li>说明：<code>XXX.properties</code>通常为配置文件</li>
</ol>
<h4 id="treemap"><a class="markdownIt-Anchor" href="#treemap"></a> <code>TreeMap</code></h4>
<ul>
<li>当使用无参构造器创建<code>TreeMap</code>时，它默认按 Key 的字典序进行排序。</li>
<li>使用<code>TreeMap</code>提供的一个构造器，可以传入一个比较器（匿名内部类），并指定排序规则。</li>
</ul>
<h2 id="集合选型规则"><a class="markdownIt-Anchor" href="#集合选型规则"></a> 集合选型规则⭐</h2>
<ol>
<li>先判断存储类型，（一组对象[单列]或一组键值对[多列]）</li>
<li>一组对象：<code>Collection</code>接口
<ul>
<li>允许重复：<code>List</code>
<ul>
<li>增删多：<code>LinkedList</code>【底层维护了一个双向链表】</li>
<li>改查多：<code>ArrayList</code>【底层维护了Object类型可变数组】</li>
</ul>
</li>
<li>不允许重复：<code>Set</code>
<ul>
<li>无序：<code>HashSet</code>【底层是<code>HashMap</code>，维护了一个哈希表，即 数组 + 链表 + 红黑树】</li>
<li>排序：<code>TreeSet</code></li>
<li>插入和取出顺序一致：<code>LinkedHashSet</code>【维护 数组 + 双向链表】</li>
</ul>
</li>
</ul>
</li>
<li>一组键值对：<code>Map</code>
<ul>
<li>键无序：<code>HashMap</code>【底层是：哈希表 JDK 7：数组 + 链表；JDK 8：数组 + 链表 + 红黑树】</li>
<li>键排序：<code>TreeMap</code></li>
<li>键插入顺序和取出顺序一致：<code>LinkedHashMap</code></li>
<li>读取文件：<code>Properties</code></li>
</ul>
</li>
</ol>
<h2 id="collections-工具类"><a class="markdownIt-Anchor" href="#collections-工具类"></a> <code>Collections</code> 工具类</h2>
<blockquote>
<p>Collections 工具类是一个操作 Set、List 和 Map 等集合的工具类</p>
<p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作</p>
</blockquote>
<h3 id="排序操作"><a class="markdownIt-Anchor" href="#排序操作"></a> 排序操作</h3>
<p>均为 static 方法</p>
<ul>
<li><code>reverse(List)</code>：反转 List 中元素的顺序</li>
<li><code>shuffle(List)</code>：对 List 集合元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素按升序排序</li>
<li><code>sort(List, Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List, int, int)</code>：将指定 List 集合中的 i 处元素和 j 处元素进行交换</li>
</ul>
<h3 id="查找-替换"><a class="markdownIt-Anchor" href="#查找-替换"></a> 查找、替换</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>max(Collection)</code></td>
<td style="text-align:center">根据元素的自然顺序，返回给定集合中的最大元素</td>
</tr>
<tr>
<td style="text-align:center"><code>max(Collection, Comparator)</code></td>
<td style="text-align:center">根据 Comparator 指定的顺序，返回给定集合中的最大元素</td>
</tr>
<tr>
<td style="text-align:center"><code>min(Collection)</code></td>
<td style="text-align:center">根据元素的自然顺序，返回给定集合中的最小元素</td>
</tr>
<tr>
<td style="text-align:center"><code>min(Collection, Comparator)</code></td>
<td style="text-align:center">根据 Comparator 指定的顺序，返回给定集合中的最小元素</td>
</tr>
<tr>
<td style="text-align:center"><code>frequency(Collection, Object)</code></td>
<td style="text-align:center">返回指定集合中指定元素出现的次数</td>
</tr>
<tr>
<td style="text-align:center"><code>copy(List dest, List src)</code></td>
<td style="text-align:center">将 src 集合中的内容赋值到 dest 中，需要保证 dest 和 src 的大小相等</td>
</tr>
<tr>
<td style="text-align:center"><code>replaceAll(List list, Object oldVal, Object new Val)</code></td>
<td style="text-align:center">将 list 集合中的所有 oldVal 全部替换为 newVal</td>
</tr>
</tbody>
</table>
<h1 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h1>
<blockquote>
<p>泛型又称参数化类型，是 JDK 5.0出现的新特性，解决数据类型的安全性问题</p>
<p>在类声明或实例化时只要制定好需要的具体的类型即可</p>
</blockquote>
<ul>
<li>
<p>基本语法：<code>ArrayList&lt;类名&gt; list = new ArrayList&lt;类名&gt;();</code></p>
</li>
<li>
<p>Java 泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生类型转换异常，代码更加简洁，健壮</p>
</li>
<li>
<p>泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。</p>
</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>编译时，检查添加元素的类型，提高了安全性</li>
<li>减少了类型转换的次数，提高效率</li>
<li>在遍历的时候，可以直接取出对应类的类型，而不是 Object 类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Person&lt;String&gt; person = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;String&gt;(<span class="string">&quot;xzt&quot;</span>);  <span class="comment">// String 类型的Person类</span></span><br><span class="line"></span><br><span class="line">        Person&lt;Integer&gt; person1 = <span class="keyword">new</span> <span class="title class_">Person</span>&lt;Integer&gt;(<span class="number">122</span>);  <span class="comment">// Integer 类型的Person类</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类时添加泛型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;E&gt; &#123;</span><br><span class="line">    E s;  <span class="comment">// E表示 s的数据类型，该数据类型在定义Person对象的时候指定，即在编译期间，就确定E是什么类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(E s)</span> &#123;  <span class="comment">// E也可以是参数类型</span></span><br><span class="line">        <span class="built_in">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">f</span><span class="params">()</span> &#123;  <span class="comment">// 返回类型也可以使用E</span></span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2>
<p><strong>泛型的声明</strong></p>
<p><code>interface 接口名&lt;T&gt;&#123;&#125;</code> 和 <code>class 类名&lt;K, V&gt;&#123;&#125;</code></p>
<p>说明：</p>
<ul>
<li>其中，T，K，V 不代表值，而是表示类型</li>
<li>任意字母都可以，常用T表示，是 Type 的缩写</li>
</ul>
<p><strong>泛型的实例化</strong></p>
<p>要在类名后米娜指定类型参数的值（类型）。如：</p>
<ul>
<li><code>Person&lt;String&gt; person = new Person&lt;String&gt;(&quot;xzt&quot;);</code></li>
<li><code>Iterator&lt;Customer&gt; iterator = cunstomers.iterator();</code></li>
</ul>
<p><strong>注意事项</strong></p>
<ul>
<li>T，K，V只能是引用类型，不能是基本数据类型</li>
<li>在给泛型指定具体类型后，可以传入该类型或者其子类类型</li>
<li>泛型的使用形式
<ul>
<li><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();</code></li>
<li><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code> 推荐写法，编译器会进行类型推断。</li>
</ul>
</li>
<li><code>ArrayList list = new ArrayList();</code>默认泛型是 Object 类</li>
</ul>
<h2 id="自定义泛型"><a class="markdownIt-Anchor" href="#自定义泛型"></a> 自定义泛型</h2>
<h3 id="自定义泛型类"><a class="markdownIt-Anchor" href="#自定义泛型类"></a> 自定义泛型类</h3>
<p><strong>基本语法</strong>：<code>class 类名&lt;T, R ...&gt; &#123; 成员 &#125;</code>，也可以是接口</p>
<p><strong>注意细节</strong></p>
<ul>
<li>普通成员可以使用泛型（属性、方法）</li>
<li>使用泛型的数组，不能初始化。<strong>因为数组在new的时候，不能确定 T 的类型，就无法在内存中开空间</strong></li>
<li>静态方法中不能使用类的泛型。<strong>因为静态方法和类相关，在类加载时，对象还没创建，所以静态方法不能使用泛型</strong></li>
<li>泛型类的类型，是在创建对象时确定的，因为创建对象时，需要指定确定类型</li>
<li>如果在创建对象时，没有指定类型，默认为 Object</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tiger</span>&lt;T, R, M&gt; &#123;</span><br><span class="line">    String name;</span><br><span class="line">    R r;</span><br><span class="line">    T t;</span><br><span class="line">    M m;</span><br><span class="line">    T[] ts;  <span class="comment">// 使用泛型的数组，不允许直接初始化，因为数组在new的时候，不能确定T的类型，就无法在内存中开空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tiger</span><span class="params">(String name, R r, T t, M m)</span> &#123;  <span class="comment">//构造器使用泛型</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法使用泛型，返回类型也可以使用泛型</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">getR</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setR</span><span class="params">(R r)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.r = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setT</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> M <span class="title function_">getM</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setM</span><span class="params">(M m)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.m = m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义泛型接口"><a class="markdownIt-Anchor" href="#自定义泛型接口"></a> 自定义泛型接口</h3>
<p><strong>基本语法</strong>：<code>interface 接口名&lt;T, R, ...&gt; &#123;&#125;</code></p>
<p><strong>注意事项</strong></p>
<ul>
<li>接口中，静态成员也不能使用泛型</li>
<li>泛型接口类型中，在继承接口或者实现接口时确定</li>
<li>没有指定类型，默认为 Object</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IUsb</span>&lt;U, R&gt; &#123;</span><br><span class="line">    <span class="comment">// 普通方法中，可以使用接口泛型</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 在接口中，所有成员都是静态成员</span></span><br><span class="line">    R <span class="title function_">get</span><span class="params">(U u)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(R r)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Run</span><span class="params">(R r1, R r2, U u1, U u2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在jdk 8中，可以在接口中，使用默认方法，也可以使用泛型</span></span><br><span class="line">    <span class="keyword">default</span> R <span class="title function_">method</span><span class="params">(U u)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承泛型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span> <span class="keyword">extends</span> <span class="title class_">IUsb</span>&lt;String, Double&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现泛型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">IA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Double <span class="title function_">get</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Run</span><span class="params">(Double r1, Double r2, String u1, String u2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义泛型方法"><a class="markdownIt-Anchor" href="#自定义泛型方法"></a> 自定义泛型方法</h3>
<p><strong>基本语法</strong>：<code>修饰符 &lt;T, R, ...&gt;返回类型 方法名(参数列表) &#123;&#125;</code></p>
<p><strong>注意事项</strong></p>
<ul>
<li>泛型方法，可以定义在普通类中，也可以定义在泛型类中。</li>
<li>当泛型方法被调用时，类型会确定</li>
<li>若修饰符后面没有泛型<code>&lt;T, R, ..&gt;</code>，则该方法不是泛型方法</li>
</ul>
<h2 id="泛型的继承和通配符"><a class="markdownIt-Anchor" href="#泛型的继承和通配符"></a> 泛型的继承和通配符</h2>
<ul>
<li>泛型不具备继承性。<code>List&lt;Object&gt; list = new ArrayList&lt;String&gt;()</code> 是不正确的</li>
<li><code>&lt;?&gt;</code>：支持任意泛型类型</li>
<li><code>&lt;? extends A&gt;</code>：支持A类及A类的子类，规定了泛型的上限</li>
<li><code>&lt;? super A&gt;</code>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限</li>
</ul>
<h1 id="junit单元测试类"><a class="markdownIt-Anchor" href="#junit单元测试类"></a> Junit单元测试类</h1>
<ul>
<li><code>Junit</code>是一个Java语言的单元测试框架</li>
<li>多数Java的开发环境否已经集成了<code>Junit</code>作为单元测试工具</li>
<li>在需要测试的方法上面加入<code>@Test</code>，则可以直接运行该方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xzt.Junit_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xzt</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Junit_</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span>  <span class="comment">// 使用Junit类测试该方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试m1方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试m2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>1305.两颗二叉搜索树中的所有元素</title>
    <url>/2022/05/01/LeetCode/20220501/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/"> 两颗二叉搜索树中的所有元素 </a></p>
<h2 id="思路-1"><a class="markdownIt-Anchor" href="#思路-1"></a> 思路 1</h2>
<p>先前序遍历两个二叉搜索树，将所有节点的值存放至<code>vector&lt;int&gt;</code>中，然后在进行排序。</p>
<h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路 2</h2>
<p>先进行中序遍历，得到两个二叉搜索树对应的数组，该数组均为有序（从小到大），然后进行归并即可。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解 1</button></li><li class="tab"><button type="button" data-href="#题解-2">题解 2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 二叉树的前序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preTraverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">preTraverse</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preTraverse</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getAllElements</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">preTraverse</span>(root1);</span><br><span class="line">        <span class="built_in">preTraverse</span>(root2);</span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O((n + m) * log(n + m))</em>，其中 <em>n</em> 和 <em>m</em> 分别为两棵二叉搜索树的节点个数。</li>
<li>空间复杂度：<em>O(n + m)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：120 ms, 在所有 C++ 提交中击败了82.38%的用户</p>
<p>内存消耗：83.3 MB, 在所有 C++ 提交中击败了60.43%的用户</p>
<p>通过测试用例：48 / 48</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="题解-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InoTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">InoTraversal</span>(root-&gt;left, nums);</span><br><span class="line">        nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">InoTraversal</span>(root-&gt;right, nums);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getAllElements</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums1, nums2;</span><br><span class="line">        <span class="built_in">InoTraversal</span>(root1, nums1);</span><br><span class="line">        <span class="built_in">InoTraversal</span>(root2, nums2);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.<span class="built_in">size</span>() &amp;&amp; j &lt; nums2.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i] &lt; nums2[j])</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums1.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(nums1[i++]);</span><br><span class="line">        <span class="keyword">while</span>(j &lt; nums2.<span class="built_in">size</span>()) res.<span class="built_in">push_back</span>(nums2[j++]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O((n + m))</em>，其中 <em>n</em> 和 <em>m</em> 分别为两棵二叉搜索树的节点个数。</li>
<li>空间复杂度：<em>O(n + m)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：116 ms, 在所有 C++ 提交中击败了88.62%的用户</p>
<p>内存消耗：85.4 MB, 在所有 C++ 提交中击败了6.23%的用户</p>
<p>通过测试用例：48 / 48</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉搜索树</tag>
        <tag>深度优先搜索</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>908.最小差值</title>
    <url>/2022/04/30/LeetCode/20220430/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/smallest-range-i/"> 最小差值 1 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>先找到数组中的最大值和最小值，然后用二者的差在减去 2 * k，若小于等于 0，则结果为 0，否则，结果为差值。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解 1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestRangeI</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">10000</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; nums[i])  <span class="comment">// 找最小值</span></span><br><span class="line">                min = nums[i];</span><br><span class="line">            <span class="keyword">if</span>(max &lt; nums[i])  <span class="comment">// 找最大值</span></span><br><span class="line">                max = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max - min &lt;= k * <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (max - min - k * <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em></li>
<li>空间复杂度：<em>O(n)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：132 ms, 在所有 C++ 提交中击败了52.57%的用户</p>
<p>内存消耗：83.3 MB, 在所有 C++ 提交中击败了57.45%的用户</p>
<p>通过测试用例：48 / 48</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第291场周赛</title>
    <url>/2022/05/02/LeetCode/291WeeklyCompetition/</url>
    <content><![CDATA[<h2 id="题目-1移除指定数字得到的最大结果"><a class="markdownIt-Anchor" href="#题目-1移除指定数字得到的最大结果"></a> 题目 1：移除指定数字得到的最大结果</h2>
<p><a href="https://leetcode-cn.com/problems/remove-digit-from-number-to-maximize-result/"> 移除指定数字得到的最大结果 </a></p>
<h3 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h3>
<p><code>字符串</code></p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<p>遍历一遍字符串，当遇到指定字符时，使用 <code>erase</code> 函数删除该字符，然后使用 <code>compare()</code>函数进行字符串比较，因为字符串的长度都是相等的，所以就相当于比较的是对应整型的大小。最后保存最大的即可。</p>
<h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDigit</span><span class="params">(string number, <span class="type">char</span> digit)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; number.<span class="built_in">length</span>(); i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(number[i] == digit)&#123;</span><br><span class="line">                string str = number;  <span class="comment">// 用于临时保存原来的string</span></span><br><span class="line">                str.<span class="built_in">erase</span>(i, <span class="number">1</span>); <span class="comment">// 删除该字符，从i开始删除，删除1个字符</span></span><br><span class="line">                <span class="keyword">if</span>(res == <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                    res = str;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(res.<span class="built_in">compare</span>(str) &lt; <span class="number">0</span>)&#123;  <span class="comment">// 比较字符串大小</span></span><br><span class="line">                    res = str;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n ^ 2)</em>，其中 <em>n</em> 为 <em>number</em> 的长度，我们只需要对 <em>number</em> 进行一次遍历，但是<code>erase</code>函数的时间复杂度为<em>O(n)</em>。</li>
<li>空间复杂度：<em>O(n)</em>，即为存储标结果需要使用的空间。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：6.4 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>通过测试用例：112 / 112</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="题目-2必须拿起的最小连续卡牌数"><a class="markdownIt-Anchor" href="#题目-2必须拿起的最小连续卡牌数"></a> 题目 2：必须拿起的最小连续卡牌数</h2>
<p><a href="https://leetcode-cn.com/problems/minimum-consecutive-cards-to-pick-up/"> 必须拿起的最小连续卡牌数 </a></p>
<h3 id="标签-2"><a class="markdownIt-Anchor" href="#标签-2"></a> 标签</h3>
<p><code>队列</code>、<code>哈希表</code></p>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<p>使用队列存储元素，若将要加入的元素已经存在于队列中，则开始出队，知道队列中不存在该元素，然后和<code>res</code>比较大小，若<code>res</code>大于队列元素个数 加 2（因为此时当前元素还没加入，并且和其相同的元素也已经出队了，所以需要加 2）。然后将当前元素入队，继续往后遍历。</p>
<p>判断当前元素是否存在于队列中需要使用<code>unordered_map&lt;int, int&gt;</code>哈希表进行存储，表示 K 在哈希表中的个数为 V 。</p>
<h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumCardPickup</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cards)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que; <span class="comment">// 队列</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hsp;  <span class="comment">// 哈希表</span></span><br><span class="line">        que.<span class="built_in">push</span>(cards[<span class="number">0</span>]);</span><br><span class="line">        hsp[cards[<span class="number">0</span>]] ++;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; cards.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(hsp[cards[i]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(hsp[cards[i]] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> top = que.<span class="built_in">front</span>();</span><br><span class="line">                    hsp[top] --;</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(res == <span class="number">-1</span> || res &gt; (que.<span class="built_in">size</span>() + <span class="number">2</span>)) res = que.<span class="built_in">size</span>() + <span class="number">2</span>;</span><br><span class="line">                hsp[cards[i]] ++;</span><br><span class="line">                que.<span class="built_in">push</span>(cards[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                hsp[cards[i]] ++;</span><br><span class="line">                que.<span class="built_in">push</span>(cards[i++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 为 <em>cards</em> 的长度，我们只需要对 <em>cards</em> 进行一次遍历.</li>
<li>空间复杂度：<em>O(2 * n)</em>，即为队列和哈希表所需要的空间。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：372 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：116.4 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>通过测试用例：78 / 78</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="题目-3含最多-k-个可整除元素的子数组"><a class="markdownIt-Anchor" href="#题目-3含最多-k-个可整除元素的子数组"></a> 题目 3：含最多 K 个可整除元素的子数组 ⭐</h2>
<p><a href="https://leetcode-cn.com/problems/k-divisible-elements-subarrays/"> 含最多 K 个可整除元素的子数组 </a></p>
<h3 id="标签-3"><a class="markdownIt-Anchor" href="#标签-3"></a> 标签</h3>
<p><code>哈希表</code>、<code>字符串</code></p>
<h3 id="思路-3"><a class="markdownIt-Anchor" href="#思路-3"></a> 思路</h3>
<p>对 <code>nums</code> 数组进行双重循环，第一重确定开始的位置*（0 ~ nums.size() - 1）* ，然后依次遍历数组，使用整型变量 <em>count</em> 记录出现能整除 <em>p</em> 的个数，当 <em>count</em> 大于 <em>k</em> 时，就跳出循环。否则将该元素转为字符串加入 <em>str</em> 中，<strong>注意</strong>  需要在每个数后面加个 <code>,</code>，是为了防止出现连续加入 1,9和直接加入19造成的歧义。最后将<em>str</em> 直接加入<code>unordered_map</code> 中进行去重。最后结果为<code>unordered_map</code>的个数。</p>
<p>去重也可以使用<code>map&lt;vector&lt;int&gt;, int&gt;</code></p>
<h3 id="unordered_map-和-map-的区别"><a class="markdownIt-Anchor" href="#unordered_map-和-map-的区别"></a> unordered_map 和 map 的区别</h3>
<ul>
<li><code>map</code>，<code>set</code>底层是红黑树，有序的，存储的数据类型可以自定义，空间时间复杂度比较高</li>
<li><code>unordered_map</code>，<code>unordered_set</code>底层实现的时哈希表，无序存储，查询、插入时间空间复杂度比较低（相较于上面两个），但是缺点就是数据类型只能是基本数据类型，比如：<code>int</code>，<code>char</code>，<code>float</code>，<code>string</code>等。</li>
</ul>
<h3 id="题解-3"><a class="markdownIt-Anchor" href="#题解-3"></a> 题解</h3>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">使用unordered_map</button></li><li class="tab"><button type="button" data-href="#题解-2">使用map</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDistinct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;string, <span class="type">int</span>&gt; hsp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 记录能被p整除的个数</span></span><br><span class="line">            string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] % p == <span class="number">0</span>) count ++;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; k) <span class="keyword">break</span>;</span><br><span class="line">                str += <span class="built_in">to_string</span>(nums[j]); <span class="comment">// 将整型转为string类型，并添加到str中</span></span><br><span class="line">                str += <span class="string">&quot;,&quot;</span>; <span class="comment">// 防止出现 1 9  和 19 一样的情况</span></span><br><span class="line">                hsp[str] ++;  <span class="comment">// 使用unordered_map进行去重</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; hsp.size() &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hsp.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n ^ 2)</em>，其中 <em>n</em> 为 <em>nums</em> 的长度</li>
<li>空间复杂度：<em>O((1 + n) * n / 2)</em>，即为 <em>unordered_map</em> 做多需要使用的空间。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：492 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：204.6 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>通过测试用例：129 / 129</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="题解-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countDistinct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">        map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 记录能被p整除的个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; nums.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] % p == <span class="number">0</span>) count ++;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; k) <span class="keyword">break</span>;</span><br><span class="line">                res[<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">begin</span>() + i, nums.<span class="built_in">begin</span>() + j + <span class="number">1</span>)] = <span class="number">1</span>; <span class="comment">// 添加入map</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; hsp.size() &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n ^ 2)</em>，其中 <em>n</em> 为 <em>nums</em> 的长度</li>
<li>空间复杂度：<em>O((1 + n) * n / 2)</em>，即为 <em>map</em> 做多需要使用的空间。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：1220 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：261 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>通过测试用例：129 / 129</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="题目-4字符串的总引力"><a class="markdownIt-Anchor" href="#题目-4字符串的总引力"></a> 题目 4：字符串的总引力 ⭐⭐</h2>
<p><a href="https://leetcode-cn.com/problems/total-appeal-of-a-string/"> 字符串的总引力 </a></p>
<h3 id="标签-4"><a class="markdownIt-Anchor" href="#标签-4"></a> 标签</h3>
<p><code>字符串</code>、<code>哈希表</code>、<code>动态规划</code></p>
<h3 id="思路-4"><a class="markdownIt-Anchor" href="#思路-4"></a> 思路</h3>
<p>分类讨论：</p>
<ul>
<li>如果 <em>s[i]</em> 之前没有遇到过，那么致谢子串的引力值都会增加 1，这些子串的引力值之和会增加 i，再加上1，即 <em>s[i]</em> 单独组成的子串的引力值。</li>
<li>如果 <em>s[i]</em> 之前遇到过，设其上次出现的下标为 <em>j</em>，那么向子串 <code>s[0...i - 1], s[1...i - 1], s[2...i - 1], ..., s[j...i - 1]</code> 的末尾添加<code>s[i]</code>后，这些子串的引力值是不会变化的，因为 <code>s[i]</code> 已经在 <code>s[j]</code> 出现过了；而子串<code>s[j + 1 .. i - 1], s[j + 2 .. i - 1], .. ,s[i - 1 .. i - 1]</code>由于不包含 <code>s[i]</code>,这些子串的引力值都会增加 1，因此有 <code>i - j - 1</code>个子串的引力值会增加 1，这些子串的引力值之和会增加 <code>i - j -1</code>，在加上 1，即 <code>s[i]</code> 单独组成的子串的引力值。</li>
</ul>
<h3 id="题解-4"><a class="markdownIt-Anchor" href="#题解-4"></a> 题解</h3>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">appealSum</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">26</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> a = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            sum += i - pos[a];</span><br><span class="line">            res += sum;</span><br><span class="line">            pos[a] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 为 <em>s</em> 的长度。</li>
<li>空间复杂度：<em>O(∣Σ∣)</em>，其中 <em>∣Σ∣</em> 为字符集合的大小，本题中字符均为小写字母，所以 <em>∣Σ∣=26</em>。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：20 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：10.4 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>通过测试用例：76 / 76</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>591.标签验证器</title>
    <url>/2022/05/02/LeetCode/20220502-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/tag-validator/"> 标签验证器 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>如果当前字符为 <strong>&lt;</strong>，需要考虑下面四种情况：</p>
<ul>
<li>如果下一个字符为 <strong>/</strong>，那么说明我们遇到了一个结束标签。我们需要定位下一个 <strong>&gt;</strong> 的位置 <strong>j</strong>，此时 <code>code[i+2..j−1]</code> 就是该结束标签的名称。我们需要判断该名称与当前栈顶的名称是否匹配，如果匹配，说明名称的标签已经闭合，我们需要将当前栈顶的名称弹出。同时根据规则 <strong>1</strong>，我们需要保证整个 <strong>code</strong> 被闭合标签包围，因此如果栈中已经没有标签，但是 <strong>j</strong> 并不是 <strong>code</strong> 的末尾，那么说明后续还会有字符，它们不被闭合标签包围。</li>
<li>如果下一个字符为 <strong>!</strong>，那么说明我们遇到了一个 <strong>cdata</strong>，我们需要继续往后读 77 个字符，判断其是否为 \texttt{[CDATA[}[CDATA[。在这之后，我们定位下一个 <strong>]]&gt;</strong> 的位置 <strong>j</strong>，此时 <code>code[i+9..j−1]</code> 就是 <strong>cdata</strong> 中的内容，它不需要被解析，所以我们也不必进行任何验证。需要注意的是，根据规则 <strong>1</strong>，栈中需要存在至少一个开放的标签。</li>
<li>如果下一个字符为大写字母，那么说明我们遇到了一个开始标签。我们需要定位下一个 <strong>&gt;</strong> 的位置 <strong>j</strong>，此时 <code>code[i+2..j−1]</code> 就是该开始标签的名称。我们需要判断该名称是否恰好由 1 至 9 个大写字母组成，如果是，说明该标签合法，我们需要将该名称放入栈顶。</li>
<li>除此之外，如果不存在下一个字符，或者下一个字符不属于上述三种情况，那么 <strong>code</strong> 是不合法的。</li>
</ul>
<p>如果当前的字符为其它字符，那么根据规则 1，栈中需要存在至少一个开放的标签。</p>
<p>在遍历完成后，我们还需要保证此时栈中没有任何（还没有结束的）标签。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string code)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; stk;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, n = code.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(code[i] == <span class="string">&#x27;&lt;&#x27;</span>)&#123;  <span class="comment">// 当前字符为 &lt;</span></span><br><span class="line">                <span class="keyword">if</span>(i == n - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(code[i + <span class="number">1</span>] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; code[i + <span class="number">1</span>] &lt;= <span class="string">&#x27;Z&#x27;</span>)&#123;  <span class="comment">// 下一个字符是大写字母</span></span><br><span class="line">                    <span class="type">int</span> j = code.<span class="built_in">find</span>(<span class="string">&#x27;&gt;&#x27;</span>, i);  <span class="comment">// 从i开始找，找到第一个 &gt;，并返回其下标</span></span><br><span class="line">                    <span class="keyword">if</span>(j == string::npos) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 不存在 &gt;</span></span><br><span class="line">                    string str = code.<span class="built_in">substr</span>(i + <span class="number">1</span>, j - i - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(str.<span class="built_in">length</span>() &lt; <span class="number">1</span> || str.<span class="built_in">length</span>() &gt; <span class="number">9</span>) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 判断长度是否合法</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; str.<span class="built_in">size</span>(); k ++)&#123;  <span class="comment">// 判断是否全为大写字母</span></span><br><span class="line">                        <span class="keyword">if</span>(str[k] &lt; <span class="string">&#x27;A&#x27;</span> || str[k] &gt; <span class="string">&#x27;Z&#x27;</span>)</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    stk.<span class="built_in">push</span>(str);</span><br><span class="line">                    i = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(code[i + <span class="number">1</span>] == <span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> j = code.<span class="built_in">find</span>(<span class="string">&#x27;&gt;&#x27;</span>, i);</span><br><span class="line">                    <span class="keyword">if</span>(j == string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    string str = code.<span class="built_in">substr</span>(i + <span class="number">2</span>, j - i - <span class="number">2</span>);</span><br><span class="line">                    <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != str) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 如果栈顶元素为空 或者 和栈顶元素不匹配</span></span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                    i = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(stk.<span class="built_in">empty</span>() &amp;&amp; i != n) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果栈为空，但是还没遍历到字符串末尾</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(code[i + <span class="number">1</span>] == <span class="string">&#x27;!&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    string str = code.<span class="built_in">substr</span>(i + <span class="number">2</span>, <span class="number">7</span>);  <span class="comment">// 往后读7个字符</span></span><br><span class="line">                    <span class="keyword">if</span>(str != <span class="string">&quot;[CDATA[&quot;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">int</span> j = code.<span class="built_in">find</span>(<span class="string">&quot;]]&gt;&quot;</span>, i);</span><br><span class="line">                    <span class="keyword">if</span>(j == string::npos) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    i = j + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 当前字符为其他字符，但是栈为空了，</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>(); <span class="comment">// 可能还存在栈最后还不空的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 为 <em>code</em> 的长度，我们只需要对 <em>code</em> 进行一次遍历。</li>
<li>空间复杂度：<em>O(n)</em>，即为栈存储标签名称需要使用的空间。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：6.3 MB, 在所有 C++ 提交中击败了96.00%的用户</p>
<p>通过测试用例：260 / 260</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>34.在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2022/05/02/LeetCode/20220502-02/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/"> 在排序数组中查找元素的第一个和最后一个位置 </a></p>
<h2 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h2>
<p><code>二分查找模板</code></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>使用二分算法的两个模板分别可以求出元素出现的第一个位置和最后一个位置。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解 1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;  <span class="comment">//第一个模板</span></span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[l] != target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(l);</span><br><span class="line">            l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;  <span class="comment">// 第二个模板</span></span><br><span class="line">                <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(log n)</em>，其中 <em>n</em> 为数组的长度。二分查找的时间复杂度是<em>O(log n)</em>，一共执行两次，所以总的时间复杂度是<em>O(log n)</em></li>
<li>空间复杂度：<em>O(1)</em>，只需要常数空间存放若干变量</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：4 ms, 在所有 C++ 提交中击败了93.27%的用户</p>
<p>内存消耗：13.3 MB, 在所有 C++ 提交中击败了34.09%的用户</p>
<p>通过测试用例：88 / 88</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>937.重新排列日志文件</title>
    <url>/2022/05/03/LeetCode/20220503-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/reorder-data-in-log-files/"> 重新排列日志文件 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ul>
<li>思路1：先遍历一边数组，分别将字母日志和数字日志存入<code>vector&lt;string&gt;</code>中，然后将字母日志使用自定义排序进行排序，再将数字日志加入排序后的字母日志即可。</li>
<li>思路2：直接使用 <code>stable_sort</code>进行自定义排序.</li>
</ul>
<h2 id="stable_sort-和-sort-的区别"><a class="markdownIt-Anchor" href="#stable_sort-和-sort-的区别"></a> <code>stable_sort</code> 和 <code>sort</code> 的区别</h2>
<ul>
<li><code>sort</code>是快速排序实现，因此是不稳定的；<code>stable_sort</code>是归并排序实现，因此是稳定的。（这里的稳定是指排序后相等元素的相对位置保持不变）</li>
<li>对于相等的元素<code>sort</code>可能改变顺序，<code>stable_sort</code>保证排序后相等的元素次序不变。</li>
<li>如果提供了比较函数，<code>sort</code>不要求比较函数的参数被限定为<code>const</code>，而<code>stable_sort</code>则要求参数被限定为<code>const</code>，否则编译不能通过。</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li><li class="tab"><button type="button" data-href="#题解-2">题解2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">reorderLogFiles</span><span class="params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; dig;  <span class="comment">// 保存数字日志</span></span><br><span class="line">        vector&lt;string&gt; let;  <span class="comment">// 保存字母日志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; logs.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            string str = logs[i];</span><br><span class="line">            <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; str.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[j] == <span class="string">&#x27; &#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[j + <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[j + <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123; <span class="comment">//是数字日志</span></span><br><span class="line">                dig.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123; <span class="comment">// 是字母日志</span></span><br><span class="line">                let.<span class="built_in">push_back</span>(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(let.<span class="built_in">begin</span>(), let.<span class="built_in">end</span>(), [](string &amp;a, string &amp;b) &#123;  <span class="comment">//自定义sort排序</span></span><br><span class="line">            <span class="type">int</span> x = a.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="type">int</span> y = b.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            string stra = a.<span class="built_in">substr</span>(x + <span class="number">1</span>);</span><br><span class="line">            string strb = b.<span class="built_in">substr</span>(y + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(stra != strb) <span class="keyword">return</span> stra &lt; strb;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a &lt; b;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dig.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            let.<span class="built_in">push_back</span>(dig[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> let;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * log n)</em>，其中 <em>n</em> 为 <em>logs</em> 的字符数，是平均情况下内置排序的时间复杂度。</li>
<li>空间复杂度：<em>O(n)</em>，额外存放日志的数组</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：16 ms, 在所有 C++ 提交中击败了23.57%的用户</p>
<p>内存消耗：12.4 MB, 在所有 C++ 提交中击败了31.52%的用户</p>
<p>通过测试用例：65 / 65</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="题解-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">reorderLogFiles</span><span class="params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stable_sort</span>(logs.<span class="built_in">begin</span>(), logs.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b)&#123;  <span class="comment">// stable_sort</span></span><br><span class="line">            <span class="type">int</span> x = a.<span class="built_in">find_first_of</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 找到a的第一个空格</span></span><br><span class="line">            <span class="type">int</span> y = b.<span class="built_in">find_first_of</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 找到b的第一个空格</span></span><br><span class="line">            <span class="type">bool</span> isDigital_a = <span class="built_in">isdigit</span>(a[x + <span class="number">1</span>]);</span><br><span class="line">            <span class="type">bool</span> isDigital_b = <span class="built_in">isdigit</span>(b[y + <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(isDigital_a &amp;&amp; isDigital_b)&#123;  <span class="comment">// 两个都是数字日志</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!isDigital_a &amp;&amp; !isDigital_b) &#123; <span class="comment">// 两个都是字母日志</span></span><br><span class="line">                string stra = a.<span class="built_in">substr</span>(x + <span class="number">1</span>);</span><br><span class="line">                string strb = b.<span class="built_in">substr</span>(y + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(stra != strb) <span class="keyword">return</span> stra &lt; strb;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">return</span> a &lt; b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> isDigital_a ? <span class="literal">false</span> : <span class="literal">true</span>;  <span class="comment">// 判断a是否是数字日志，若a是数字日志，则返回false</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> logs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * log n)</em>，其中 <em>n</em> 为 <em>logs</em> 的字符数，是平均情况下内置排序的时间复杂度。</li>
<li>空间复杂度：<em>O(n)</em>，额外存放日志的数组</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：12 ms, 在所有 C++ 提交中击败了59.80%的用户</p>
<p>内存消耗：10.9 MB, 在所有 C++ 提交中击败了83.87%的用户</p>
<p>通过测试用例：65 / 65</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>排序</tag>
        <tag>字符串</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>1090.受标签影响的最大值</title>
    <url>/2022/05/03/LeetCode/20220503-02/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/largest-values-from-labels/"> 受标签影响的最大值 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>使用<code>vector&lt;pair&lt;int, int&gt;&gt;</code> 将 <em>values</em> 和 <em>labels</em> 对应起来，然后按照 <em>values</em> 从大到小进行排序，每次在满足对应的标签没有达到上限时（使用<code>unordered_map</code>进行计数），优先取最大的即可。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hsp;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestValsFromLabels</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values, vector&lt;<span class="type">int</span>&gt;&amp; labels, <span class="type">int</span> numWanted, <span class="type">int</span> useLimit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; values.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(values[i], labels[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;b)&#123;  <span class="comment">// 将arr数组从大到小进行排序</span></span><br><span class="line">            <span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() &amp;&amp; numWanted; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hsp[arr[i].second] &lt; useLimit)&#123;</span><br><span class="line">                hsp[arr[i].second] ++;</span><br><span class="line">                res += arr[i].first;</span><br><span class="line">                numWanted--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * log n)</em>，其中 <em>n</em> 为 <em>values</em> 的大小，主要是 <code>sort()</code>函数的时间发复杂度</li>
<li>空间复杂度：<em>O(n)</em>，数组和哈希表对应的空间</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：24 ms, 在所有 C++ 提交中击败了80.30%的用户</p>
<p>内存消耗：19.8 MB, 在所有 C++ 提交中击败了65.15%的用户</p>
<p>通过测试用例：81 / 81</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>排序</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>78.子集</title>
    <url>/2022/05/03/LeetCode/20220503-03/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/subsets/"> 子集 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>先确定需要的子数组的大小，（从 0 到 <code>nums.size()</code> 依次遍历），然后递归进行选择，每次递归都从上一个元素的下一位置开始，直到临时数组的大小等于当前确定的所需子数组的大小，将其加入结果数组。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">    <span class="comment">// x 当前需要子集的大小， npc 应该开始位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> x, <span class="type">int</span> npc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == arr.<span class="built_in">size</span>())&#123; <span class="comment">// 当前子集的大小满足目前所需的大小</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = npc; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;  <span class="comment">// 从npc 开始遍历</span></span><br><span class="line">            arr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, x, i + <span class="number">1</span>);</span><br><span class="line">            arr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>(); i++)&#123;  <span class="comment">// 遍历，i代表需要子集的大小，</span></span><br><span class="line">            <span class="built_in">dfs</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * 2 ^ n)</em>，一共 <em>2 ^ n</em> 个状态，每种状态需要 O*(<em>n</em>) 的时间来构造子集。</li>
<li>空间复杂度：<em>O</em>(<em>n</em>)。临时数组 <em>arr</em> 的空间代价是 O*(<em>n</em>)，递归时栈空间的代价为 <em>O</em>(<em>n</em>)。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：4 ms, 在所有 C++ 提交中击败了43.18%的用户</p>
<p>内存消耗：7.6 MB, 在所有 C++ 提交中击败了13.53%的用户</p>
<p>通过测试用例：10 / 10</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="延伸题目"><a class="markdownIt-Anchor" href="#延伸题目"></a> 延伸题目</h2>
<p><a href="https://leetcode-cn.com/problems/subsets-ii/"> 子集 II </a></p>
<h2 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h2>
<ul>
<li>思路1：在上面的基础上，当满足条件时使用<code>map</code> 进行去重，若重复则不加入，反之则加入。（需要先排序）</li>
<li>思路2：递归法实现子树枚举，在递归时，若发现没有选择上一个数，并且当前数字与上一个数字相同，则可以跳过当前生成的子集。</li>
</ul>
<h2 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">使用hash表</button></li><li class="tab"><button type="button" data-href="#题解-2">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; hsp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> x, <span class="type">int</span> npc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.<span class="built_in">size</span>() == x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hsp[arr] == <span class="number">1</span>) <span class="keyword">return</span>;  <span class="comment">//使用map进行判断是否有重复的</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">            hsp[arr] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = npc; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums, x, i + <span class="number">1</span>);</span><br><span class="line">            arr.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * 2 ^ n)</em>，一共 <em>2 ^ n</em> 个状态，每种状态需要 O*(<em>n</em>) 的时间来构造子集。</li>
<li>空间复杂度：<em>O</em>(<em>n</em>)。临时数组 <em>arr</em> 的空间代价是 O*(<em>n</em>)，递归时栈空间的代价为 <em>O</em>(<em>n</em>)。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：12 ms, 在所有 C++ 提交中击败了5.73%的用户</p>
<p>内存消耗：9.5 MB, 在所有 C++ 提交中击败了13.58%的用户</p>
<p>通过测试用例：20 / 20</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="题解-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> x, <span class="type">bool</span> pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, x + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(!pre &amp;&amp; x &gt; <span class="number">0</span> &amp;&amp; nums[x] == nums[x - <span class="number">1</span>]) <span class="comment">// 上一个数和当前数相等，并且上一个数没有被加入</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(nums[x]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, x + <span class="number">1</span>, <span class="literal">true</span>);</span><br><span class="line">        arr.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * 2 ^ n)</em>，其中 <em>n</em> 是数组 <em>nums</em> 的长度。排序的时间复杂度为 *O(n * log n) <em>。最坏情况下 <em>nums</em> 中无重复元素，需要枚举其所有 <em>2 ^ n</em> 个子集，每个子集加入答案时需要拷贝一份，耗时 <em>O(n)</em> ，一共需要 <em>O(n * 2 ^ n) + O(n) = O(n * 2 ^ n)</em> 的时间来构造子集。由于在渐进意义上 <em>O(n * log n) * 小于</em>O(n * 2 ^ n)</em> ，故总的时间复杂度为 <em>O(n * 2 ^ n)</em><br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li>
<li>空间复杂度：<em>O</em>(<em>n</em>)。临时数组 <em>arr</em> 的空间代价是 O*(<em>n</em>)，递归时栈空间的代价为 <em>O</em>(<em>n</em>)。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：4 ms, 在所有 C++ 提交中击败了54.66%的用户</p>
<p>内存消耗：15.6 MB, 在所有 C++ 提交中击败了5.03%的用户</p>
<p>通过测试用例：20 / 20</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>1823.找出游戏的获胜者</title>
    <url>/2022/05/04/LeetCode/20220504-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/"> 找出游戏的获胜者 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>使用队列将所有数字存储起来，然后进行循环遍历直到队列中只剩一个元素，每次循环先将 k 减一，将队头元素使用临时变量保存起来，然后出队，dang k 不等于0时，将刚出队的元素再次入队，若 k 等于0，则需要更新 k 。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTheWinner</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = k;</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;  <span class="comment">// 循环遍历，直到队列中只剩一人</span></span><br><span class="line">            x --;</span><br><span class="line">            <span class="type">int</span> top = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(x != <span class="number">0</span>)&#123;  <span class="comment">// 当还没到第k个，则再次入栈</span></span><br><span class="line">                que.<span class="built_in">push</span>(top);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;  <span class="comment">// 到第k个，则需要更新x，再次计数</span></span><br><span class="line">                x = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * k)</em>，其中 n 是做游戏的小伙伴数量，<em>k</em> 是每一轮离开圈子的小伙伴的计数。初始时需要将 <em>n</em> 个元素加入队列，每一轮需要将 <em>k</em> 个元素从队列中取出，将 <em>k−1</em> 个元素加入队列，一共有 <em>n−1</em> 轮，因此时间复杂度是 <em>O(n * k)</em>。</li>
<li>空间复杂度：<em>O(n)</em>，队列最多有n个元素。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：72 ms, 在所有 C++ 提交中击败了11.70%的用户</p>
<p>内存消耗：23.8 MB, 在所有 C++ 提交中击败了15.31%的用户</p>
<p>通过测试用例：95 / 95</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>队列</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>47.全排列 II</title>
    <url>/2022/05/04/LeetCode/20220504-02/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/"> 全排列 II </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>对数组进行递归，若当前元素和上一次递归选择的元素相同，则直接跳过（相当于剪枝），若当前元素不等于上一次元素且没有被选择过，则可以选择，加入数组，直到临时数组的大小等于 <code>nums</code> 数组的大小，则将该临时数据加入至结果数组中。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; used;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(arr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">-11</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x == nums[i]) <span class="keyword">continue</span>;  <span class="comment">// 当前位置刚选过的x和当前值相等。则直接跳过</span></span><br><span class="line">            <span class="keyword">if</span>(!used[i])&#123;  <span class="comment">// 当前值没有被选择</span></span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line">                arr.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(nums, arr);</span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                x = arr[arr.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">                arr.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) used.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, arr);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * n!)</em></li>
<li>空间复杂度：<em>O( n)</em>，结果数组中最多有 n 个元素的数组</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：4 ms, 在所有 C++ 提交中击败了91.98%的用户</p>
<p>内存消耗：8.7 MB, 在所有 C++ 提交中击败了56.14%的用户</p>
<p>通过测试用例：33 / 33</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>递归</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>713.乘积小于k的子数组</title>
    <url>/2022/05/05/LeetCode/20220505-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/"> 乘积小于 K 的子数组 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ul>
<li>使用 <code>queue</code> 队列实现 <code>滑动窗口</code> ，当前元素入队后，若队列中总的乘积小于 k，则继续遍历下一个元素，若队列中总的乘积大于等于 k，则依次出队，直到队列中的总元素乘积小于 k，每个遍历后需要将队列中的总元素个数加至结果变量中。</li>
<li>使用两个指针代表 <code>滑动窗口</code> 的两个边界。</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li><li class="tab"><button type="button" data-href="#题解-2">题解2</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            sum *= nums[i];</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; sum &gt;= k)&#123;</span><br><span class="line">                <span class="type">int</span> top = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                sum /= top;</span><br><span class="line">            &#125;</span><br><span class="line">            res += que.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是数组 <em>nums</em> 的大小</li>
<li>空间复杂度：<em>O(n)</em>，队列最多有 <em>n</em> 个元素</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：68 ms, 在所有 C++ 提交中击败了53.23%的用户</p>
<p>内存消耗：63 MB, 在所有 C++ 提交中击败了5.26%的用户</p>
<p>通过测试用例：97 / 97</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="题解-2"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            sum *= nums[j];</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; sum &gt;= k)&#123;</span><br><span class="line">                sum /= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += j - i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是数组 <em>nums</em> 的大小</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：52 ms, 在所有 C++ 提交中击败了96.72%的用户</p>
<p>内存消耗：59.8 MB, 在所有 C++ 提交中击败了65.17%的用户</p>
<p>通过测试用例：97 / 97</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>209.长度最小的子数组</title>
    <url>/2022/05/05/LeetCode/20220505-02/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/"> 长度最小的子数组 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<ul>
<li>使用双指针记录滑动窗口的左边界和右边界，当满足条件后，进行判断并记录结果。</li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = INT_MAX;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(i &lt;= j &amp;&amp; sum &gt;= target)&#123;</span><br><span class="line">                res = <span class="built_in">min</span>(res, j - i + <span class="number">1</span>);  </span><br><span class="line">                sum -= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">0</span> : res;  <span class="comment">// 若是最后还没有找到区间，则为 0 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是数组 <em>nums</em> 的大小</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：8 ms, 在所有 C++ 提交中击败了61.48%的用户</p>
<p>内存消耗：10.2 MB, 在所有 C++ 提交中击败了71.05%的用户</p>
<p>通过测试用例：19 / 19</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>933.最近请求的次数</title>
    <url>/2022/05/06/LeetCode/20220506-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<h4 id="最近的请求次数"><a class="markdownIt-Anchor" href="#最近的请求次数"></a> <a href="https://leetcode-cn.com/problems/number-of-recent-calls/"> 最近的请求次数 </a></h4>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>使用队列，每次将新的 t 加入队列，然后循环判断对头元素是否大于 t - 3000，若小于则出队，否则结束循环，最后返回队列中的元素个数即可。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="built_in">RecentCounter</span>() &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) que.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">ping</span><span class="params">(<span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        que.<span class="built_in">push</span>(t);</span><br><span class="line">        <span class="keyword">while</span>(que.<span class="built_in">front</span>() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your RecentCounter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * RecentCounter* obj = new RecentCounter();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;ping(t);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是调用 ping 的次数</li>
<li>空间复杂度：<em>O(n)</em>，队列中元素的个数</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：144 ms, 在所有 C++ 提交中击败了32.54%的用户</p>
<p>内存消耗：56.1 MB, 在所有 C++ 提交中击败了24.97%的用户</p>
<p>通过测试用例：68 / 68</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>队列</tag>
        <tag>设计</tag>
        <tag>数据流</tag>
      </tags>
  </entry>
  <entry>
    <title>942.增减字符串匹配</title>
    <url>/2022/05/09/LeetCode/20220509-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode.cn/problems/di-string-match/"> 增减字符串匹配 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>定义两个变量，<code>l</code> 表示最小值0，<code>h</code>表示最大值 <code>s.size()</code>,然后遍历当前元素，若当前元素是 <code>I</code>，则当前位置需要赋值 <code>l</code>并更新<code>l</code>的值，反之，则赋值<code>h</code>的值，并更新<code>h</code>的值。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diStringMatch</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, h = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;I&#x27;</span>)  <span class="comment">// 当前字符是 I 时，添加此时最小的</span></span><br><span class="line">                res[i] = l ++;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 当前字符是 D 时，添加此时最大的</span></span><br><span class="line">                res[i] = h --;</span><br><span class="line">        &#125;</span><br><span class="line">        res[n] = l; <span class="comment">// 添加最后一个数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是字符串 s 的长度</li>
<li>空间复杂度：<em>O(1)</em>，数组长度 为 <em>n + 1</em>，但返回值不计入空间复杂度</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：4 ms, 在所有 C++ 提交中击败了88.53%的用户</p>
<p>内存消耗：8.4 MB, 在所有 C++ 提交中击败了73.80%的用户</p>
<p>通过测试用例：95 / 95</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
        <tag>数组</tag>
        <tag>贪心</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 第292场周赛</title>
    <url>/2022/05/09/LeetCode/292WeeklyCompetition/</url>
    <content><![CDATA[<h2 id="题目1字符串中最大的-3-位相同数字"><a class="markdownIt-Anchor" href="#题目1字符串中最大的-3-位相同数字"></a> 题目1：字符串中最大的 3 位相同数字</h2>
<p><a href="https://leetcode.cn/problems/largest-3-same-digit-number-in-string/"> 字符串中最大的 3 位相同数字 </a></p>
<h3 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h3>
<p><code>字符串</code></p>
<h3 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h3>
<p>遍历一遍数组，每次从第 i 个位置截取长度为 3 字符串，然后判断字符串是否符合要求，若符合，则更新结果。</p>
<h3 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h3>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestGoodInteger</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>() - <span class="number">2</span>; i ++)&#123;</span><br><span class="line">            string str = num.<span class="built_in">substr</span>(i, <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>] == str[<span class="number">1</span>] &amp;&amp; str[<span class="number">1</span>] == str[<span class="number">2</span>] &amp;&amp; res &lt; str)&#123;</span><br><span class="line">                res = str;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 为 字符串 <em>num</em> 的长度</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：6.4 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>通过测试用例：140 / 140</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
<h2 id="题目2统计值等于子树平均值的节点数"><a class="markdownIt-Anchor" href="#题目2统计值等于子树平均值的节点数"></a> 题目2：统计值等于子树平均值的节点数</h2>
<p><a href="https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/"> 统计值等于子树平均值的节点数 </a></p>
<h3 id="标签-2"><a class="markdownIt-Anchor" href="#标签-2"></a> 标签</h3>
<p><code>二叉树</code>、<code>后序遍历</code>、<code>pair</code></p>
<h3 id="思路-2"><a class="markdownIt-Anchor" href="#思路-2"></a> 思路</h3>
<ol>
<li>递归函数与返回值
<ul>
<li>用pair&lt;int,int&gt;作为返回值记录以当前节点为根的子树的总值与节点个数</li>
<li><code>pair&lt;int,int&gt; getAvgVal(TreeNode* root)&#123;&#125;</code></li>
</ul>
</li>
<li>递归函数出口
<ul>
<li>如果遇到空节点 返回{0,0}</li>
<li><code>if(root==nullptr) return &#123;0,0&#125;;</code></li>
</ul>
</li>
<li>单层递归逻辑
<ul>
<li>用l_pair接住遍历过程中左子树的 pair&lt;&gt;;</li>
<li>用r_pair接住遍历过程中右子树的 pair&lt;&gt;;</li>
<li>计算当前节点的 pair&lt;&gt;;</li>
<li>判断当前节点是否符合条件，++ans;</li>
<li>返回当前节点的 pair&lt;&gt;;</li>
</ul>
</li>
</ol>
<h3 id="题解-2"><a class="markdownIt-Anchor" href="#题解-2"></a> 题解</h3>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 总数，个数</span></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">getAvgVal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pair_l = <span class="built_in">getAvgVal</span>(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pair_r = <span class="built_in">getAvgVal</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> sum = pair_l.first + pair_r.first + root-&gt;val;</span><br><span class="line">        <span class="type">int</span> count = pair_l.second + pair_r.second + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; cur = &#123;sum, count&#125;;</span><br><span class="line">        <span class="keyword">if</span>(sum / count == root-&gt;val) res++;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">averageOfSubtree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; per = <span class="built_in">getAvgVal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 为 二叉树中的节点个数</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：6.4 MB, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>通过测试用例：140 / 140</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>周赛</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>442.数组中的重复数据</title>
    <url>/2022/05/10/LeetCode/20220510-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array/"> 数组中重复的数据 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>使用 <code>unordered_map</code> 保存每个整数出现的次数，最后遍历一遍哈希表，将整数出现次数为 2 的整数存入结果数组中。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hsp;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">            hsp[nums[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = hsp.<span class="built_in">begin</span>(); it != hsp.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(it-&gt;second == <span class="number">2</span>)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(it-&gt;first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是数组 <em>nums</em> 的长度</li>
<li>空间复杂度：<em>O(n)</em>，定义的哈希表的大小</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：68 ms, 在所有 C++ 提交中击败了19.03%的用户</p>
<p>内存消耗：43.5 MB, 在所有 C++ 提交中击败了9.79%的用户</p>
<p>通过测试用例：28 / 28</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>449.序列化和反序列化二叉搜索树</title>
    <url>/2022/05/11/LeetCode/20220511-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/"> 序列化和反序列化二叉搜索树</a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p><strong>后序遍历</strong>：二叉搜索树可根据后序遍历的结果将其恢复。</p>
<p>序列化：只需要对二叉搜索树进行后序遍历，再将数组编码成字符串即可。</p>
<p>反序列化时，需要先将字符串解码成后序遍历的数组。在将后序遍历的数组恢复成二叉搜索树时，不需要先排序得到中序遍历的数组再根据中序和后序遍历的数组来恢复二叉树，而可以根据有序性直接由后序遍历的数组恢复二叉搜索树。后序遍历得到的数组中，根结点的值位于数组末尾，左子树的节点均小于根节点的值，右子树的节点均大于根节点的值，可以根据这些性质设计递归函数恢复二叉搜索树。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">postTraversal</span>(root, arr);</span><br><span class="line">        <span class="keyword">if</span>(arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            res += <span class="built_in">to_string</span>(arr[i]) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">substr</span>(<span class="number">0</span>, res.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postTraversal</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">postTraversal</span>(root-&gt;left, arr);</span><br><span class="line">        <span class="built_in">postTraversal</span>(root-&gt;right, arr);</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        TreeNode* root;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        <span class="built_in">transArr</span>(data, arr);</span><br><span class="line">        <span class="keyword">if</span>(arr.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// int n = arr.size();</span></span><br><span class="line">        <span class="comment">// root-&gt;val = arr[n - 1];</span></span><br><span class="line">        root = <span class="built_in">dfs</span>(arr);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transArr</span><span class="params">(string data, vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span>&#123;  <span class="comment">// 将string 拆分为整数数组</span></span><br><span class="line">        <span class="type">int</span> npc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == data.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">                string str = data.<span class="built_in">substr</span>(npc, i - npc + <span class="number">1</span>);</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(<span class="built_in">stoi</span>(str));</span><br><span class="line">                npc = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(data[i] == <span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                string str = data.<span class="built_in">substr</span>(npc, i - npc);</span><br><span class="line">                arr.<span class="built_in">emplace_back</span>(<span class="built_in">stoi</span>(str));</span><br><span class="line">                npc = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr.<span class="built_in">size</span>() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> npc = arr[n - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(npc);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(arr, npc); <span class="comment">// 寻找最后一个小于 根节点的下标，则x左边的都是该节点的左子树，右边的都是该节点的右子树</span></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span>)&#123;  </span><br><span class="line">            root-&gt;left = <span class="built_in">dfs</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">begin</span>() + x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= n - <span class="number">2</span>)&#123;</span><br><span class="line">            root-&gt; right = <span class="built_in">dfs</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(arr.<span class="built_in">begin</span>() + x, arr.<span class="built_in">begin</span>() + n - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; x)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec* ser = new Codec();</span></span><br><span class="line"><span class="comment">// Codec* deser = new Codec();</span></span><br><span class="line"><span class="comment">// string tree = ser-&gt;serialize(root);</span></span><br><span class="line"><span class="comment">// TreeNode* ans = deser-&gt;deserialize(tree);</span></span><br><span class="line"><span class="comment">// return ans;</span></span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是树的节点个数，<em>serialize</em> 需要 <em>O(n)</em> 时间遍历每个点。<em>deserialize</em> 需要 <em>O(n)</em> 时间恢复每个点</li>
<li>空间复杂度：<em>O(n)</em>，其中 <em>n</em> 是树的节点个数，<em>serialize</em> 需要 <em>O(n)</em> 空间数组保存每个点的值，递归的深度最深也为 <em>O(n)</em>。<em>deserialize</em> 需要 <em>O(n)</em> 空间用数组保存每个点的值，递归的深度最深也为 <em>O(n)</em>。</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：36 ms, 在所有 C++ 提交中击败了44.95%的用户</p>
<p>内存消耗：36.3 MB, 在所有 C++ 提交中击败了12.22%的用户</p>
<p>通过测试用例：62 / 62</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉搜索树</tag>
        <tag>深度优先搜索</tag>
        <tag>字符串</tag>
        <tag>设计</tag>
        <tag>树</tag>
        <tag>广度优先搜索</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>944.删列造序</title>
    <url>/2022/05/12/LeetCode/20220512-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode.cn/problems/delete-columns-to-make-sorted/"> 删列造序 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>暴力解法：遍历二维数组，先遍历列，再遍历行。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDeletionSize</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; strs.<span class="built_in">size</span>(); j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(strs[j][i] &lt; strs[j - <span class="number">1</span>][i])&#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * m)</em>，其中 <em>n</em> 是字符串的个数，m是每个字符串的长度</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：36 ms, 在所有 C++ 提交中击败了68.31%的用户</p>
<p>内存消耗：11.9 MB, 在所有 C++ 提交中击败了33.14%的用户</p>
<p>通过测试用例：85 / 85</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>3375.成绩排序</title>
    <url>/2022/05/12/AcWing/20220512-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://www.acwing.com/problem/content/3378/"> 成绩排序 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>使用 <code>stable_sort</code> 进行排序，因为 <code>stable_sort</code> 是稳定的，可确保不需要排序的数据相对位置不改变。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stable_sort 使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">minTomax</span><span class="params">(vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stable_sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &lt; b.second; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxTomin</span><span class="params">(vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt;&amp; arr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stable_sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second; </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        string a;</span><br><span class="line">        <span class="type">int</span> b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="built_in">maxTomin</span>(arr);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">minTomax</span>(arr);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; arr[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i].second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * logn)</em>，其中 <em>n</em> 是学生的个数</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：31 ms</p>
<p>内存消耗：340KB</p>
<p>通过测试用例：10/10</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>AcWing</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>3376.成绩排序2</title>
    <url>/2022/05/12/AcWing/20220512-02/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://www.acwing.com/problem/content/3379/"> 成绩排序2 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>自定义 <code>sort</code> 排序</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; arr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义排序</span></span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &amp;a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.second != b.second) </span><br><span class="line">            <span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> a.first &lt; b.first;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        cout &lt;&lt; arr[i].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; arr[i].second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n * logn)</em>，其中 <em>n</em> 是学生的个数</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：18 ms</p>
<p>内存消耗：220KB</p>
<p>通过测试用例：10/10</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>AcWing</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 01.05.一次编辑</title>
    <url>/2022/05/13/LeetCode/20220513-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode.cn/problems/one-away-lcci/"> 一次编辑 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>分类讨论：</p>
<ul>
<li>当两个字符串相等时，直接返回 <code>True</code></li>
<li>当两个字符串的长度相差超过2时，直接返回 <code>False</code></li>
<li>当两个字符串长度相差为 1 时，则调用函数判断是否只存在一处编辑</li>
<li>当两个字符串长度相等时，遍历一遍字符串，判断每个位置的字符是否相等，若不相等的个数大于 1 时，则返回 <code>False</code> ，否则返回 <code>True</code></li>
</ul>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// a 是较大的字符串，b是较小的字符串</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isDelete</span><span class="params">(string a, string b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            string str = a;</span><br><span class="line">            str.<span class="built_in">erase</span>(i, <span class="number">1</span>);  <span class="comment">// 删除一个字符</span></span><br><span class="line">            <span class="keyword">if</span>(str == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">oneEditAway</span><span class="params">(string first, string second)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> firstLen = first.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> secondLen = second.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(first == second) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(firstLen - secondLen) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(firstLen - secondLen) == <span class="number">1</span>) &#123; <span class="comment">// 插入或者删除一个字符</span></span><br><span class="line">            <span class="keyword">if</span>(firstLen &gt; secondLen)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isDelete</span>(first, second);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">isDelete</span>(second, first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; first.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(first[i] != second[i])&#123;</span><br><span class="line">                    num ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num == <span class="number">1</span> || num == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是字符串的长度，最多遍历一遍字符串</li>
<li>空间复杂度：<em>O(n)</em>，判断是否删除时，需要找一个临时变量存储字符串</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户</p>
<p>内存消耗：6.2 MB, 在所有 C++ 提交中击败了19.66%的用户</p>
<p>通过测试用例：1146 / 1146</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>82.删除排序链表中的重复元素 II</title>
    <url>/2022/05/14/LeetCode/20220514-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/"> 删除排序链表中的重复元素 II </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>首先再原有的链表前面插入一个新的节点，可以减少头指针变化。若 <code>cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val</code> 则删除 <code>cur-&gt;next</code>,然后依次判断，将所有重复的节点全部删除。</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val)&#123;</span><br><span class="line">                <span class="type">int</span> x = cur-&gt;next-&gt;val;  <span class="comment">// 记录下一节点的值</span></span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == x) &#123; <span class="comment">// 循环删除和下一节点值相等的所有节点</span></span><br><span class="line">                    cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是链表中节点的个数，最多遍历一遍链表</li>
<li>空间复杂度：<em>O(n)</em>，使用新的链表进行遍历</li>
</ul>
</div>
<div class="note success simple"><p>执行用时：4 ms, 在所有 C++ 提交中击败了92.06%的用户</p>
<p>内存消耗：10.8 MB, 在所有 C++ 提交中击败了65.46%的用户</p>
<p>通过测试用例：166 / 166</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>812.最大三角形面积</title>
    <url>/2022/05/15/LeetCode/20220515-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode.cn/problems/largest-triangle-area/"> 最大三角形面积 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>暴力解法：三重循环。主要是计算三角形面积的公式</p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">triangleArea</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> x3, <span class="type">int</span> y3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">abs</span>(x1 * y2 + x2 * y3 + x3 * y1 - x1 * y3 - x2 * y1 - x3 * y2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">largestTriangleArea</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = points.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">double</span> ret = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">                    ret = <span class="built_in">max</span>(ret, <span class="built_in">triangleArea</span>(points[i][<span class="number">0</span>], points[i][<span class="number">1</span>], points[j][<span class="number">0</span>], points[j][<span class="number">1</span>], points[k][<span class="number">0</span>], points[k][<span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n ^ 3)</em>，其中 <em>n</em> 是数组中元素的个数</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：8 ms, 在所有 C++ 提交中击败了78.81%的用户</p>
<p>内存消耗：7.4 MB, 在所有 C++ 提交中击败了54.24%的用户</p>
<p>通过测试用例：57 / 57</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>数组</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题 04.06.后继者</title>
    <url>/2022/05/16/LeetCode/20220516-01/</url>
    <content><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目</h2>
<p><a href="https://leetcode.cn/problems/successor-lcci/"> 后继者 </a></p>
<h2 id="思路"><a class="markdownIt-Anchor" href="#思路"></a> 思路</h2>
<p>直接进行中序遍历，当找到指定节点时，让 <code>loop = true</code>，然后继续递归，若<code>loop &amp;&amp; !res</code> 时，则赋值，否则 <code>return</code></p>
<h2 id="题解"><a class="markdownIt-Anchor" href="#题解"></a> 题解</h2>
<div class="tabs" id="题解"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#题解-1">题解1</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="题解-1"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *res = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> loop = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InorderTra</span><span class="params">(TreeNode *root, TreeNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">InorderTra</span>(root-&gt;left, p);</span><br><span class="line">        <span class="keyword">if</span>(loop)&#123;  <span class="comment">// 已经找到指定节点</span></span><br><span class="line">            <span class="keyword">if</span>(res == <span class="literal">NULL</span>)  <span class="comment">// 下一节点还没确定</span></span><br><span class="line">                res = root;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 下一节点已经确定</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root == p) loop = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">InorderTra</span>(root-&gt;right, p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">inorderSuccessor</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">InorderTra</span>(root, p);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<div class="note info simple"><ul>
<li>时间复杂度：<em>O(n)</em>，其中 <em>n</em> 是二叉树中节点的个数</li>
<li>空间复杂度：<em>O(1)</em></li>
</ul>
</div>
<div class="note success simple"><p>执行用时：20 ms, 在所有 C++ 提交中击败了98.29%的用户</p>
<p>内存消耗：22.2 MB, 在所有 C++ 提交中击败了83.77%的用户</p>
<p>通过测试用例：24 / 24</p>
</div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉搜索树</tag>
        <tag>深度优先搜索</tag>
        <tag>树</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
