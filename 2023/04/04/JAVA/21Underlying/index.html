<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>源码学习 | Atopos's Blog</title><meta name="keywords" content="JAVA"><meta name="author" content="Atopos·"><meta name="copyright" content="Atopos·"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录复习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="源码学习">
<meta property="og:url" content="http://example.com/2023/04/04/JAVA/21Underlying/index.html">
<meta property="og:site_name" content="Atopos&#39;s Blog">
<meta property="og:description" content="记录复习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Review.jpg">
<meta property="article:published_time" content="2023-04-04T00:02:25.000Z">
<meta property="article:modified_time" content="2023-04-06T07:05:35.782Z">
<meta property="article:author" content="Atopos·">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Review.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/04/04/JAVA/21Underlying/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":20,"languages":{"author":"作者: Atopos·","link":"链接: ","source":"来源: Atopos's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '源码学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-06 15:05:35'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/fonts.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/../../img/Review.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Atopos's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">源码学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-04T00:02:25.000Z" title="发表于 2023-04-04 08:02:25">2023-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-06T07:05:35.782Z" title="更新于 2023-04-06 15:05:35">2023-04-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ReviewNotes/">ReviewNotes</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="源码学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HashMap源码学习"><a href="#HashMap源码学习" class="headerlink" title="HashMap源码学习"></a>HashMap源码学习</h1><blockquote>
<p>最早在JDK1.2中出现，底层是基于散列算法实现。</p>
<p>在JDK1.8中已经非常复杂。包括：散列表实现，扰动函数，初始化容量，负载因子，扩容元素拆分，链表树化，红黑树，插入，查找，删除，遍历，分段锁等等。下面就针对这些内容进行详细解释</p>
</blockquote>
<h2 id="散列表实现"><a href="#散列表实现" class="headerlink" title="散列表实现"></a>散列表实现</h2><h3 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h3><ul>
<li>数组模拟散列表时，这里的长度是8，也就是2的倍数，这样的数组长度才会出现一个0111除高位以外都是1的特征，也是为了散列。</li>
<li>计算连列表索引时的计算方法：<code>key.hashCode() &amp; (tab.length - 1)</code>，计算出每个字符串在数组中的位置</li>
<li>在字符串存放到数组的过程，如果当前索引位置已经有元素了，则进行<code>连接</code>操作<code>模拟链表操作</code>。</li>
</ul>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一组字符串</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;jlkk&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;lopi&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;小傅哥&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;e4we&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;alpo&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;yhjk&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;plop&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义要存放的数组，模拟散列表</span></span><br><span class="line">String[] tab = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环存放</span></span><br><span class="line"><span class="keyword">for</span> (String key : list) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> key.hashCode() &amp; (tab.length - <span class="number">1</span>);  <span class="comment">// 计算索引位置</span></span><br><span class="line">    System.out.println(String.format(<span class="string">&quot;key值=%s Idx=%d&quot;</span>, key, idx));</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> == tab[idx]) &#123;</span><br><span class="line">        tab[idx] = key;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tab[idx] = tab[idx] + <span class="string">&quot;-&gt;&quot;</span> + key;  <span class="comment">// 模拟相同位置的链接情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出测试结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;测试结果：&quot;</span> + JSON.toJSONString(tab));</span><br></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p><img src="21Underlying/image-20230404165338416.png" alt="image-20230404165338416"></p>
<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul>
<li>这里所有的所有元素存放都需要获取一个索引位置，如果元素的位置不够，散列碰撞严重（同一索引存在较多的元素），那就失去了散列表存放的意义。</li>
<li>在获取索引ID的计算公式中，需要数组长度是2的倍数，<strong>那怎么进行初始化这个数组大小。</strong></li>
<li>数组越小碰撞越大，数组越大碰撞越小，<strong>时间空间怎么取舍。</strong></li>
<li>目前存放了7个元素，已经存在两个位置存放了2个字符串，<strong>那么链表越长该怎么优化。</strong></li>
<li>随着元素到的不断增加，<strong>数组长度不足扩容时，怎么把原有的元素，拆分到新的位置。</strong></li>
</ul>
<h2 id="扰动函数"><a href="#扰动函数" class="headerlink" title="扰动函数"></a>扰动函数</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>理论上来说字符串hashCode是一个int类型值，那可以直接作为数组下标，并且不会出现碰撞，但这个hashCode的取值范围是[-2147483648, 2147483647]，数组初始化不可能这么大。</p>
<p>HashMap底层默认初始化的大小是16个长度。<code>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code>，因此获取到的hashCode值不能直接作为下标使用。需要与数组长度进行取模运算得到一个下标值。<code>key.hashCode() &amp; (tab.length - 1)</code> 这个只是简单的运算，HashMap底层计算如下。</p>
<h3 id="HashMap底层实现"><a href="#HashMap底层实现" class="headerlink" title="HashMap底层实现"></a>HashMap底层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h3><p><img src="21Underlying/image-20230404193630048.png" alt="image-20230404193630048"></p>
<h2 id="初始化容量"><a href="#初始化容量" class="headerlink" title="初始化容量"></a>初始化容量</h2><p>HashMap默认的初始化大小是16，并且要求初始化的容量必须是2的倍数，因为只有2的倍数在减1的时候，才会出现01111这样的值。</p>
<p>因此如果在初始化HashMap的时候，传一个17个的值，<code>new HashMap&lt;&gt;(17)</code>，在底层会通过一个构造函数找到大于17的最小的<strong>2的倍数</strong>（2^x）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);  <span class="comment">// 通过tableSizeFor进行计算。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="负载因子"><a href="#负载因子" class="headerlink" title="负载因子"></a>负载因子</h2><p>在HashMap中，负载因子决定了数据量到达多少了以后会进行扩容。需要提供一个指标来确定当某个位置的碰撞阈值到达多少后会进行扩容。</p>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<p>在HashMap中的默认值是0.75，就是说当阈值容量占了3/4时需要扩容，减少Hash碰撞。</p>
<p>这个阈值可以进行调整，如果希望可以用更多的空间换取时间，可以把负载因子调的更小一些，减少碰撞。</p>
<h2 id="扩容元素拆分"><a href="#扩容元素拆分" class="headerlink" title="扩容元素拆分"></a>扩容元素拆分</h2><p>扩容是在当数组长度不足的时候，需要把元素拆分到新的数组中。</p>
<p>在JDK1.7中需要重新计算哈希值，在JDK1.8中进行了优化：</p>
<h3 id="拆分后新的位置的计算方法"><a href="#拆分后新的位置的计算方法" class="headerlink" title="拆分后新的位置的计算方法"></a>拆分后新的位置的计算方法</h3><p>原哈希值与扩容新增出来的长度16进行&amp;运算，如果值等于0，则下标位置不变，如果不为0，则新的位置则是原来位置上加16。</p>
<p>在JDK1.8引入了红黑树解决链表长度过长的问题，简单说当链表长度&gt;=8时，将链表转换为红黑树。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><img src="21Underlying/第2章，第3节 HashMap插入数据流程图.png" alt="第2章，第3节 HashMap插入数据流程图"></p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol>
<li><p>首先进行哈希值的扰动，获取一个新的哈希值。<code>(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code></p>
</li>
<li><p>判断tab是否为空或者长度为0，如果是则进行扩容操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;  <span class="comment">// 数组长度</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>根据哈希值计算下标，如果对应下标没有存放数据，则直接插入即可，否则需要覆盖。<code>tab[i = (n - 1) &amp; hash] = key;</code></p>
</li>
<li><p>判断<code>tab[i]</code>是否是树节点（链表长度&gt;=8则为树）。是则向树中插入节点；否则向链表总插入数据，</p>
</li>
<li><p>如果链表中插入节点后，链表长度大于等于8，则需要把链表转换为<strong>红黑树</strong>。<code>treeifyBin(tab, hash);</code></p>
</li>
<li><p>最后所有元素处理完成后，判断时候超过阈值；<code>threshold</code>，超过则会扩容。</p>
</li>
<li><p>treeifyBin是一个链表转树的方法，但不是所有的链表长度为8后都会转成树，还需要判断存放key值得数组桶长度是否小于64<code>MIN_TREEIFY_CAPACITY</code>，如果小于则需要扩容，扩容后链表上得数据会被拆分散列到相应得桶节点上，也就把链表得长度缩短了。</p>
</li>
</ol>
<h3 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">    <span class="comment">// 初始化桶数组 table，table被延迟到插入新数据时才进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 如果桶中不包含键值对节点引用，则将新键值对节点得引用存入桶中即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果键的值以及节点 hash 等于链表中的第一个键值对节点时，则将 e 指向该键值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果桶中得引用类型是TreeNode，则调用红黑树得插入方法。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对链表进行遍历，并统计链表得长度。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 链表中不包含要插入得键值对节点时，则将该节点接在链表的最后</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表的长度 &gt;= 树化阈值8，则进行树化操作。转为红黑树。</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 表示当前链表包含要插入的键值对，终止遍历</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断要插入的键值对是否存在HashMap中</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// 表示 仅在oldValue为null的情况下更新键值对的值。</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 键值数量超过阈值，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><blockquote>
<p>HashMap是基于数组+链表和红黑树实现的，但用于存放key值的数组桶长度是固定的，有初始化决定。</p>
</blockquote>
<p>随着数据的插入数量增加以及负载因子的作用，就需要扩容来存放更多的数据。</p>
<h4 id="扩容时机"><a href="#扩容时机" class="headerlink" title="扩容时机"></a>扩容时机</h4><p>当HashMap中的元素个数超过数组大小*DEFAULT_LOAD_FACTOR，就会进行数组扩容，</p>
<h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ol>
<li>扩容时计算出新的newCap，newThr，这是两个单词的缩写，一个时Capacity，另一个时Threshold</li>
<li>newCap用于创新的数组桶<code>new Node[newCap]</code></li>
<li>随着扩容后，原来那些因为哈希碰撞，存放成链表和红黑树的元素，都需要进行拆分存放到新的位置。</li>
</ol>
<h4 id="源码学习-1"><a href="#源码学习-1" class="headerlink" title="源码学习"></a>源码学习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// cap 是 capacity的缩写，容量，如果容量不为空，则说明已经初始化。</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果容量达到最大 1 &lt;&lt; 30则不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 按旧容量和阈值的2倍计算新容量和阈值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 初始化时，将 threshold 的值赋值给newCap</span></span><br><span class="line">        <span class="comment">// HashMap 使用 threshold 变量暂时保存 initialCapacity 参数的值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// newThr 为0时，则使用阈值公式计算容量。</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    <span class="comment">// 初始化数组桶</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// split 进行红黑树拆分操作，在重新映射时操作的。</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 如果当前时按照链表存放的，则将链表节点按原顺序进行分组。</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 将分组后的链表映射到桶中。</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链表树化"><a href="#链表树化" class="headerlink" title="链表树化"></a>链表树化</h3><blockquote>
<p>HashMap这种散列表的数据结构，最大的性能在于能够O(1)时间复杂度定位到元素，但因为哈希表碰撞不得不在一个下标里存放多组数据。</p>
<p>在JDK1.8以前，只是采用链表的方式进行存放，但是从链表中定位数据的时间复杂度时O(n)，链表越长性能越差。</p>
<p>在JDK1.8以后，把过长的链表也就是8个，优化为<strong>自平衡</strong>的红黑树，可以让定位元素的时间复杂度优化近似于O(logn)。</p>
</blockquote>
<p><img src="21Underlying/image-20230404210658613.png" alt="image-20230404210658613"></p>
<h4 id="源码学习-2"><a href="#源码学习-2" class="headerlink" title="源码学习"></a>源码学习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> hash)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 不一定会树化，也可能是扩容。主要桶数组容量是否小于 MIN_TREEIFY_CAPACITY 64</span></span><br><span class="line">    <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// hd = head tl = tile</span></span><br><span class="line">        TreeNode&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 将普通节点转换为树节点，但此时还不是红黑树，也就是说还不一定平衡。</span></span><br><span class="line">            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">                hd = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p.prev = tl;</span><br><span class="line">                tl.next = p;</span><br><span class="line">            &#125;</span><br><span class="line">            tl = p;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> ((tab[index] = hd) != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 转红黑树操作，这里需要循环比较，染色，旋转，</span></span><br><span class="line">            hd.treeify(tab);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li>链表树化的条件有两点：链表长度大于等于8 &amp;&amp; 桶容量大于64，否则只是扩容，不会树化。</li>
<li>链表树化的过程中是先由链表转换为树节点，此时的树可能不是一颗平衡树。同时 在树转换过程中会记录链表的顺序，<code>tl.next = p</code>，这主要方便后续树转链表和 拆分更方便。</li>
<li>链表转换成树完成后，在进行红黑树的转换。先简单介绍下，红黑树的转换需要染 色和旋转，以及比对大小。</li>
</ol>
<h3 id="红黑树转链"><a href="#红黑树转链" class="headerlink" title="红黑树转链"></a>红黑树转链</h3><p>在链表转红黑树的过程中，记录了原有链表的顺序，因此在红黑树转链表的时候，直接把TreeNode转为Node即可。</p>
<h4 id="源码学习-3"><a href="#源码学习-3" class="headerlink" title="源码学习"></a>源码学习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">untreeify</span><span class="params">(HashMap&lt;K,V&gt; map)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; hd = <span class="literal">null</span>, tl = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历TreeNode</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; q = <span class="built_in">this</span>; q != <span class="literal">null</span>; q = q.next) &#123;</span><br><span class="line">        <span class="comment">// 将TreeNode 转为 Node </span></span><br><span class="line">        Node&lt;K,V&gt; p = map.replacementNode(q, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (tl == <span class="literal">null</span>)</span><br><span class="line">            hd = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tl.next = p;</span><br><span class="line">        tl = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt; <span class="title function_">replacementNode</span><span class="params">(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><p><img src="21Underlying/image-20230404212940971.png" alt="image-20230404212940971"></p>
<h3 id="源码学习-4"><a href="#源码学习-4" class="headerlink" title="源码学习"></a>源码学习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 通过扰动函数hash()计算key对应的Hash值</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="type">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 桶数组是否为空或者长度为0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 计算key在桶数组中对应的下标 哈希值 &amp; 数组长度 - 1</span></span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// TreeNode 节点直接调用红黑树的查找方法，时间复杂度O(logn)</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 如果是链表就依次遍历查找。</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><ol>
<li>扰动函数的使用，获得新的哈希值hash</li>
<li>下标的计算，tab[(n - 1) &amp; hash]</li>
<li>确定桶数组下标位置，接下来就是对红黑树和链表进行查找和遍历了。</li>
</ol>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除操作比较简单，没有太多的复杂逻辑</p>
<h3 id="源码学习-5"><a href="#源码学习-5" class="headerlink" title="源码学习"></a>源码学习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">remove</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 通过扰动函数获得key所对应的hash值</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>)) == <span class="literal">null</span> ?</span><br><span class="line">        <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">removeNode</span><span class="params">(<span class="type">int</span> hash, Object key, Object value,</span></span><br><span class="line"><span class="params">                           <span class="type">boolean</span> matchValue, <span class="type">boolean</span> movable)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, index;</span><br><span class="line">    <span class="comment">// 桶数组table不为空，并且长度不等于0</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="comment">// 定位桶数组的下标位置 index = (n - 1) &amp; hash</span></span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="literal">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">// 如果与链表第一个节点相等，则将node指向该节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 树节点，调用红黑树查找方法查找该节点</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 遍历链表，找到待删除的节点。</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除节点，以及红黑树需要修复，因为删除后会破坏平衡性，链表的删除更加简单。</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="literal">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)  <span class="comment">// TreeNode</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="built_in">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)  <span class="comment">// 头节点</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">// 链表节点</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ul>
<li>只有链表信息</li>
</ul>
<p><img src="21Underlying/image-20230404214649948.png" alt="image-20230404214649948"></p>
<ul>
<li>链表转换为红黑树，树会跟会移动到数组头部<code>moveRootToFront()</code>方法</li>
</ul>
<p><img src="21Underlying/image-20230404214739995.png" alt="image-20230404214739995"></p>
<ul>
<li>删除部分元素，红黑树退成链表</li>
</ul>
<p><img src="21Underlying/image-20230404214826248.png" alt="image-20230404214826248"></p>
<h1 id="2-3树与红黑树学习"><a href="#2-3树与红黑树学习" class="headerlink" title="2-3树与红黑树学习"></a>2-3树与红黑树学习</h1><h2 id="为什么使用树结构"><a href="#为什么使用树结构" class="headerlink" title="为什么使用树结构"></a>为什么使用树结构</h2><p>使用树结构最直接的原因就是为了提升整体的效率；插入，删除，查找（索引），尤其是索引操作，相比较于链表，一个平衡树的索引时间复杂度是O(logn)，而数组的索引时间复杂度是O(n)</p>
<h2 id="2-3树解决平衡问题"><a href="#2-3树解决平衡问题" class="headerlink" title="2-3树解决平衡问题"></a>2-3树解决平衡问题</h2><blockquote>
<p>2-3树是一种非常巧妙地结构，在保持树结构地基础上，它允许在一个节点中可以有两个元素，等元素数量等于3个时候再进行调整。通过这种方式，来保证整个二叉搜索树地平衡性。2-3树是红黑树的演变前身。</p>
<p>需要注意：2-3树里的2，3是指树种某个子节点的数量。可以有两个，也可以有三个。</p>
</blockquote>
<p>下图是二叉搜索树和2-3平衡树插入节点的对比</p>
<p><img src="21Underlying/image-20230405085625311.png" alt="image-20230405085625311"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>2-3树所有子叶节点都在同一层</li>
<li>1个节点可以有1到2个数据，如果有三个数据就需要调整树结构</li>
<li>1个节点1个数据时，则该节点有两个子节点</li>
<li>1个节点2个数据时，则该节点有三个子节点，且中间子节点是介于两个节点间的值。</li>
</ul>
<h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><p>下图是模拟将1，2，3，4，5，6，7插入到2-3树的变化过程。</p>
<p><img src="21Underlying/image-20230405091432816.png" alt="image-20230405091432816"></p>
<ol>
<li>向节点1中插入数据2，此时为了保持平衡，不会产生新分支，只会在一个节点中存放两个数据</li>
<li>继续插入数据3，此时节点中有三个数据，这是一个临时区域</li>
<li>把三个数据的节点，中间节点拉起来，调整成属性结构</li>
<li>继续插入数据4，为了保持树平衡，数据4会放在节点3中，该节点存放数据3，4</li>
<li>继续插入数据5，插入后3，4，5公用一个节点，则需要调整该节点。</li>
<li>中间节点4向上调整，调整后节点1在左侧，节点3在中间，节点5在右侧。</li>
<li>继续插入数据6，在保持平衡的情况下，与节点5公用一个节点。</li>
<li>插入数据七。5，6，7公用一个节点，进行调整，将6向上调整，此时2，4，6又公用一个节点，需要再次调整，</li>
<li>最终形成一个平衡的二叉树。</li>
</ol>
<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><p>数据删除是一个逆向的过程，主要包括两种情况：</p>
<ul>
<li>删除了3-节点，也就是包含两个数据元素的节点，直接删除即可，不会破坏树的平衡。</li>
<li>删除了2-节点，此时会破坏树平衡，需要将树高缩短或者元素合并，恢复树平衡。</li>
</ul>
<p>下图是模拟将数据再从7，6，5，4，3，2，1顺序删除</p>
<p><img src="21Underlying/image-20230405092623718.png" alt="image-20230405092623718"></p>
<p>稍微复杂一点的2-3树删除</p>
<p><img src="21Underlying/image-20230405092736523.png" alt="image-20230405092736523"></p>
<h3 id="数据索引"><a href="#数据索引" class="headerlink" title="数据索引"></a>数据索引</h3><p>相比较于插入删除，索引的过程比较简单。基本原则就是：</p>
<ul>
<li>大于当前节点值，右侧寻找</li>
<li>小于当前节点值，左侧寻找</li>
<li>直到找到索引值，停止。</li>
</ul>
<h2 id="2-3树转红黑树"><a href="#2-3树转红黑树" class="headerlink" title="2-3树转红黑树"></a>2-3树转红黑树</h2><blockquote>
<p>红黑树是一种高效的自平衡的二叉查找树。可以在近似O(logn)时间复杂度下完成插入，删除，查找等操作。</p>
<p>Java中的TreeMap，JDK1.8中的HashMap，C++STL中的map均是基于红黑树结构实现的。</p>
</blockquote>
<h3 id="红黑树规则"><a href="#红黑树规则" class="headerlink" title="红黑树规则"></a>红黑树规则</h3><ul>
<li>根节点是黑色</li>
<li>节点是红色或者黑色</li>
<li>所有叶节点都是黑色（子叶节点是NIL节点，默认没有画出来）</li>
<li>每个红色节点必须有两个黑色子节点（也就说明一条链路上不能有相连的红色节点）</li>
<li>从任一节点到其每个子叶节点，经过的路径都包含相同数目的黑色节点。</li>
</ul>
<h3 id="2-3树和红黑树关系"><a href="#2-3树和红黑树关系" class="headerlink" title="2-3树和红黑树关系"></a>2-3树和红黑树关系</h3><blockquote>
<p>2-3树转红黑树是由概念模型2-3-4树转换而来的。-4叉就是一个节点里有3个元素，有四个子节点。这在2-3树中会被调整。但实现起来比较复杂。</p>
<p>红黑树既保持2-3树平衡和O(logn)的特性，又能在代码上更加方便实现。</p>
</blockquote>
<h3 id="2-3树转红黑树-1"><a href="#2-3树转红黑树-1" class="headerlink" title="2-3树转红黑树"></a>2-3树转红黑树</h3><p>2-3-4树与红黑树的转换关系包括：</p>
<ul>
<li>2-叉节点，把原有节点转换成黑色节点</li>
<li>3-叉节点，包括两个元素，先用红色线把两个节点相连，之后拆分出来，最后调整高度，黑色节点在上。</li>
<li>4-叉节点，包括了3个元素，分别用红黑线连接，之后拆分出来拉升高度。这个拉升过程和2-3树调整一致，只是添加了颜色。</li>
</ul>
<p>简单转换示例</p>
<p><img src="21Underlying/image-20230405094101903.png" alt="image-20230405094101903"></p>
<p>复杂一点的2-3树转红黑树</p>
<p><img src="21Underlying/image-20230405094919173.png" alt="image-20230405094919173"></p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="平衡操作"><a href="#平衡操作" class="headerlink" title="平衡操作"></a>平衡操作</h3><blockquote>
<p>2-3树在插入新节点时不会插入到空位置，而是与现有节点融合以及调整，保持整个树的平衡。</p>
<p>红黑树是2-3-4树的一种概念模型转换而来的，再插入节点时通过红色链接相连，也就是插入红色节点。插入完成后进行调整，以保持树接近平衡。</p>
<p>为了让红黑树达到平衡状态，主要包括染色，左右旋转。</p>
</blockquote>
<h4 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h4><blockquote>
<p>把一个向右倾斜的红节点链接（2-3树，3-叉双元素节点），转化为左连接</p>
</blockquote>
<p>插入数据1，2，3时的2-3平衡树和红黑树保持平衡的操作如下图所示：</p>
<p><img src="21Underlying/image-20230405095641274.png" alt="image-20230405095641274"></p>
<ul>
<li>2-3树，所有插入的节点都会保持在一个节点上，之后通过调整节点位置，保持平衡。</li>
<li>红黑树，则需要通过节点的左侧旋转，将元素2拉起来，元素1和元素3分别称为左右子节点。</li>
</ul>
<h4 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h4><blockquote>
<p>把一个向左倾斜的红节点连接（2-3树，3-叉双元素节点），转换为右连接。</p>
</blockquote>
<p>插入数据3，2，1时的2-3平衡树和红黑树保持平衡的操作如下图所示：</p>
<p><img src="21Underlying/image-20230405095947576.png" alt="image-20230405095947576"></p>
<ul>
<li>2-3树，所有插入的节点都会保持在一个节点上，之后通过调整节点位置，保持平衡。</li>
<li>红黑树，则需要通过节点的右侧旋转，将元素2拉起来，元素1和元素3分别称为左右子节点。</li>
</ul>
<p>这里可以发现，左旋和右旋是相互对应的，但在2-3树中式保持不变的。</p>
<h4 id="左右旋转综合"><a href="#左右旋转综合" class="headerlink" title="左右旋转综合"></a>左右旋转综合</h4><ul>
<li>1，3插入0，左侧底部插入，与2-3树相比，需要右旋转保持平衡。</li>
<li>1，3插入2，中间位置插入，首先进行左旋调整元素位置，之后进行又选进行树平衡。</li>
<li>1，3插入5，右侧位置插入，此时正好保持平衡，不需要调整。</li>
</ul>
<p><img src="21Underlying/image-20230405100608493.png" alt="image-20230405100608493"></p>
<h3 id="染色"><a href="#染色" class="headerlink" title="染色"></a>染色</h3><p>当添加了新的节点后，为了保持树平衡是不插入到空位置上的，需要参照红黑树规则来进行染色。<a href="#红黑树规则">红黑树规则</a></p>
<p>其中最终要的两条规则是：</p>
<ul>
<li>从根节点到叶节点的每条链路上不能有相连的两个红色节点。</li>
<li>每条链路上黑色节点的数应该相等。</li>
</ul>
<h3 id="旋转-染色运用案例"><a href="#旋转-染色运用案例" class="headerlink" title="旋转+染色运用案例"></a>旋转+染色运用案例</h3><ul>
<li>首先从左侧开始，是一个按照顺序插入生成的红黑树，插入顺序：7，2，8，1，4，3，5</li>
<li>向红黑树中插入6，插入后右下角有三个红色节点：3，5，6。此时不满足【从根节点到叶节点的每条链路上不能有相连的两个红色节点。】因此需要进行染色。染色后3，5为黑色节点，4，6为红色节点。</li>
<li>染色后，被红色链接线连接的7，2，4，最小节点在中间。左旋平衡树结构。</li>
<li>左旋完成后，红色连接线的7，4，2，为左倾顺序节点，因此需要做右旋操作。</li>
<li>右旋完成后，又满足了染色操作【根节点必须为黑色节点，每条路径上黑色节点数需要相同。】。染色后，红黑树恢复了平衡。</li>
</ul>
<p><img src="21Underlying/image-20230405102111592.png" alt="image-20230405102111592"></p>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>根据2-3-4树模型的红黑树，在删除的时候基本是按照2-3方式进行删除，只不过在这个过程中需要染色和旋转操作。以保持树平衡。删除过程可以分为如下四种情况。</p>
<p><img src="21Underlying/image-20230405102940176.png" alt="image-20230405102940176"></p>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><blockquote>
<p>ArrayList是基于数组实现的。它可以在ArrayList的管理下插入数据时按需动态扩容，数据拷贝等操作。</p>
</blockquote>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>Array + List = 数组 + 列表 = ArrayList = 数组列表</p>
<p><img src="21Underlying/image-20230405104823322.png" alt="image-20230405104823322"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment"> *         is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><h4 id="普通插入"><a href="#普通插入" class="headerlink" title="普通插入"></a>普通插入</h4><blockquote>
<p>ArrayList对元素的插入，其实就是对数组的操作，只不过需要特定时候扩容。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查长度是否充足，</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是插入元素的源码，size++自增，把对应元素添加上去。</p>
<h4 id="插入时扩容"><a href="#插入时扩容" class="headerlink" title="插入时扩容"></a>插入时扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行扩容的源码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="comment">// 计算扩容后数组的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从初始化的源码可以看出，ArrayList默认初始化时会申请10个长度的空间，如果超过这个长度，则需要进行扩容。</p>
<p>扩容的步骤主要是，先申请新的数组长度，并把原数组元素拷贝到新数组中。</p>
<p><strong>具体步骤</strong></p>
<ol>
<li>判断长度是否充足：<code>ensureCapacityInternal(size + 1)</code></li>
<li>当长度不足时，则通过扩大函数，进行扩容:<code>grow(minCapacity);</code></li>
<li><strong>扩容的长度计算</strong>：<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> 旧容量 + 旧容量右移一位，这相当于扩容了原来容量的<code>(int)3/2</code>。初始长度为10，扩容一次新的长度则为15。</li>
<li>当扩容完以后，就需要进行把数组中的数据拷贝到新数组中。这个过程会用到<code>Arrays.copyOf(elementData, newCapacity);</code>。但是底层用到的就是<code>System.arraycopy</code></li>
</ol>
<h4 id="指定位置插入"><a href="#指定位置插入" class="headerlink" title="指定位置插入"></a>指定位置插入</h4><p><code>list.add(index, value)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查index是否越界，这里的界限并不是capacity，而是size</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 数组拷贝迁移，把待插入的位置空出来</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">// 数据插入操作</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>具体步骤</strong></p>
<ol>
<li>容量验证<ol>
<li>指定位置首先需要判断该位置是否查过size的长度。<code>rangeCheckForAdd(index);</code>，如果越界，则会抛异常。</li>
<li>这里的size不是初始化数组时申请的capacity 10。而是插入元素的个数。如果超出这个size，则会抛出<code>IndexOutOfBoundException</code>异常。</li>
</ol>
</li>
<li>元素迁移<ol>
<li>容量验证index可以进行插入后，</li>
<li>判断插入后是否需要进行扩容<code>ensureCapacityInternal(size + 1);</code>，如果需要，则进行扩容</li>
<li>数据元素迁移，把从待插入位置后的元素，顺序往后迁移。这里用的时数组拷贝<code>System.arraycopy(elementData, index, elementData, index + 1, size - index);</code>把数组中从index往后位置的元素，复制到新数组的index + 1 位置中。</li>
<li>给数组的指定位置赋值，也就是把待插入元素插入进来，更新size。</li>
</ol>
</li>
</ol>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查index是否越界</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">	</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算删除后需要移动的元素，就是index后元素的个数。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 通过复制实现删除</span></span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">// 结尾元素清空</span></span><br><span class="line">    elementData[--size] = <span class="literal">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>具体步骤</strong></p>
<ol>
<li>校验是否越界；<code>rangeCheck(index)</code></li>
<li>计算删除元素后需要的移动长度<code>numMoved</code>，通过<code>System.arraycopy</code>把自己从index+1位置往后的元素复制到index位置往后。</li>
<li>把最后一个元素清空为null。更新size。</li>
</ol>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><blockquote>
<p>LinkedList是基于链表实现的，由双向链条next，prev，把数据节点穿插起来。因此插入数据时不需要扩容数组。</p>
</blockquote>
<h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>Linked + List = 链表 + 列表 = LinkedList = 链表列表</p>
<p><img src="21Underlying/image-20230405154226411.png" alt="image-20230405154226411"></p>
<h2 id="源码学习-6"><a href="#源码学习-6" class="headerlink" title="源码学习"></a>源码学习</h2><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>与ArrayList不同，LinkedList初始化不需要创建数组，因为他是一个链表结构。<code>LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(10)</code>时错误的。</p>
<h3 id="插入-2"><a href="#插入-2" class="headerlink" title="插入"></a>插入</h3><blockquote>
<p>LinkedList的插入方法比较多。除了List接口默认提供的<code>add</code>方法外，也可以指定位置插入，还提供了头插<code>addFirst</code>和尾插<code>addLast</code></p>
</blockquote>
<h4 id="头插"><a href="#头插" class="headerlink" title="头插"></a>头插</h4><p>LinkedList和ArrayList头插对比：ArrayList头插就是add(0, value);</p>
<p><img src="21Underlying/image-20230405154935372.png" alt="image-20230405154935372"></p>
<p>从上图可以看出：</p>
<ul>
<li>ArrayList头插时，需要把数组元素通过Arrays.copyOf的方式把数组元素移位，如果容量不足时还需要扩容</li>
<li>LinkedList头插时，组不需要考虑扩容以及移位问题，直接把元素定位到首位，节点链条链接上即可。</li>
</ul>
<p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供的方法接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取原来的头节点，用f指向</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 生成新的节点，新的节点next指针指向f，pre指针指向null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    <span class="comment">// first头指针指向新的节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 如果原来的头节点是null，则新的节点既是头节点，也是尾节点，因此last尾指针执行该新节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="comment">// 如果原理啊的头节点不是null，则将原来头节点的前驱指针指向新的头节点。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>具体步骤</strong></p>
<ol>
<li>首先通过头指针first获取原来的头节点，并用f指向。<code>f = first</code></li>
<li>生成新的节点<code>newNode</code>，新的节点的next指针指向f，pre指针指向null。<code>newNode.next = f</code></li>
<li>将头指针指向新的节点。<code>first = newNode</code></li>
<li>然后判断原来的头节点f是否存在，不存在，则新插入的节点既是头节点也是尾节点，因此需要尾指针也指向它。<code>last = newNode</code></li>
<li>如果存在，则用f的pre指针指向新的头节点。<code>f.prev = newNode</code></li>
<li>最后记录size大小，和元素数量modCount。modCount用在遍历时做校验。</li>
</ol>
<h4 id="尾插"><a href="#尾插" class="headerlink" title="尾插"></a>尾插</h4><p>LinkedList和ArrayList尾插对比：ArrayList尾插就是add(value);</p>
<p><img src="21Underlying/image-20230405161621543.png" alt="image-20230405161621543"></p>
<p>从上图可以看出：</p>
<ul>
<li>ArrayList尾插时，是不需要数据位移的，比较耗时的是数据的扩容时，需要拷贝迁移了。</li>
<li>LinkedList尾插时，与头插相比耗时点会在对象的实例化上。</li>
</ul>
<p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取用原来的尾节点，用l指向</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 生成新的节点，pre指针指向l，next指针指向null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 将last尾指针指向新的节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">// 判断原来的尾节点是否为空，如果为空，则头指针也需要指向新的节点。</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="comment">// 如果不为空，原来尾节点的next指针指向新的尾节点。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾插和头插代码没什么区别，只是first换成了last。耗时点在创建节点上<code>Node&lt;E&gt;</code></p>
<h4 id="中间插"><a href="#中间插" class="headerlink" title="中间插"></a>中间插</h4><p>LinkedList和ArrayList中间插对比：ArrayList中间插就是add(index，value);</p>
<p><img src="21Underlying/image-20230405162403477.png" alt="image-20230405162403477"></p>
<p>从上图可以看出：</p>
<ul>
<li>ArrayList中间插入，它定位的时间复杂度时O(1)，比较耗时的点在于数据迁移和容量扩充。</li>
<li>LinkedList中间插入，链表的数据实际插入并不耗时，但是定位的元素的时间复杂度时O(n)。所以这部分以及元素的实例化比较耗时。</li>
</ul>
<p><strong>源码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用add(index, value)插入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在最后一个位置插入</span></span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 位置定位</span></span><br><span class="line">Node&lt;E&gt; <span class="title function_">node</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">	<span class="comment">// size &gt;&gt; 1，这部分的代码是用来判断是在左半区间还是右半区间。</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行插入</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> &#123;</span><br><span class="line">    <span class="comment">// assert succ != null;</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(pred, e, succ);</span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>具体步骤</strong></p>
<ul>
<li>首先判断index是否越界。</li>
<li>当index是链表的最后一个位置时，直接用尾插法进行插入<code>addLast(value)</code>;</li>
<li>否则需要获取定位index的节点。这里可以使用<code>size &gt;&gt; 1</code>来进行判断index是在左半区间还是右半区间，进而缩小定位的时间。</li>
<li>然后执行插入。执行插入的过程和头插尾插一样。只不过将<code>first</code>和<code>last</code>换位定位之后的元素<code>succ</code>了。</li>
</ul>
<h3 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h3><p>和ArrayList不同，删除操作不需要拷贝元素，直接找到要删除的元素位置，把元素前后链链接上，即可。</p>
<p><img src="21Underlying/image-20230405163719063.png" alt="image-20230405163719063"></p>
<ul>
<li>确定出要删除的元素x，把前后的链接进行替换。</li>
<li>如果是删除首尾元素，操作起来会更容易，但中间位置删除，需要遍历找到对应位置。</li>
</ul>
<h4 id="删除操作的方法"><a href="#删除操作的方法" class="headerlink" title="删除操作的方法"></a>删除操作的方法</h4><p><img src="21Underlying/image-20230405163918550.png" alt="image-20230405163918550"></p>
<p><strong>源码</strong></p>
<p>这里列举<code>list.remove(&quot;a&quot;)</code>的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素定位。找到要删除元素的位置。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="literal">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="literal">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解链</span></span><br><span class="line">E <span class="title function_">unlink</span><span class="params">(Node&lt;E&gt; x)</span> &#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">E</span> <span class="variable">element</span> <span class="operator">=</span> x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="literal">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="literal">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的重点是<code>unlink</code>方法：</p>
<ul>
<li>获取待删除节点的信息；元素item，元素下一个节点next，元素上一个节点prev</li>
<li>如果上个节点为空则把待删除的元素的下一个节点赋值给首节点<code>first = next</code>。否则把删除节点的下一个节点，赋值给待删除节点的上一个节点的子节点。<code>pre.next = next</code>。其实就是在判断删除的是不是头节点。</li>
<li>对于待删除节点的下一个节点next，也执行上一步的操作。这一步就是在判断删除的是不是尾节点。</li>
<li>最后把待删除的节点设置为null，并更新size和modeCount。</li>
</ul>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p>ArrayList和LinkedList的遍历都是通用的。基本包括5种方式。</p>
<p><strong>耗时程度</strong>：<code>普通for循环 &gt; forEach循环 == stream流 &gt; 增强for循环 == iterator遍历</code></p>
<h4 id="普通for循环"><a href="#普通for循环" class="headerlink" title="普通for循环"></a>普通for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size(); i ++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer itr : list) &#123;</span><br><span class="line">    System.out.println(itr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="iterator遍历"><a href="#iterator遍历" class="headerlink" title="iterator遍历"></a>iterator遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">    System.out.println(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="forEach循环"><a href="#forEach循环" class="headerlink" title="forEach循环"></a>forEach循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(integer -&gt; &#123;</span><br><span class="line">    System.out.println(integer);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line">list.forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="stream流"><a href="#stream流" class="headerlink" title="stream流"></a>stream流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list.stream().forEach(integer -&gt; &#123;</span><br><span class="line">   System.out.println(integer); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line">list.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>程序开发种的数据结构可以分为8类：数组、链表、栈、队列、散列表、树、堆、图</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>ArrayList</td>
</tr>
<tr>
<td>链表</td>
<td>LinkedList</td>
</tr>
<tr>
<td>树</td>
<td>2-3树、红黑树</td>
</tr>
<tr>
<td>散列表</td>
<td>HashMap</td>
</tr>
<tr>
<td>栈</td>
<td>Stack</td>
</tr>
<tr>
<td>队列</td>
<td>Queue、Deque</td>
</tr>
</tbody>
</table>
</div>
<h2 id="栈Stack"><a href="#栈Stack" class="headerlink" title="栈Stack"></a>栈Stack</h2><blockquote>
<p>Stack栈是JDK1.0时代的，基于继承Vector实现的。<code>Stack</code>类已经不建议使用了。</p>
</blockquote>
<h3 id="源码学习-7"><a href="#源码学习-7" class="headerlink" title="源码学习"></a>源码学习</h3><p>以<code>push()</code>操作为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">push</span><span class="params">(E item)</span> &#123;</span><br><span class="line">    addElement(item);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addElement</span><span class="params">(E obj)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被抛弃的原因。</p>
<ul>
<li>Stack栈是JDK1.0时代的，基于继承Vector实现的。本身Vector就是一个不推荐使用的类。主要在于<strong>它的一些操作方法锁（synchronized）的力度太粗</strong>，都是放到方法上的。</li>
<li>Stack栈底层是使用Vector数组实现的。数组结构在元素添加和删除需要通过System.arraycopy，进行扩容操作。而栈本身的特点就是首尾元素的操作，也不需要遍历，使用数组结构其实不太理想。</li>
<li>推荐使用<code>Deque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;()</code>，虽然这也是数组结构，但是没有粗粒度的锁。同时可以申请指定空间并且在扩容时操作时也要优于 Stack 。并且它还是 一个双端队列，使用起来更灵活。</li>
</ul>
<h2 id="双端队列ArrayDeque"><a href="#双端队列ArrayDeque" class="headerlink" title="双端队列ArrayDeque"></a>双端队列ArrayDeque</h2><blockquote>
<p>ArrayDeque 是基于数组实现的可动态扩容的双端队列，也就是说你可以在队列的头和尾同时插入和弹出元素。当元素数量超过数组初始化长度时，则需要扩容和迁移数据。</p>
</blockquote>
<p>数据结构操作如下：</p>
<p><img src="21Underlying/image-20230405204836463.png" alt="image-20230405204836463"></p>
<p>从上图我们可以看出：</p>
<ul>
<li>双端队列是基于数组实现的，所以有扩容迁移数据操作</li>
<li>push是向队尾插入，offerLast是向队头插入，这样两端都满足后进先出。</li>
<li>整体来看，双端队列就是一个环形，所以扩容后继续插入元素也满足后进先出。</li>
</ul>
<h3 id="源码学习-8"><a href="#源码学习-8" class="headerlink" title="源码学习"></a>源码学习</h3><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><p>提供了多个初始化的构造函数，可以指定大小以及提供默认的元素。以<code>new ArrayDeque&lt;String&gt;(1)</code>为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSize</span><span class="params">(<span class="type">int</span> numElements)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">initialCapacity</span> <span class="operator">=</span> MIN_INITIAL_CAPACITY;</span><br><span class="line">    <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">    <span class="comment">// Tests &quot;&lt;=&quot; because arrays aren&#x27;t kept full.</span></span><br><span class="line">    <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">        initialCapacity = numElements;</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">        initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        initialCapacity++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> initialCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在初始化的过程中，他初始化数组的大小也是当前传输值最小的2的倍数，和HashMap底层初始化数组过程相似。</p>
<p>不同的是，如果不指定大小，则它提供的默认大小为8，HashMap提供的默认大小为16。</p>
<h3 id="数据入栈"><a href="#数据入栈" class="headerlink" title="数据入栈"></a>数据入栈</h3><p><code>deque.push(&quot;a&quot;)</code>，<code>ArrayDeque</code>提供了一个<code>push</code>方法，这个方法和<code>deque.offerFirst(&quot;a&quot;)</code>一致，底层源码都是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offerLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">    <span class="keyword">if</span> (head == tail)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    elements[tail] = e;</span><br><span class="line">    <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">        doubleCapacity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分入栈元素，其实就是给数组赋值，知识点如下：</p>
<ul>
<li><p>首先初始化时：head和tail指向数组第一个位置。例如：数组长度初始化为8时，则head = 0，tail = 0；换句话说，<strong>head指向队头元素，tail指向队尾元素的下一个位置。</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">length = 8</span><br><span class="line">// 头插定位</span><br><span class="line">(head - 1) &amp; (length - 1)</span><br><span class="line">(0 - 1) &amp; (8 - 1) = 7</span><br><span class="line">(7 - 1) &amp; (8 - 1) = 6</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// 尾插定位</span><br><span class="line">tail，插完需要更新 tail = (tail + 1) &amp; (length - 1)</span><br><span class="line">0 更新 tail = (0 + 1) &amp; (8 - 1) = 1</span><br><span class="line">1 更新 tail = (1 + 1) &amp; (8 - 1) = 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>addFirst()</code>中，定位下标，<code>head = (head - 1) &amp; (elements.length - 1)</code>，因为数组的长度是 <code>2^n</code>，所以<code>2^n - 1</code>就是一个全1的二进制数，可以用于运算得出数组小标。</p>
</li>
<li><p>在addLast()中，也使用了相同的定位方式，只不过是从0开始的。网上增加。</p>
</li>
<li><p>对满的判断条件是：<code>tail = (tail + 1) &amp; (elements.length - 1) == head</code>，队头和队尾是同一元素。对满则需要扩容，<code>doubleCapacity</code>函数。这里扩容的大小是原数组大小的2倍，和HashMap一样。</p>
</li>
</ul>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doubleCapacity</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> head == tail;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> elements.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> n - p; <span class="comment">// number of elements to the right of p</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> n &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Sorry, deque too big&quot;</span>);</span><br><span class="line">    Object[] a = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];</span><br><span class="line">    System.arraycopy(elements, p, a, <span class="number">0</span>, r);</span><br><span class="line">    System.arraycopy(elements, <span class="number">0</span>, a, r, p);</span><br><span class="line">    elements = a;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就可以清楚的看到新的容量是旧的容量的2倍：<code>newCapacity = n &lt;&lt; 1</code></p>
<h2 id="双端队列LinkedList"><a href="#双端队列LinkedList" class="headerlink" title="双端队列LinkedList"></a>双端队列LinkedList</h2><p>LinkedList天生就可以支持双端队列，而且从头尾取数据也是它时间复杂度O(1)的。同时数据的插入和删除也不需要像数组那样拷贝数据。虽然LinkedList有这些优点，但不能说ArrayDeque因为有数组复制就性能比它低。</p>
<h3 id="数据入栈-1"><a href="#数据入栈-1" class="headerlink" title="数据入栈"></a>数据入栈</h3><p><code>deque.push(&quot;a&quot;)</code>，<code>deque.offerFirst(&quot;a&quot;)</code>和<code>offerLast(&quot;e&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头插</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">linkFirst</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>, e, f);</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾插</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">linkLast</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(l, e, <span class="literal">null</span>);</span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>)</span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>linkFirst</code>和<code>linkLast</code>分别是给链表的首尾添加节点，是链表结构，所以不存在扩容。只需要把双向链路连接上即可。</li>
</ul>
<h2 id="延时队列DelayQueue"><a href="#延时队列DelayQueue" class="headerlink" title="延时队列DelayQueue"></a>延时队列DelayQueue</h2><blockquote>
<p>延时队列，可以通过设定存放时间，依次轮训获取。</p>
</blockquote>
<h1 id="Java-util-Collections"><a href="#Java-util-Collections" class="headerlink" title="Java.util.Collections"></a>Java.util.Collections</h1><blockquote>
<p>java.util.Collections，是java集合框架的一个工具类，主要用于Collection提供的通用算法；排序，二分查找，洗牌等算法操作。</p>
</blockquote>
<p>从数据结构到具体实现，再到算法，整体的结构如下图；</p>
<p><img src="21Underlying/image-20230405220120005.png" alt="image-20230405220120005"></p>
<h2 id="Collections-sort排序"><a href="#Collections-sort排序" class="headerlink" title="Collections.sort排序"></a>Collections.sort排序</h2><h3 id="初始化集合"><a href="#初始化集合" class="headerlink" title="初始化集合"></a>初始化集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;7&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;8&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;9&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="默认排序-正序"><a href="#默认排序-正序" class="headerlink" title="默认排序[正序]"></a>默认排序[正序]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list); <span class="comment">// 从小到大</span></span><br></pre></td></tr></table></figure>
<h3 id="Comparator排序"><a href="#Comparator排序" class="headerlink" title="Comparator排序"></a>Comparator排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String o1, String o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);  <span class="comment">// 从大到小</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Comparator还可以对对象按照某个字段进行排序。</li>
</ul>
<h3 id="reverseOrder倒排"><a href="#reverseOrder倒排" class="headerlink" title="reverseOrder倒排"></a>reverseOrder倒排</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, Collections.&lt;String&gt;reverseOrder());</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Collections.&lt;String&gt;reverseOrder()</code> 的源码部分就和我们上面把两个对比的类调换过来一样。<code>c2.compareTo(c1)</code>;</li>
</ul>
<h3 id="源码学习-9"><a href="#源码学习-9" class="headerlink" title="源码学习"></a>源码学习</h3><ul>
<li><code>Collections.sort()</code></li>
</ul>
<p><code>Collections.sort()</code>底层调用<code>List</code>接口中的<code>sort</code>方法，然后实现类是<code>Arrays</code>类中的<code>sort</code>函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections类中的sort函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">    list.sort(c);  <span class="comment">// List接口中的sort方法。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Arrays类中的sort函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        sort(a);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">            legacyMergeSort(a, c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这一部分排序逻辑包括了，旧版的归并排序<code>legacyMergeSort</code>和<code>TimSort</code>排序（优化后的归并排序）。</li>
<li>但因为开关的作用，<code>LegacyMergeSort.userRequested = false</code>,基本都是走到<code>TimSort</code>排序。</li>
<li>同时在排序的过程中还会因为元素的个数是否大于32，而选择<code>分段排序</code>和<code>二分插入排序</code>，</li>
</ul>
<h2 id="Collections-binarySearch二分查找"><a href="#Collections-binarySearch二分查找" class="headerlink" title="Collections.binarySearch二分查找"></a>Collections.binarySearch二分查找</h2><h3 id="源码学习-10"><a href="#源码学习-10" class="headerlink" title="源码学习"></a>源码学习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码可以看出：</p>
<ul>
<li>首先会对需要二分查找的list进行判断，这里有两个条件，<ul>
<li><code>list instanceof RandomAccess</code> 这个是用来判断list是ArrayList还是LinkedList，因为ArrayList实现了RandomAccess接口，但是LinkedList没有实现这个接口。</li>
<li><code>list.size() &lt; BINARYSEARCH_THRESHOLD</code> 使用来判断需要判断的list中元素的数量是否超过阈值。这里的阈值是5000。</li>
</ul>
</li>
<li>因此当需要进行查找的list是ArrayList或者list.size()不超过5000时，都会调用<code>indexedBinarySearch</code>进行查找。</li>
<li>否则就会调用<code>iteratorBinarySearch</code>进行查找。下面就分别学习这两个查找函数的源码。</li>
</ul>
<p><strong>indexedBinarySearch</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">indexedBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; midVal = list.get(mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个函数的源码可以看出，每次都是通过折半二分定位元素，耗时点就是在list.get(mid)。LinkedList相比于ArrayList更耗时。</p>
<p><strong>iteratorBinarySearch</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">iteratorBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="built_in">super</span> T&gt;&gt; list, T key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> list.size()-<span class="number">1</span>;</span><br><span class="line">    ListIterator&lt;? <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;? <span class="built_in">super</span> T&gt;&gt; i = list.listIterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="built_in">super</span> T&gt; midVal = get(i, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数是元素数量大于5000个，同时是LinkedList时，才会使用迭代器list.listIterator的方式进行二分查找操作。</p>
<h2 id="Collections-shuffle洗牌算法"><a href="#Collections-shuffle洗牌算法" class="headerlink" title="Collections.shuffle洗牌算法"></a>Collections.shuffle洗牌算法</h2><blockquote>
<p>洗牌算法，其实就是将list集合中的元素进行打乱，一般可以用在抽奖，摇号，洗牌等各个场景中。</p>
</blockquote>
<h3 id="功能使用"><a href="#功能使用" class="headerlink" title="功能使用"></a>功能使用</h3><ul>
<li>Collections.shuffle(list);</li>
<li>Collections.shuffle(list, 100); 100是随机种子控制洗牌范围。</li>
</ul>
<h3 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            <span class="comment">// 交换 i - 1 位置和随机的位置元素。</span></span><br><span class="line">            swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] arr = list.toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shuffle array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump array back into list</span></span><br><span class="line">        <span class="comment">// instead of using a raw type here, it&#x27;s possible to capture</span></span><br><span class="line">        <span class="comment">// the wildcard but it will require a call to a supplementary</span></span><br><span class="line">        <span class="comment">// private method</span></span><br><span class="line">        <span class="type">ListIterator</span> <span class="variable">it</span> <span class="operator">=</span> list.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这部分的代码逻辑主要是通过随机数从逐步缩小范围的集合中找到对应的元素，与递减的下标位置进行元素替换。整体的执行过成如下：</p>
<p><img src="21Underlying/image-20230406100828753.png" alt="image-20230406100828753"></p>
<h2 id="Collections-rotate旋转算法"><a href="#Collections-rotate旋转算法" class="headerlink" title="Collections.rotate旋转算法"></a>Collections.rotate旋转算法</h2><blockquote>
<p>旋转算法：可以把ArrayList 或者LinkedList，从指定的某个位置开始，进行正旋或者逆旋操作。</p>
<p>有点像把集合理解成圆盘，把要的元素找到自己这，其他的元素顺序跟随。</p>
</blockquote>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><code>Collection.rotate(list, 2);</code> 把list集合顺时针旋转2位。逆时针旋转为负数。</p>
<p><img src="21Underlying/image-20230406101912402.png" alt="image-20230406101912402"></p>
<h3 id="源码学习-11"><a href="#源码学习-11" class="headerlink" title="源码学习"></a>源码学习</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span><br><span class="line">        rotate1(list, distance);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rotate2(list, distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把旋转算法的实现分为两部分：</p>
<ul>
<li>list是ArrayList时或者元素数量不多时（不超过100），则通过rotate1实现。</li>
<li>如果时LinkedList并且元素数量超过100时，则通过rotate2实现。</li>
</ul>
<p><strong>rotate1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">rotate1</span><span class="params">(List&lt;T&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    distance = distance % size;  <span class="comment">// 获取旋转位置</span></span><br><span class="line">    <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)  <span class="comment">// 是负数，转为正数</span></span><br><span class="line">        distance += size;</span><br><span class="line">    <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cycleStart</span> <span class="operator">=</span> <span class="number">0</span>, nMoved = <span class="number">0</span>; nMoved != size; cycleStart++) &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">displaced</span> <span class="operator">=</span> list.get(cycleStart);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cycleStart;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i += distance;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                i -= size;</span><br><span class="line">            displaced = list.set(i, displaced);</span><br><span class="line">            nMoved ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != cycleStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>具体步骤，首先通过 distance = distance % size 获取旋转的位置。</p>
</li>
<li><p>for循环和dowhile，配合每次的旋转操作。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 上图实例</span><br><span class="line">i = 0， distance = 2</span><br><span class="line">下标：</span><br><span class="line">0 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; 3 -&gt; 0; do..while结束。此时onMoved 也刚好等于size，直接结束。</span><br></pre></td></tr></table></figure>
</li>
<li><p>最终list元素被循环替换完成</p>
</li>
</ul>
<p><strong>rotate2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rotate2</span><span class="params">(List&lt;?&gt; list, <span class="type">int</span> distance)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span>  -distance % size;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; <span class="number">0</span>)</span><br><span class="line">        mid += size;</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    reverse(list.subList(<span class="number">0</span>, mid));</span><br><span class="line">    reverse(list.subList(mid, size));</span><br><span class="line">    reverse(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要操作：</p>
<ul>
<li>定位拆链位置。<code>mid = -distance % size + size</code> 也即是我们要旋转后找到的元素位置。</li>
<li>第一次翻转，把从位置0到拆链位置</li>
<li>第二次翻转，把拆链位置到结尾</li>
<li>第三次翻转，翻转整个链表.</li>
</ul>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原链表 7 4 8 3 9</span><br><span class="line">旋转2位,distance = 2,因此计算得到mid = 3;</span><br><span class="line">1.翻转0 ~ 3 =&gt;  8 4 7 3 9</span><br><span class="line">2.翻转3 ~ 4 =&gt;  8 4 7 9 3</span><br><span class="line">3.翻转整个链表 =&gt; 3 9 7 4 8</span><br><span class="line">至此实现了向右循环两位的操作.</span><br></pre></td></tr></table></figure>
<p><img src="21Underlying/image-20230406102918322.png" alt="image-20230406102918322"></p>
<h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><ul>
<li>Collections.min(list);</li>
<li>Collections.max(list);</li>
</ul>
<h3 id="元素替换"><a href="#元素替换" class="headerlink" title="元素替换"></a>元素替换</h3><ul>
<li>Collections.replaceAll(list, oldValue, newValue);</li>
</ul>
<h3 id="连续集合位置判断"><a href="#连续集合位置判断" class="headerlink" title="连续集合位置判断"></a>连续集合位置判断</h3><ul>
<li>int idx = Collections.indexOfSubList(list, Arrays.asList(“8”, “3”))</li>
</ul>
<p>找到第一次出现的位置.</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h1 id="StringBuilder和String对比"><a href="#StringBuilder和String对比" class="headerlink" title="StringBuilder和String对比"></a>StringBuilder和String对比</h1><h2 id="StringBuilder比String快"><a href="#StringBuilder比String快" class="headerlink" title="StringBuilder比String快?"></a>StringBuilder比String快?</h2><p>String进行<code>+</code>拼接的时候会被优化成StringBuilder,但是还是会很慢,原因是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i ++) </span><br><span class="line">    str += i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层实现</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i ++) &#123;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str).append(i).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次循环都会实例化一次StringBuilder。所以非常耗时。这样和字符串直接连接是一样的。</p>
<h2 id="String源码分析"><a href="#String源码分析" class="headerlink" title="String源码分析"></a>String源码分析</h2><h3 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h3><p>因为String底层结构是数组char value[]，所以它的初始化方式也会有很多跟数组相关的，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面都是&quot;abc&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>&#125;, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0x61</span>, <span class="number">0x62</span>, <span class="number">0x63</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p><code>s.charAt(0)</code>，可以从查找的源码中看出String底层就是一个char数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不可变final"><a href="#不可变final" class="headerlink" title="不可变final"></a>不可变final</h3><p>从源码中可以看到，String类和用于存放字符串的数组都用了 final 修饰，也就是创建了以后，这些都是不可变的。</p>
<p>字符串拼接也是重新创建了新的对象进行赋值的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>
<h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>底层使用<code>native</code>进行修饰，说明<code>intern()</code>是一个本地方法，底层通过JNI调用C++语言编写功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);  <span class="comment">// false</span></span><br><span class="line">System.out.println(str1 == str2.intern());  <span class="comment">// false</span></span><br><span class="line">System.out.println(str1.intern() == str2.intern());  <span class="comment">// true;</span></span><br><span class="line">System.out.println(str1 == str3);  <span class="comment">// false</span></span><br><span class="line">System.out.println(str1.intern() == str3);  <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>
<p>图解：</p>
<p><img src="21Underlying/image-20230406110106223.png" alt="image-20230406110106223"></p>
<h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><ul>
<li><code>==</code>，用在基础类型之间比较的是值，用在引用类型之间比对的是地址。另外equal比对的是哈希值。</li>
<li>两个new出来的对象，地址肯定不同，所以是false；</li>
<li>intern()，直接把值推进了常量池，所以两个对象都做了intern()操作后，比对的是常量池中的值。</li>
<li><code>str = &quot;abc&quot;</code>，JVM编译器做了优化，不会重新创建对象，直接引用常量池里的值。</li>
</ul>
<h2 id="StringBuilder源码分析"><a href="#StringBuilder源码分析" class="headerlink" title="StringBuilder源码分析"></a>StringBuilder源码分析</h2><h3 id="初始化-4"><a href="#初始化-4" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这几种方式都可以初始化，可以传一个初始化容量，也可以传一个默认的字符串。</p>
<h4 id="源码学习-12"><a href="#源码学习-12" class="headerlink" title="源码学习"></a>源码学习</h4><p>默认初始容量是16，就是初始化数组，和ArrayList类似。只不过这里的是字符数组。ArrayList可以是任意类型数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="type">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="title class_">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p><code>str.append(&quot;abc&quot;);</code></p>
<p>入口方法-源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AbstractStringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length();</span><br><span class="line">    <span class="comment">// 容量检测，如果加上待加入的字符串的长度后超过容量，需要扩容。</span></span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是<code>public final class StringBuilder extends AbstractStringBuilder</code>的父类和<code>StringBuilder</code>公用这个方法。</p>
<ul>
<li>这个方法包括了容量检测、元素拷贝、记录count数量。</li>
</ul>
<h4 id="扩容方法"><a href="#扩容方法" class="headerlink" title="扩容方法"></a>扩容方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minimumCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                              newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">newCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>操作和数组的原理一样，都需要检测容量大小，如果不够则需要扩容，扩容的容量是 <code>n * 2 + 2</code>。然后扩容后将原有元素拷贝到新数组中。</li>
</ul>
<h3 id="填充元素"><a href="#填充元素" class="headerlink" title="填充元素"></a>填充元素</h3><p><code>str.getChars(0, len, value, count);</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getChars</span><span class="params">(<span class="type">int</span> srcBegin, <span class="type">int</span> srcEnd, <span class="type">char</span>[] dst, <span class="type">int</span> dstBegin)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(srcBegin);</span><br><span class="line">    <span class="keyword">if</span> ((srcEnd &lt; <span class="number">0</span>) || (srcEnd &gt; count))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(srcEnd);</span><br><span class="line">    <span class="keyword">if</span> (srcBegin &gt; srcEnd)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(<span class="string">&quot;srcBegin &gt; srcEnd&quot;</span>);</span><br><span class="line">    System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加元素的方式是基于<code>System.arraycopy</code>拷贝操作进行的，这是一个本地方法</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a copy, don&#x27;t share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>toString()底层实现就是通过调用String的构造函数传递数组进行转换的。</p>
<h2 id="StringBuffer源码分析"><a href="#StringBuffer源码分析" class="headerlink" title="StringBuffer源码分析"></a>StringBuffer源码分析</h2><blockquote>
<p>StringBuffer 和 StringBuilder API的使用和底层实现基本一致，不同的是StringBuffer加了synchronized锁，所以它是线程安全的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    toStringCache = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="String常用API"><a href="#String常用API" class="headerlink" title="String常用API"></a>String常用API</h2><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>str.concat(“cde”)</td>
<td>字符串连接，替换+号</td>
</tr>
<tr>
<td>2</td>
<td>str.length()</td>
<td>获取字符串长度</td>
</tr>
<tr>
<td>3</td>
<td>str.isEmpty()</td>
<td>判断是否为空</td>
</tr>
<tr>
<td>4</td>
<td>str.charAt(index)</td>
<td>获取指定位置的值</td>
</tr>
<tr>
<td>5</td>
<td>str.codePointAt(index)</td>
<td>获取指定位置元素，并返回ascii码值</td>
</tr>
<tr>
<td>6</td>
<td>str.equals(“abc”)</td>
<td>比较</td>
</tr>
<tr>
<td>7</td>
<td>str.equalsIgnoreCase(“Abc”)</td>
<td>忽略大小写，比较</td>
</tr>
<tr>
<td>8</td>
<td>str.substring(beginIndex, endIndex)</td>
<td>截取[beginIndex, endIndex)</td>
</tr>
<tr>
<td>9</td>
<td>str.trim()</td>
<td>格式化，首尾去空格</td>
</tr>
<tr>
<td>10</td>
<td>str.split(“#”)</td>
<td>拆分，可以支持正则</td>
</tr>
<tr>
<td>11</td>
<td>str.toCharArray()</td>
<td>转数组</td>
</tr>
</tbody>
</table>
</div>
<h1 id="ThreadLocal源码分析❗"><a href="#ThreadLocal源码分析❗" class="headerlink" title="ThreadLocal源码分析❗"></a>ThreadLocal源码分析❗</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Atopos·</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/04/04/JAVA/21Underlying/">http://example.com/2023/04/04/JAVA/21Underlying/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Atopos's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JAVA/">JAVA</a></div><div class="post_share"><div class="social-share" data-image="/../../img/Review.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/06/JAVA/22Underlying/"><img class="prev-cover" src="/../../img/Review.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">锁</div></div></a></div><div class="next-post pull-right"><a href="/2023/03/30/JAVA/20ReviewNotes/"><img class="next-cover" src="/../../img/Review.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">复习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/09/24/JAVA/00Thread/" title="Java 多线程与高并发练习"><img class="cover" src="/../../img/Java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-24</div><div class="title">Java 多线程与高并发练习</div></div></a></div><div><a href="/2022/05/01/JAVA/03JavaBasic/" title="Java 基础入门 Java8"><img class="cover" src="/../../img/Java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">Java 基础入门 Java8</div></div></a></div><div><a href="/2022/04/18/JAVA/01JavaBasic/" title="Java 基础入门 阶段1 & 阶段2"><img class="cover" src="/../../img/Java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-18</div><div class="title">Java 基础入门 阶段1 & 阶段2</div></div></a></div><div><a href="/2022/04/18/JAVA/02JavaBasic/" title="Java 基础入门 阶段3"><img class="cover" src="/../../img/Java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-18</div><div class="title">Java 基础入门 阶段3</div></div></a></div><div><a href="/2022/06/06/JAVA/04JavaMySQL/" title="Java 企业开发基础 MySQL"><img class="cover" src="/../../img/Java.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-06</div><div class="title">Java 企业开发基础 MySQL</div></div></a></div><div><a href="/2022/09/25/JAVA/05JavaWeb/" title="Java 企业开发基础 JavaWeb"><img class="cover" src="/../../img/JavaWeb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-25</div><div class="title">Java 企业开发基础 JavaWeb</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Atopos·</div><div class="author-info__description">看得懂的书,请仔细看;看不懂的书,请硬着头皮看!</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">88</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">57</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Xzt-hub"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/aaaatopos" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xzt2520@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">学习使用新博客</div></div><div class="sticky_clock"></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.</span> <span class="toc-text">HashMap源码学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.</span> <span class="toc-text">散列表实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">需要注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">简单实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="toc-number">1.1.3.</span> <span class="toc-text">测试结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">存在的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">扰动函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.2.1.</span> <span class="toc-text">原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">HashMap底层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">计算方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">初始化容量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90"><span class="toc-number">1.4.</span> <span class="toc-text">负载因子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">底层实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E5%85%83%E7%B4%A0%E6%8B%86%E5%88%86"><span class="toc-number">1.5.</span> <span class="toc-text">扩容元素拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E5%90%8E%E6%96%B0%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">拆分后新的位置的计算方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">1.6.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.6.1.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.6.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.6.3.</span> <span class="toc-text">源码学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.4.</span> <span class="toc-text">扩容机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%97%B6%E6%9C%BA"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">扩容时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-1"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">源码学习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%A0%91%E5%8C%96"><span class="toc-number">1.6.5.</span> <span class="toc-text">链表树化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-2"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">源码学习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%BD%AC%E9%93%BE"><span class="toc-number">1.6.6.</span> <span class="toc-text">红黑树转链</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-3"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">源码学习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-4"><span class="toc-number">1.7.2.</span> <span class="toc-text">源码学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-1"><span class="toc-number">1.7.3.</span> <span class="toc-text">知识点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.8.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-5"><span class="toc-number">1.8.1.</span> <span class="toc-text">源码学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">1.9.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-3%E6%A0%91%E4%B8%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AD%A6%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">2-3树与红黑树学习</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">为什么使用树结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E6%A0%91%E8%A7%A3%E5%86%B3%E5%B9%B3%E8%A1%A1%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.</span> <span class="toc-text">2-3树解决平衡问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">数据插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.3.</span> <span class="toc-text">数据删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">数据索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E6%A0%91%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">2-3树转红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E8%A7%84%E5%88%99"><span class="toc-number">2.3.1.</span> <span class="toc-text">红黑树规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E6%A0%91%E5%92%8C%E7%BA%A2%E9%BB%91%E6%A0%91%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.2.</span> <span class="toc-text">2-3树和红黑树关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E6%A0%91%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91-1"><span class="toc-number">2.3.3.</span> <span class="toc-text">2-3树转红黑树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.1.</span> <span class="toc-text">平衡操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B%E8%BD%AC"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">左旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B%E8%BD%AC"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">右旋转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E6%97%8B%E8%BD%AC%E7%BB%BC%E5%90%88"><span class="toc-number">2.4.1.3.</span> <span class="toc-text">左右旋转综合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%93%E8%89%B2"><span class="toc-number">2.4.2.</span> <span class="toc-text">染色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC-%E6%9F%93%E8%89%B2%E8%BF%90%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">2.4.3.</span> <span class="toc-text">旋转+染色运用案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">2.4.4.</span> <span class="toc-text">删除操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ArrayList"><span class="toc-number">3.</span> <span class="toc-text">ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%8F%92%E5%85%A5"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">普通插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%97%B6%E6%89%A9%E5%AE%B9"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">插入时扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">指定位置插入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-number">3.2.3.</span> <span class="toc-text">删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LinkedList"><span class="toc-number">4.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="toc-number">4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-6"><span class="toc-number">4.2.</span> <span class="toc-text">源码学习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">4.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-2"><span class="toc-number">4.2.2.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%8F%92"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">头插</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%8F%92"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">尾插</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E6%8F%92"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">中间插</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-2"><span class="toc-number">4.2.3.</span> <span class="toc-text">删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">删除操作的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-1"><span class="toc-number">4.2.4.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%80%9Afor%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">普通for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">增强for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iterator%E9%81%8D%E5%8E%86"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">iterator遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forEach%E5%BE%AA%E7%8E%AF"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">forEach循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stream%E6%B5%81"><span class="toc-number">4.2.4.5.</span> <span class="toc-text">stream流</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88Stack"><span class="toc-number">5.1.</span> <span class="toc-text">栈Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-7"><span class="toc-number">5.1.1.</span> <span class="toc-text">源码学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97ArrayDeque"><span class="toc-number">5.2.</span> <span class="toc-text">双端队列ArrayDeque</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-8"><span class="toc-number">5.2.1.</span> <span class="toc-text">源码学习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">5.2.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%A5%E6%A0%88"><span class="toc-number">5.2.3.</span> <span class="toc-text">数据入栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9"><span class="toc-number">5.2.4.</span> <span class="toc-text">扩容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97LinkedList"><span class="toc-number">5.3.</span> <span class="toc-text">双端队列LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%A5%E6%A0%88-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">数据入栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97DelayQueue"><span class="toc-number">5.4.</span> <span class="toc-text">延时队列DelayQueue</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-util-Collections"><span class="toc-number">6.</span> <span class="toc-text">Java.util.Collections</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections-sort%E6%8E%92%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">Collections.sort排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%9B%86%E5%90%88"><span class="toc-number">6.1.1.</span> <span class="toc-text">初始化集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%8E%92%E5%BA%8F-%E6%AD%A3%E5%BA%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">默认排序[正序]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Comparator%E6%8E%92%E5%BA%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">Comparator排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reverseOrder%E5%80%92%E6%8E%92"><span class="toc-number">6.1.4.</span> <span class="toc-text">reverseOrder倒排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-9"><span class="toc-number">6.1.5.</span> <span class="toc-text">源码学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections-binarySearch%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">6.2.</span> <span class="toc-text">Collections.binarySearch二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-10"><span class="toc-number">6.2.1.</span> <span class="toc-text">源码学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections-shuffle%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">Collections.shuffle洗牌算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8"><span class="toc-number">6.3.1.</span> <span class="toc-text">功能使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">6.3.2.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections-rotate%E6%97%8B%E8%BD%AC%E7%AE%97%E6%B3%95"><span class="toc-number">6.4.</span> <span class="toc-text">Collections.rotate旋转算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.4.1.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-11"><span class="toc-number">6.4.2.</span> <span class="toc-text">源码学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96API"><span class="toc-number">6.5.</span> <span class="toc-text">其他API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">6.5.1.</span> <span class="toc-text">最大最小值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%9B%BF%E6%8D%A2"><span class="toc-number">6.5.2.</span> <span class="toc-text">元素替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E9%9B%86%E5%90%88%E4%BD%8D%E7%BD%AE%E5%88%A4%E6%96%AD"><span class="toc-number">6.5.3.</span> <span class="toc-text">连续集合位置判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-number">6.5.4.</span> <span class="toc-text">synchronized</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringBuilder%E5%92%8CString%E5%AF%B9%E6%AF%94"><span class="toc-number">7.</span> <span class="toc-text">StringBuilder和String对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder%E6%AF%94String%E5%BF%AB"><span class="toc-number">7.1.</span> <span class="toc-text">StringBuilder比String快?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.2.</span> <span class="toc-text">String源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="toc-number">7.2.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE-1"><span class="toc-number">7.2.2.</span> <span class="toc-text">查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98final"><span class="toc-number">7.2.3.</span> <span class="toc-text">不可变final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#intern"><span class="toc-number">7.2.4.</span> <span class="toc-text">intern()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%A4%84"><span class="toc-number">7.2.4.1.</span> <span class="toc-text">用处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-2"><span class="toc-number">7.2.4.2.</span> <span class="toc-text">知识点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.3.</span> <span class="toc-text">StringBuilder源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-4"><span class="toc-number">7.3.1.</span> <span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0-12"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">源码学习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="toc-number">7.3.2.</span> <span class="toc-text">添加元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">扩容方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A1%AB%E5%85%85%E5%85%83%E7%B4%A0"><span class="toc-number">7.3.3.</span> <span class="toc-text">填充元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-NaN"><span class="toc-number">7.3.4.</span> <span class="toc-text">toString()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuffer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.4.</span> <span class="toc-text">StringBuffer源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%B8%B8%E7%94%A8API"><span class="toc-number">7.5.</span> <span class="toc-text">String常用API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E2%9D%97"><span class="toc-number">8.</span> <span class="toc-text">ThreadLocal源码分析❗</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/06/JAVA/22Underlying/" title="锁"><img src="/../../img/Review.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="锁"/></a><div class="content"><a class="title" href="/2023/04/06/JAVA/22Underlying/" title="锁">锁</a><time datetime="2023-04-06T00:02:25.000Z" title="发表于 2023-04-06 08:02:25">2023-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/04/JAVA/21Underlying/" title="源码学习"><img src="/../../img/Review.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="源码学习"/></a><div class="content"><a class="title" href="/2023/04/04/JAVA/21Underlying/" title="源码学习">源码学习</a><time datetime="2023-04-04T00:02:25.000Z" title="发表于 2023-04-04 08:02:25">2023-04-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/30/JAVA/20ReviewNotes/" title="复习笔记"><img src="/../../img/Review.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="复习笔记"/></a><div class="content"><a class="title" href="/2023/03/30/JAVA/20ReviewNotes/" title="复习笔记">复习笔记</a><time datetime="2023-03-30T00:02:25.000Z" title="发表于 2023-03-30 08:02:25">2023-03-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/29/AcWing/SpringBoot/07Course/" title="AcWing SpringBoot项目实战07"><img src="https://cdn.acwing.com/media/activity/surface/springbootlesson.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AcWing SpringBoot项目实战07"/></a><div class="content"><a class="title" href="/2023/03/29/AcWing/SpringBoot/07Course/" title="AcWing SpringBoot项目实战07">AcWing SpringBoot项目实战07</a><time datetime="2023-03-29T02:23:23.000Z" title="发表于 2023-03-29 10:23:23">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/27/Question/StrangeQuestion/" title="奇怪的问题&amp;解决方法"><img src="/../../img/problem.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="奇怪的问题&amp;解决方法"/></a><div class="content"><a class="title" href="/2023/03/27/Question/StrangeQuestion/" title="奇怪的问题&amp;解决方法">奇怪的问题&amp;解决方法</a><time datetime="2023-03-27T08:34:29.000Z" title="发表于 2023-03-27 16:34:29">2023-03-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Atopos·</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_clock')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="/./img/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>