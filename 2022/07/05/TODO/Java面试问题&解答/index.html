<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="记录复习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java面试问题&amp;解答">
<meta property="og:url" content="http://example.com/2022/07/05/TODO/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&%E8%A7%A3%E7%AD%94/index.html">
<meta property="og:site_name" content="Atopos&#39;s Blog">
<meta property="og:description" content="记录复习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/shallow&amp;deep-copy.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/java7_concurrenthashmap.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/java8_concurrenthashmap.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/JVM">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/lifecycle-of-a-class.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/class-loader-parents-delegation-model.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/20210226133909692.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/hotspot-heap-structure.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/mark-and-sweep-garbage-collection-algorithm.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/copying-garbage-collection-algorithm.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/mark-and-compact-garbage-collection-algorithm.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/object-circular-reference.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/jvm-gc-roots.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/java-runtime-data-areas-jdk1.8.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/2019-4%E6%AD%BB%E9%94%811.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/application-layer-protocol.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/transport-layer-protocol.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/nerwork-layer-protocol-040eb203.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/tcp-shakes-hands-three-times.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/tcp-waves-four-times.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/format,png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/format2,png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/http1.0-vs-http1.1.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/http1.1-vs-http2.0.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/http2.0-vs-http3.0.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/state-transition-of-process.png">
<meta property="og:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/scheduling-algorithms-of-process.png">
<meta property="article:published_time" content="2022-07-05T00:02:25.000Z">
<meta property="article:modified_time" content="2023-07-10T01:48:45.321Z">
<meta property="article:author" content="Atopos·">
<meta property="article:tag" content="JAVA">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="计算机网络">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&amp;%E8%A7%A3%E7%AD%94/shallow&amp;deep-copy.png">

<link rel="canonical" href="http://example.com/2022/07/05/TODO/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&%E8%A7%A3%E7%AD%94/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" href="https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css">
  <title>Java面试问题&解答 | Atopos's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Atopos's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">One step at a time!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">92</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/05/TODO/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&%E8%A7%A3%E7%AD%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/./img/head.jpg">
      <meta itemprop="name" content="Atopos·">
      <meta itemprop="description" content="看得懂的书,请仔细看;看不懂的书,请硬着头皮看!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Atopos's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java面试问题&解答
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-05 08:02:25" itemprop="dateCreated datePublished" datetime="2022-07-05T08:02:25+08:00">2022-07-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-07-10 09:48:45" itemprop="dateModified" datetime="2023-07-10T09:48:45+08:00">2023-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ReviewNotes/" itemprop="url" rel="index"><span itemprop="name">ReviewNotes</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>33k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>30 分钟</span>
            </span>
            <div class="post-description">记录复习笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="Java中的集中基本数据类是什么？对应的包装类型是什么？各自占用多少字节？"><a href="#Java中的集中基本数据类是什么？对应的包装类型是什么？各自占用多少字节？" class="headerlink" title="Java中的集中基本数据类是什么？对应的包装类型是什么？各自占用多少字节？"></a>Java中的集中基本数据类是什么？对应的包装类型是什么？各自占用多少字节？</h3><div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
<th>占用字节</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>byte</code></td>
<td><code>Byte</code></td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td><code>short</code></td>
<td><code>Short</code></td>
<td>2</td>
<td>0</td>
</tr>
<tr>
<td><code>int</code></td>
<td><code>Integer</code></td>
<td>4</td>
<td>0</td>
</tr>
<tr>
<td><code>long</code></td>
<td><code>Long</code></td>
<td>8</td>
<td>0L</td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>Character</code></td>
<td>2</td>
<td><code>&#39;u0000&#39;</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>Float</code></td>
<td>4</td>
<td>0f</td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>Double</code></td>
<td>8</td>
<td>od</td>
</tr>
<tr>
<td><code>boolean</code></td>
<td><code>Boolean</code></td>
<td>1</td>
<td><code>false</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="String、StringBuilder、StringBuffer的区别是什么？"><a href="#String、StringBuilder、StringBuffer的区别是什么？" class="headerlink" title="String、StringBuilder、StringBuffer的区别是什么？"></a><code>String</code>、<code>StringBuilder</code>、<code>StringBuffer</code>的区别是什么？</h3><ul>
<li><code>String</code>是<strong>不可变字符串</strong>，因为<code>String</code>类和底层实现的<code>char</code>数组都用<code>final</code>关键词进行修饰，一旦确定后就不能进行改变了。</li>
<li><code>StringBuilder</code>和<code>StringBuffer</code>是<strong>可变长字符串</strong>，都继承自<code>AbstractStringBuilder</code>类。可以通过<code>append</code>、<code>insert</code>函数进行字符串修改。<strong>不同的是</strong>：<code>StringBuilder</code>不是线程安全的，而<code>StringBuffer</code>是线程安全的（对方法加了同步锁），因此<code>StringBuilder</code>效率更高一点。</li>
</ul>
<h3 id="String-s1-new-String-quot-abc-quot-这段代码创建了几个字符串对象？"><a href="#String-s1-new-String-quot-abc-quot-这段代码创建了几个字符串对象？" class="headerlink" title="String s1 = new String(&quot;abc&quot;);这段代码创建了几个字符串对象？"></a><code>String s1 = new String(&quot;abc&quot;);</code>这段代码创建了几个字符串对象？</h3><p><strong>会创建1或2个字符串对象</strong></p>
<ul>
<li>如果字符串常量池中不存在字符串对象”abc”的引用，那么它将首先<strong>在字符串常量池中创建</strong>，然后<strong>在堆空间中创建</strong>，因此将创建总共2个字符串对象。</li>
<li>如果字符串常量池中已经存在字符串对象“abc”的引用，则只会在堆中创建一个字符串对象”abc”</li>
</ul>
<h3 id="和equals的区别？"><a href="#和equals的区别？" class="headerlink" title="==和equals的区别？"></a><code>==</code>和<code>equals</code>的区别？</h3><p><code>==</code>对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code>比较的是值</li>
<li>对于引用数据类型来说，<code>==</code>比较的是对象的内存地址</li>
</ul>
<blockquote>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</blockquote>
<p><code>equals</code>不能用于判断基本类型的变量，只能用来判断两个对象是否相等。<code>equals</code>方法存在于<code>Object</code>类中，因此所有的类都有<code>equals</code>方法。</p>
<ul>
<li><p>当类没有重写<code>equals</code>方法时：使用<code>equals</code>比较两个对象，相当于使用<code>==</code>比较两个对象。使用的是默认<code>Object</code>类中的<code>equals</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object 类中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当前类重写了<code>equals</code>方法，一般我们都重写<code>equals</code>方法来比较两个类中的某些属性是否相等，如果相等就返回<code>true</code>。</p>
</li>
</ul>
<h3 id="hashCode和equals的关系？"><a href="#hashCode和equals的关系？" class="headerlink" title="hashCode和equals的关系？"></a><code>hashCode</code>和<code>equals</code>的关系？</h3><p><code>hashCode</code>的作用是获取哈希码（<code>int</code>整数），也称散列码，这个哈希码的作用是确定该对象在哈希表中的索引位置。</p>
<p>一般我们在重写<code>equals</code>方法时必须重写<code>hashCode</code>方法，原因是：</p>
<p>两个相等的对象的<code>hashCode</code>值必须是相等。也就是说如果<code>equals</code>方法判断两个对象是相等的，那这两个对象的<code>hashCode</code>值也要相等。</p>
<p><strong>总结：</strong></p>
<ul>
<li><code>equals</code>方法判断两个对象是相等的，那这两个对象的<code>hashCode</code>值也要相等。</li>
<li>两个对象有相同的<code>hashCode</code>值，他们也不一定是相等的（哈希碰撞）。</li>
</ul>
<h3 id="包装类型的缓存机制？"><a href="#包装类型的缓存机制？" class="headerlink" title="包装类型的缓存机制？"></a>包装类型的缓存机制？</h3><p>Java 基本数据类型的包装类型的大部分都用到了<strong>缓存机制</strong>来提升性能。</p>
<p><code>Byte</code>、<code>Short</code>、<code>Integer</code>和<code>Long</code>这4种包装类型默认创建了数值<code>[-128, 127]</code>的相应类型的缓存数据。<code>Character</code>创建了数值在<code>[0, 127]</code>范围的缓存数据，<code>Boolean</code>直接返回<code>True</code>or<code>False</code></p>
<p>示例：为什么结果输出<code>false</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1 == i2);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>Integer i1 = 40;</code>发生装箱，等价于<code>Integer i1 = Integer.valueOf(40)</code>。因此<code>i1</code>直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40);</code>会直接创建新的对象。所以<code>i1</code>和<code>i2</code>是两个不同的对象，结果返回<code>false</code>。</p>
<h3 id="自动装箱与拆箱了解吗？原理是什么？"><a href="#自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="自动装箱与拆箱了解吗？原理是什么？"></a>自动装箱与拆箱了解吗？原理是什么？</h3><ul>
<li>装箱：将基本类型用它们对应的引用类型包装起来。原理是调用包装类的<code>valueOf()</code>方法。</li>
<li>拆箱：将包装类型转换为基本数据类型。原理是调用包装类的<code>xxxValue()</code>方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 装箱，等价于 Integer i = Integer.valueOf(10);</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i; <span class="comment">// 拆箱， 等价于 int n = i.intValue();</span></span><br></pre></td></tr></table></figure>
<p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>
<h3 id="深拷贝和浅拷贝的区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝的区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝的区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝的区别了解吗？什么是引用拷贝？</h3><ul>
<li>浅拷贝：会在堆上创建一个新的对象（区别引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li>
<li>深拷贝：会完全复制整个对象，包括这个对象所包含的内部对象。</li>
<li>引用拷贝：就是两个不同的引用指向同一对象。</li>
</ul>
<p><img src="/img/Java面试问题&amp;解答/shallow&amp;deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p>
<h3 id="谈谈对Java注解的理解，解决了什么问题？❗"><a href="#谈谈对Java注解的理解，解决了什么问题？❗" class="headerlink" title="谈谈对Java注解的理解，解决了什么问题？❗"></a>谈谈对Java注解的理解，解决了什么问题？❗</h3><p><code>Annotation</code>（注解）是Java5开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p>
<p>注解本质是一个继承了<code>Annotation</code>的特殊接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Override</span> <span class="keyword">extends</span> <span class="title class_">Annotation</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exception和Error有什么区别？"><a href="#Exception和Error有什么区别？" class="headerlink" title="Exception和Error有什么区别？"></a><code>Exception</code>和<code>Error</code>有什么区别？</h3><p>在Java中，所有的异常都有一个共同的祖先<code>java.lang</code>包中的<code>Throwable</code>类，<code>Throwable</code>有两个重要的子类：</p>
<ul>
<li><p><code>Exception</code>：程序本身可以处理的异常。可以通过<code>catch</code>进行捕获。<code>Exception</code>又可以分为两类：</p>
<ul>
<li><p><code>Checked Exception</code>：受检查异常，Java代码在<strong>编译</strong>过程中，如果受检查异常没有被<code>catch</code>或者<code>throws</code>关键字处理的话，就没办法通过编译。</p>
<p>例如：<code>int i = 10 / 0;</code>如果不使用<code>catch</code>或者<code>throws</code>关键字进行处理则无法通过编译。</p>
</li>
<li><p><code>Unchecked Exception</code>：不受检查异常，Java代码在编译过程中吗，我们即使不处理不受检查异常也可以正常通过编译。</p>
</li>
</ul>
</li>
<li><p><code>Error</code>：程序无法处理的错误。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
</li>
</ul>
<h3 id="Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？❗"><a href="#Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？❗" class="headerlink" title="Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？❗"></a>Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？❗</h3><p>Java反射赋予了我们在运行时分析类以及执行类中方法的能力。通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。</p>
<ul>
<li>优点：让代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</li>
<li>缺点：存在安全问题，例如无视泛型参数的安全检查。性能较差。</li>
</ul>
<p>使用反射后，增加了程序的灵活性，避免将代码写死，降低了耦合性。</p>
<h3 id="Java泛型了解吗？什么是类型擦除？介绍一下常用的通配符？❗"><a href="#Java泛型了解吗？什么是类型擦除？介绍一下常用的通配符？❗" class="headerlink" title="Java泛型了解吗？什么是类型擦除？介绍一下常用的通配符？❗"></a>Java泛型了解吗？什么是类型擦除？介绍一下常用的通配符？❗</h3><p><a target="_blank" rel="noopener" href="https://www.yuque.com/snailclimb/mf2z3k/ipqccd#acb25cb7"> 参考文档 </a></p>
<p>泛型：是JDK5中引入的一个新特性，使用泛型参数，可以增强代码的可读性以及稳定性。</p>
<p>泛型一般有三种使用方式：泛型类、泛型接口、泛型方法。</p>
<h4 id="泛型擦除机制"><a href="#泛型擦除机制" class="headerlink" title="泛型擦除机制"></a>泛型擦除机制</h4><p>Java的泛型是伪泛型，因为Java在编译期间，所有的泛型信息都会被擦掉，这也就是通常所说的类型擦除。</p>
<p>编译期间会动态的将泛型<code>T</code>擦除为<code>Object</code>，或者将<code>T extends xxx</code>擦除为其限定类型<code>xxx</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;String&gt; list)</span> &#123; <span class="comment">// 因为下面“重写”，所以报错</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原因是：泛型擦除后，<code>List&lt;String&gt;</code>和<code>List&lt;Integer&gt;</code>在编译以后都变成了<code>List&lt;Object&gt;</code>。因此会报错。</p>
<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>泛型类型是固定的，某些场景下使用起来不太灵活，于是通配符就来了！通配符可以允许类型参数变化，用来解决泛型无法协变的问题。</p>
<h5 id="通配符-和常用的泛型T有什么区别？"><a href="#通配符-和常用的泛型T有什么区别？" class="headerlink" title="通配符?和常用的泛型T有什么区别？"></a>通配符<code>?</code>和常用的泛型<code>T</code>有什么区别？</h5><ul>
<li><code>T</code>可以用于声明变量或常量，<code>?</code>不行</li>
<li><code>T</code>一般用于声明泛型类或方法，通配符<code>?</code>一般用于泛型方法的调用代码或形参。</li>
<li><code>T</code>在编译期会被擦除为限定类型或<code>Object</code>，通配符用于捕获具体类型。</li>
</ul>
<h5 id="上边界通配符extends"><a href="#上边界通配符extends" class="headerlink" title="上边界通配符extends"></a>上边界通配符<code>extends</code></h5><p><code>List&lt;? extends Person&gt;</code>限制必须是<code>Person</code>的子类。</p>
<h5 id="下边界通配符super"><a href="#下边界通配符super" class="headerlink" title="下边界通配符super"></a>下边界通配符<code>super</code></h5><p><code>LIst&lt;? super Employee&gt;</code>限制必须是<code>Employee</code>的父类。</p>
<h5 id="extends-xxx和-super-xxx的区别？"><a href="#extends-xxx和-super-xxx的区别？" class="headerlink" title="? extends xxx和? super xxx的区别？"></a><code>? extends xxx</code>和<code>? super xxx</code>的区别？</h5><p>两者接收参数的范围不同。</p>
<ul>
<li><code>? extends xxx</code>声明的泛型参数只能调用<code>get()</code>方法返回<code>xxx</code>类型，调用<code>set()</code>报错。</li>
<li><code>? super xxx</code>声明的泛型参数只能调用<code>set()</code>接收<code>xxx</code>类型，调用<code>get()</code>报错。</li>
</ul>
<p><code>T extends xxx</code>和<code>? extends xxx</code>的区别？</p>
<ul>
<li><code>T extends xxx</code>用于定义泛型类和方法，擦除后为<code>xxx</code>类型</li>
<li><code>? extends xxx</code>用于声明方法形参，接收<code>xxx</code>和其子类类型。</li>
</ul>
<h3 id="内部类了解吗？匿名内部类了解吗？"><a href="#内部类了解吗？匿名内部类了解吗？" class="headerlink" title="内部类了解吗？匿名内部类了解吗？"></a>内部类了解吗？匿名内部类了解吗？</h3><p>内部类分为下面4种：</p>
<ul>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部（方法）内部类</li>
<li>匿名内部类</li>
</ul>
<h3 id="BIO、NIO、AIO有什么区别？"><a href="#BIO、NIO、AIO有什么区别？" class="headerlink" title="BIO、NIO、AIO有什么区别？"></a>BIO、NIO、AIO有什么区别？</h3><ul>
<li>BIO属于同步阻塞IO模型，应用程序发起read调用后，会一直阻塞，知道在内核把数据拷贝到用户空间。</li>
<li>NIO：Java中的NIO可以看作是I/O多路复用模型。</li>
<li>AIO：异步IO模型。</li>
</ul>
<h2 id="Java集合框架"><a href="#Java集合框架" class="headerlink" title="Java集合框架"></a>Java集合框架</h2><h3 id="说说List、Set、Map三者的区别？三者底层的数据结构？"><a href="#说说List、Set、Map三者的区别？三者底层的数据结构？" class="headerlink" title="说说List、Set、Map三者的区别？三者底层的数据结构？"></a>说说<code>List</code>、<code>Set</code>、<code>Map</code>三者的区别？三者底层的数据结构？</h3><ul>
<li><code>List</code>：存储的元素是有序的，可以重复的。<ul>
<li><code>ArrayList</code>：底层是<code>Object[]</code>数组。</li>
<li><code>Vector</code>：底层是<code>Object[]</code> 数组。</li>
<li><code>LinkedList</code>：双向链表（JDK1.6之前是循环链表，JDK1.7后取消了循环）</li>
</ul>
</li>
<li><code>Set</code>：存储的元素是无序的，不可重复的。<ul>
<li><code>HashSet</code>（无序，唯一）：基于<code>HashMap</code>实现的。底层使用<code>HashMap</code>来保存元素。</li>
<li><code>LinkedHashSet</code>：是<code>HashSet</code>的子类，并且其内部是通过<code>LinkedHashMap</code>来实现的。</li>
<li><code>TreeSet</code>（有序，唯一）：红黑树（自平衡的排序二叉树）</li>
</ul>
</li>
<li><code>Map</code>：存储的是键值对（<code>key-value</code>），其中key是无序的，不能重复的；值是无序的，可以重复。灭个键最多映射到一个值。<ul>
<li><code>HashMap</code>：JDK1.8之前<code>HashMap</code>由数组+链表组成的，数组是<code>HashMap</code>的主体，链表则主要是为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认是8），会将链表转换为红黑树，以减少搜索时间。</li>
<li><code>LinkedHashMap</code>：继承自<code>HashMap</code>，所以他的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code>在上面结构的基础上，增加了一条双链表，使得上面的机构可以保证键值对的插入顺序。</li>
<li><code>HashTable</code>：数组+链表组成的，数组是<code>HashTable</code>的主体，链表则是主要为了解决哈希冲突而存在的。</li>
<li><code>TreeMap</code>：红黑树（自平衡的排序二叉树。</li>
</ul>
</li>
</ul>
<h3 id="有哪些集合是线程不安全的？怎么解决呢？"><a href="#有哪些集合是线程不安全的？怎么解决呢？" class="headerlink" title="有哪些集合是线程不安全的？怎么解决呢？"></a>有哪些集合是线程不安全的？怎么解决呢？</h3><p>线程不安全的集合：<code>HashMap</code>、<code>LinkedHashMap</code>、<code>TreeMap</code>、<code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code></p>
<p>选用线程安全的集合：<code>ConcurrentHashMap</code>、<code>HashTable</code>和<code>ConcurrentHashSet</code>.</p>
<h3 id="比较HashSet、LinkedHashSet、TreeSet三者的异同"><a href="#比较HashSet、LinkedHashSet、TreeSet三者的异同" class="headerlink" title="比较HashSet、LinkedHashSet、TreeSet三者的异同"></a>比较<code>HashSet</code>、<code>LinkedHashSet</code>、<code>TreeSet</code>三者的异同</h3><ul>
<li>都是<code>Set</code>接口的实现类，都能保证元素唯一，并且都是线程不安全大的。</li>
<li>三者的主要区别在于底层数据结构不同。<code>HashSet</code>的底层数据结构是哈希表（基于<code>HashMap</code>实现）。<code>LinkedHashMap</code>的底层数据结构是链表和哈希表，元素的插入和取出顺序满足FIFO。<code>TreeSet</code>底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li>
<li>根据三者的底层实现，三种结构的使用场景也不相同。</li>
</ul>
<h3 id="HashMap和HashTable的区别？HashMap和HashSet的区别？HashMap和TreeMap的区别？"><a href="#HashMap和HashTable的区别？HashMap和HashSet的区别？HashMap和TreeMap的区别？" class="headerlink" title="HashMap和HashTable的区别？HashMap和HashSet的区别？HashMap和TreeMap的区别？"></a><code>HashMap</code>和<code>HashTable</code>的区别？<code>HashMap</code>和<code>HashSet</code>的区别？<code>HashMap</code>和<code>TreeMap</code>的区别？</h3><h4 id="HashMap和HashTable的区别？"><a href="#HashMap和HashTable的区别？" class="headerlink" title="HashMap和HashTable的区别？"></a><code>HashMap</code>和<code>HashTable</code>的区别？</h4><ul>
<li><p><strong>线程是否安全</strong>：<code>HashMap</code>是非线程安全的，<code>HashTable</code>是线程安全的，因为<code>HashTable</code>内部的方法基本都经过<code>synchronized</code>修饰。（如果需要保证线程安全的话就使用<code>ConcurrentHashMap</code>）</p>
</li>
<li><p><strong>效率</strong>：因为线程安全的问题，<code>HashMap</code>要比<code>HashTable</code>效率高一点。另外，<code>HashTable</code>基本被淘汰，不要在代码中使用！！！</p>
</li>
<li><p><strong>对NULL key和Null value的支持</strong>：<code>HashMap</code>可以存储null的key和value，但null作为键只能有一个，null作为值可以有多个；<code>HashTable</code>不允许有null键和null值，否则会抛出<code>NullPointerException</code>。</p>
</li>
<li><p><strong>初始容量大小和每次扩容大小的不同</strong>：</p>
<ul>
<li><p>创建时如果不指定容量初始值，<code>HashTable</code>默认的初始大小为11，之后每次扩容，容量变为原来的<code>zn + 1</code>。<code>HashMap</code>默认的初始化大小为16。之后每次扩容，容量变为原来的2倍。</p>
</li>
<li><p>如果给定了容量初始值，那么<code>HashTable</code>会直接使用给定的大小，而<code>HashMap</code>会将其扩充为2的幂次方（<code>HashMap</code> 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>底层数据结构</strong>：JDK1.8以后的<code>HashMap</code>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换成红黑树），以减少搜索时间。</p>
</li>
</ul>
<h4 id="HashMap和HashSet的区别？"><a href="#HashMap和HashSet的区别？" class="headerlink" title="HashMap和HashSet的区别？"></a><code>HashMap</code>和<code>HashSet</code>的区别？</h4><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><code>HashMap</code></th>
<th style="text-align:center"><code>HashSet</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实现了<code>Map</code>接口</td>
<td style="text-align:center">实现<code>Set</code>接口</td>
</tr>
<tr>
<td style="text-align:center">存储键值对</td>
<td style="text-align:center">进存储对象</td>
</tr>
<tr>
<td style="text-align:center">调用<code>put()</code>向map中添加元素</td>
<td style="text-align:center">调用<code>add</code>方法向<code>Set</code>中添加元素</td>
</tr>
<tr>
<td style="text-align:center"><code>HashMap</code>使用键（Key）计算<code>hashCode</code></td>
<td style="text-align:center"><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td>
</tr>
</tbody>
</table>
</div>
<h4 id="HashMap和TreeMap的区别？"><a href="#HashMap和TreeMap的区别？" class="headerlink" title="HashMap和TreeMap的区别？"></a><code>HashMap</code>和<code>TreeMap</code>的区别？</h4><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortedMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。</p>
<p>定制排序示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2020年06月15日 17:02:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;Person, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person person1, Person person2)</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> person1.getAge() - person2.getAge();</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(num, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">3</span>), <span class="string">&quot;person1&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>), <span class="string">&quot;person2&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">35</span>), <span class="string">&quot;person3&quot;</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">16</span>), <span class="string">&quot;person4&quot;</span>);</span><br><span class="line">        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;</span><br><span class="line">            System.out.println(personStringEntry.getValue());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a><code>HashMap</code>的底层实现</h3><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>底层实现是<strong>数组和链表</strong>结合在一起使用也就是链表散列。</p>
<p><code>HashMap</code>通过key的<code>hashCode</code>经过<strong>扰动函数</strong>处理过后得到hash值，然后通过<code>(n - 1) &amp; hash</code>判断当前元素存放的位置（这里的n指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p>
<p>这里的<strong>扰动函数</strong>就是<code>HashMap</code>的<code>hash</code>方法。使用<code>hash</code>方法也就是<strong>扰动函数</strong>是为了防止一些实现比较查的<code>hashCode()</code>方法，换句话说，使用<strong>扰动函数</strong>之后可以<strong>减少碰撞</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扰动函数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">    <span class="comment">// ^：按位异或</span></span><br><span class="line">    <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。（类似于<strong>邻接表</strong>）</p>
<h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>底层实现是<strong>数组和链表/红黑树</strong>。相比于JDK1.8之前主要实在解决哈希冲突时有了较大的变化：</p>
<p>当链表长度大于阈值（默认是8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，会选择优先进行数组扩容，而不是转换成红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<h3 id="HashMap的长度为什么是2的幂次方？"><a href="#HashMap的长度为什么是2的幂次方？" class="headerlink" title="HashMap的长度为什么是2的幂次方？"></a><code>HashMap</code>的长度为什么是2的幂次方？</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p>重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length == hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>
<h3 id="ConcurrentHashMap和HashTable的区别？"><a href="#ConcurrentHashMap和HashTable的区别？" class="headerlink" title="ConcurrentHashMap和HashTable的区别？"></a><code>ConcurrentHashMap</code>和<code>HashTable</code>的区别？</h3><p>主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构</strong>：JDK1.7的<code>ConcurrentHashMap</code>底层采用<strong>分段的数组+链表</strong>实现，JDK1.8采用的数据结构跟<code>HashMap1.8</code>的结构一样，<strong>数组+链表/红黑树</strong>。<code>HashTable</code>和JDK1.8之前的<code>HashMap</code>的底层数据结构类似都是采用<strong>数组+链表</strong>的形式，数组是<code>HashMap</code>的主体，链表则是为了解决哈希冲突而存在的。</li>
<li><strong>实现线程安全的方式（重要）</strong>：<ul>
<li>JDK1.7的<code>ConcurrentHashMap</code>对整个桶数组进行了分割分段（<code>Segment</code>，分段锁），每一把锁都只锁容器的一部分。</li>
<li>JDK1.8的<code>ConcurrentHashMap</code>摒弃了<code>Segment</code>的概念，底层实现改为了<strong>数组+链表/红黑树</strong>。并发控制使用<code>synchornized</code>和CAS来操作。</li>
<li><code>HashTable</code>（同一把锁）：使用<code>synchornized</code>来保证线程安全，效率非常低。</li>
</ul>
</li>
</ul>
<h3 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现？"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现？" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现？"></a><code>ConcurrentHashMap</code>线程安全的具体实现方式/底层具体实现？</h3><h4 id="JDK1-8之前-1"><a href="#JDK1-8之前-1" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p><img src="/img/Java面试问题&amp;解答/java7_concurrenthashmap.png" alt="Java7 ConcurrentHashMap 存储结构"></p>
<p><strong><code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成</strong>。</p>
<p><code>Segment</code> 继承了 <code>ReentrantLock</code>,所以 <code>Segment</code> 是一种<strong>可重入锁</strong>，扮演锁的角色。<code>HashEntry</code> 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Segment</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p>
<h4 id="JDK1-8之后-1"><a href="#JDK1-8之后-1" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p><img src="/img/Java面试问题&amp;解答/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构"></p>
<p><code>ConcurrentHashMap</code>取消了<code>Segment</code>分段锁，采用了<code>Node + CAS + synchornized</code>来保证并发安全。</p>
<p>Java 8 中，锁粒度更细，<code>synchronized</code> 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，就不会影响其他 Node 的读写，效率大幅提升。</p>
<h2 id="JVM❗"><a href="#JVM❗" class="headerlink" title="JVM❗"></a>JVM❗</h2><h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>JVM内存结构呆滞分为五个部分：<strong>程序计数器、虚拟机栈、本地方法栈、堆和方法区</strong>。除此之外，还有由堆中引用的JVM外的直接内存。</p>
<p><img src="/img/Java面试问题&amp;解答/JVM" alt="JVM内存结构"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>是线程私有的</strong>。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><ul>
<li>每个线程运行时所需要的内存，称为虚拟机栈。也是线程私有的。</li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存。</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的方法。</li>
</ul>
<p>可能抛出的异常：</p>
<ul>
<li>当线程请求的栈深度超过最大值，会抛出<code>StackOverflowError</code>异常，这种异常在无停止条件的递归情况下会发生。</li>
<li>栈进行动态扩展时如果无法申请到足够内存，会抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>一些带有<code>native</code>关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法栈，服务于带<code>native</code>关键字的方法。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>所有对象都在这里分配内存，是垃圾收集的主要区域（“GC 堆”）。通过<code>new</code>关键字创建得对象会被放在堆内存。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 <code>OutOfMemoryError</code>异常。</p>
<p><strong>运行时常量池</strong>：</p>
<p>运行时常量池是方法区的一部分。常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</p>
<h3 id="JVM调优参数"><a href="#JVM调优参数" class="headerlink" title="JVM调优参数"></a>JVM调优参数</h3><p><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-parameters-intro.html"> 参考文档 </a></p>
<h4 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a>堆内存相关</h4><blockquote>
<p>堆内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p>
</blockquote>
<h5 id="显示指定堆内存-Xms和-Xmx"><a href="#显示指定堆内存-Xms和-Xmx" class="headerlink" title="显示指定堆内存-Xms和-Xmx"></a>显示指定堆内存<code>-Xms</code>和<code>-Xmx</code></h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Xms&lt;heap size&gt;[unit]  <span class="comment"># 最小堆大小</span></span><br><span class="line">-Xmx&lt;heap size&gt;[unit]  <span class="comment"># 最大堆大小</span></span><br><span class="line">-Xms2G -Xmx5G</span><br></pre></td></tr></table></figure>
<ul>
<li><code>heap size</code>表示要初始化内存的具体大小</li>
<li><code>unit</code>表示要初始化内存的单位。例如：g(GB)，m(MB)，k(KB)。</li>
</ul>
<h5 id="显示指定永久代-元空间的大小"><a href="#显示指定永久代-元空间的大小" class="headerlink" title="显示指定永久代/元空间的大小"></a>显示指定永久代/元空间的大小</h5><p>从Java8开始，如果我们没有指定Metaspace的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代不会出现这种情况）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment"># 设置Metaspace的初始大小</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment"># 设置Metaspace的最大大小</span></span><br></pre></td></tr></table></figure>
<h4 id="垃圾收集相关"><a href="#垃圾收集相关" class="headerlink" title="垃圾收集相关"></a>垃圾收集相关</h4><h5 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h5><p>JVM具有四种类型的GC实现：</p>
<ul>
<li>串行垃圾收集器：<code>-XX:UseSerialGC</code></li>
<li>并行垃圾收集器：<code>-XX:UseParallelGC</code></li>
<li>CMS垃圾收集器：<code>-XX:UseParNewGC</code></li>
<li>G1垃圾收集器：<code>-XX:UseG1GC</code></li>
</ul>
<h5 id="GC日志记录"><a href="#GC日志记录" class="headerlink" title="GC日志记录"></a>GC日志记录</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 必选</span></span><br><span class="line"><span class="comment"># 打印基本 GC 信息</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="comment"># 打印对象分布</span></span><br><span class="line">-XX:+PrintTenuringDistribution</span><br><span class="line"><span class="comment"># 打印堆数据</span></span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"><span class="comment"># 打印Reference处理信息</span></span><br><span class="line"><span class="comment"># 强引用/弱引用/软引用/虚引用/finalize 相关的方法</span></span><br><span class="line">-XX:+PrintReferenceGC</span><br><span class="line"><span class="comment"># 打印STW时间</span></span><br><span class="line">-XX:+PrintGCApplicationStoppedTime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可选</span></span><br><span class="line"><span class="comment"># 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint</span></span><br><span class="line">-XX:+PrintSafepointStatistics</span><br><span class="line">-XX:PrintSafepointStatisticsCount=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># GC日志输出的文件路径</span></span><br><span class="line">-Xloggc:/path/to/gc-%t.log</span><br><span class="line"><span class="comment"># 开启日志文件分割</span></span><br><span class="line">-XX:+UseGCLogFileRotation</span><br><span class="line"><span class="comment"># 最多分割几个文件，超过之后从头文件开始写</span></span><br><span class="line">-XX:NumberOfGCLogFiles=14</span><br><span class="line"><span class="comment"># 每个文件上限大小，超过就触发分割</span></span><br><span class="line">-XX:GCLogFileSize=50M</span><br></pre></td></tr></table></figure>
<h3 id="什么是类加载？何时类加载？类加载流程？"><a href="#什么是类加载？何时类加载？类加载流程？" class="headerlink" title="什么是类加载？何时类加载？类加载流程？"></a>什么是类加载？何时类加载？类加载流程？</h3><h4 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h4><p>类从被加载到虚拟机内存中开始到卸载出内存开始，它的整个生命周期可以简单概括为7个阶段：加载（loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中前三个阶段可以统称为连接（Linking）。</p>
<p><img src="/img/Java面试问题&amp;解答/lifecycle-of-a-class.png" alt="一个类的完整生命周期"></p>
<h4 id="类加载流程"><a href="#类加载流程" class="headerlink" title="类加载流程"></a>类加载流程</h4><blockquote>
<p>class文件需要加载到虚拟机中之后才能运行和使用。虚拟机加载这些class文件的步骤如下：</p>
</blockquote>
<p>系统加载Class类型的文件主要三步：<code>加载 -&gt; 连接 -&gt; 初始化</code>。连接过程又可以分为三步：<code>验证 -&gt; 准备 -&gt; 解析</code></p>
<h5 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h5><p>类加载过程的第一步，主要完成以下工作：</p>
<ol>
<li>通过全类名获取定义此类的二进制字节流。</li>
<li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表该类的<code>Class</code>对象，作为方法区这些数据的访问入口。</li>
</ol>
<h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p><strong>验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当做代码运行后不会危害虚拟机自身的安全。</strong></p>
<p>验证阶段主要由四个检验阶段组成：</p>
<ul>
<li>文件格式验证（Class文件格式检查）：验证字节流是否符合Class文件格式的规范。</li>
<li>元数据验证（字节码语义检查）：对字节码描述的信息进行语义分析，以保证其描述的信息符合《Java虚拟机规范》的要求。</li>
<li>字节码验证（程序语义检查）：通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的。</li>
<li>符号引用验证（类的正确性检查）：验证该类的正确性。</li>
</ul>
<h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><blockquote>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。</p>
</blockquote>
<h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><blockquote>
<p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。</p>
</blockquote>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><blockquote>
<p>初始化阶段是执行初始化方法<code>&lt;clinit&gt;()</code>方法的过程，是类加载的最后一步，这一步JVM才开始真正执行类中定义的Java程序代码（字节码）</p>
</blockquote>
<p><strong>虚拟机严格规范了有且只有5中情况下，必须对类进行初始化</strong></p>
<ol>
<li>当遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条字节码指令时。</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时。如：<code>Class.forname(&quot;...&quot;)</code>、<code>newInstance()</code>等等。</li>
<li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li>
<li>当虚拟机启动时，用户需要定义一个要执行的主类（包含<code>main</code>方法的那个类），虚拟机会先初始化这个类。</li>
<li><code>MethodHandle</code>和<code>VarHandle</code>可以看作是轻量级的反射调用机制。而要想使用这 2 个调用， 就必须先使用 <code>findStaticVarHandle</code> 来初始化要调用的类。</li>
</ol>
<h3 id="知道哪些类加载器？类加载器之间的关系？"><a href="#知道哪些类加载器？类加载器之间的关系？" class="headerlink" title="知道哪些类加载器？类加载器之间的关系？"></a>知道哪些类加载器？类加载器之间的关系？</h3><blockquote>
<p>类加载器从 JDK 1.0 就出现了，最初只是为了满足 Java Applet（已经被淘汰） 的需要。后来，慢慢成为 Java 程序中的一个重要组成部分，赋予了 Java 类可以被动态加载到 JVM 中并执行的能力。</p>
</blockquote>
<p>类加载器的作用：</p>
<ul>
<li>类加载器是一个负责加载类的对象，用于实现类加载过程中<strong>加载</strong>这一步。</li>
<li>每个Java类都有一个引用指向加载它的<code>ClassLoader</code>。</li>
<li>数组类不是通过<code>ClassLoader</code>创建的（数组类没有对应的二进制字节流），是由JVM直接生成的。</li>
</ul>
<p>简单来说，<strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong></p>
<p>JVM中内置了三个重要的<code>ClassLoader</code></p>
<ol>
<li><code>BootStrapClassLoader</code>（启动类加载器）：最顶层的加载类，由C++实现，通常表示为null，并且没有父级，主要用来加载JDk内部的核心类库（<code>%JAVA_HOME%/lib</code>目录下的<code>rt.jar</code>、<code>resources.jar</code>等jar包和类）以及被<code>-Xbootclasspath</code>参数指定的路径下的所有类。</li>
<li><code>ExtenstionClassLoader</code>（扩展类加载器）：主要负责加载<code>%JRE_HOME%/lib/ext</code>目录下的jar包和类以及被<code>java.ext.dirs</code>系统变量所指定的路径下的所有类。</li>
<li><code>AppClassLoader</code>（应用程序类加载器）：面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li>
</ol>
<p><img src="/img/Java面试问题&amp;解答/class-loader-parents-delegation-model.png" alt="类加载器层次关系图"></p>
<h3 id="类加载器的双亲委派了解吗？结合Tomcat说一下双亲委派（Tomcat如何打破双亲委托机制？）❗"><a href="#类加载器的双亲委派了解吗？结合Tomcat说一下双亲委派（Tomcat如何打破双亲委托机制？）❗" class="headerlink" title="类加载器的双亲委派了解吗？结合Tomcat说一下双亲委派（Tomcat如何打破双亲委托机制？）❗"></a>类加载器的双亲委派了解吗？结合Tomcat说一下双亲委派（Tomcat如何打破双亲委托机制？）❗</h3><p>双亲委派模型是用来明确哪个类加载器加载。</p>
<blockquote>
<p><code>ClassLoader</code>类使用委托模型来搜索类和资源。每个<code>ClassLoader</code>实例都有一个相关的父类加载器。需要查找类或资源时，<code>ClassLoader</code>实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。</p>
</blockquote>
<h3 id="为什么需要双亲委派？"><a href="#为什么需要双亲委派？" class="headerlink" title="为什么需要双亲委派？"></a>为什么需要双亲委派？</h3><p>双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了Java的核心API不被篡改。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p><img src="/img/Java面试问题&amp;解答/20210226133909692.png" alt="20210226133909692"></p>
<h3 id="栈中存放什么数据？堆中呢？"><a href="#栈中存放什么数据？堆中呢？" class="headerlink" title="栈中存放什么数据？堆中呢？"></a>栈中存放什么数据？堆中呢？</h3><ul>
<li>虚拟机栈：存放方法、局部变量、运行数据。线程私有。</li>
<li>本地方法栈：存储<code>Native</code>方法。线程私有。</li>
<li>堆：存放所有创建的对象，数组。所有线程共享区域。</li>
</ul>
<h3 id="大对象放在哪个内存区域？"><a href="#大对象放在哪个内存区域？" class="headerlink" title="大对象放在哪个内存区域？"></a>大对象放在哪个内存区域？</h3><blockquote>
<p>大对象就是需要大量连续内存空间的对象。比如：字符串、数组。</p>
</blockquote>
<p>大对象直接进入<strong>老年代</strong>主要是为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<p>堆被划分为两个不同的区域：<strong>新生代</strong>（Young）（1/3堆空间）、<strong>老年代</strong>（Old）（2/3堆空间）。其中新生代（Young）又被划分为三个区域：Eden（8/10）、From Survivor（1/10）、To Survivor（1/10）。</p>
<h3 id="堆区如何分类？"><a href="#堆区如何分类？" class="headerlink" title="堆区如何分类？"></a>堆区如何分类？</h3><p>在JDK7版本及JDK7版本之前，堆内存被通常分为下面三部分：</p>
<ul>
<li>新生代内存：占1/3堆空间。</li>
<li>老生代内存：占2/3堆空间。</li>
<li>永久代</li>
</ul>
<p>下图所示的<code>Eden</code>区、两个<code>Survivor</code>区S0和S1都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p>
<p><img src="/img/Java面试问题&amp;解答/hotspot-heap-structure.png" alt="堆内存结构"></p>
<p><strong>JDK8版本之后PermGen（永久代）已经被Metaspace（元空间）取代，元空间使用的是直接内存。</strong></p>
<h3 id="垃圾回收有哪些算法？"><a href="#垃圾回收有哪些算法？" class="headerlink" title="垃圾回收有哪些算法？"></a>垃圾回收有哪些算法？</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><blockquote>
<p>标记-清除（Mark-and-Sweep）算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。</p>
</blockquote>
<p>它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ul>
<li><strong>效率问题</strong>：标记和清除两个过程效率都不高。</li>
<li><strong>空间问题</strong>：标记清除后会产生大量不连续的内存碎片。</li>
</ul>
<p><img src="/img/Java面试问题&amp;解答/mark-and-sweep-garbage-collection-algorithm.png" alt="标记-清除算法"></p>
<p>标记-清除过程：</p>
<ol>
<li>当一个对象被创建时，给一个标记位，假设为0/false。</li>
<li>在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为1/true。</li>
<li>扫描阶段清除的就是标记位0/false的对象。</li>
</ol>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。</p>
<p>它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><img src="/img/Java面试问题&amp;解答/copying-garbage-collection-algorithm.png" alt="复制算法"></p>
<p>依然存在下面这些问题：</p>
<ul>
<li><strong>可用内存变小</strong>：可用内存缩小为原来的一半。</li>
<li><strong>不适合老年代</strong>：如果存活对象数量比较大，复制性能会变得很差。</li>
</ul>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="/img/Java面试问题&amp;解答/mark-and-compact-garbage-collection-algorithm.png" alt="标记-整理算法"></p>
<p>因为多了整理这一步，因此效率也不高，适合老年代这种回收频率不高的场景。</p>
<h4 id="分代收集算法💡"><a href="#分代收集算法💡" class="headerlink" title="分代收集算法💡"></a>分代收集算法💡</h4><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>比如<strong>在新生代中</strong>，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p>
<h3 id="GC的全部流程"><a href="#GC的全部流程" class="headerlink" title="GC的全部流程"></a>GC的全部流程</h3><h4 id="死亡对象判断"><a href="#死亡对象判断" class="headerlink" title="死亡对象判断"></a>死亡对象判断</h4><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对象中添加一个引用计数器：</p>
<ul>
<li>每当有一个地方引用它，计算器就加1。</li>
<li>当引用失败，计数器就减一。</li>
<li>任何时候计数器为0的对象就是不可能再被使用的。</li>
</ul>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题。</strong></p>
<p><img src="/img/Java面试问题&amp;解答/object-circular-reference.png" alt="对象之间循环引用"></p>
<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>
<p>下图中的 <code>Object 6 ~ Object 10</code> 之间虽有引用关系，但它们到 GC Roots 不可达，因此为需要被回收的对象。</p>
<p><img src="/img/Java面试问题&amp;解答/jvm-gc-roots.png" alt="可达性分析算法"></p>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>参考上面的垃圾回收算法。</p>
<h3 id="GC中老年代用什么回收方法？"><a href="#GC中老年代用什么回收方法？" class="headerlink" title="GC中老年代用什么回收方法？"></a>GC中老年代用什么回收方法？</h3><p>老年代中的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择<strong>“标记-清楚”</strong>或<strong>“标记-整理”</strong>算法进行垃圾回收。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="线程和进程的区别💡"><a href="#线程和进程的区别💡" class="headerlink" title="线程和进程的区别💡"></a>线程和进程的区别💡</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程是程序一次执行过程，是系统运行程序的最基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>线程与进程相似，但<strong>线程是一个比进程更小的执行单位</strong>。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源。但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为<strong>轻量级进程</strong>。</p>
<p><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</strong></p>
<h4 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h4><p><img src="/img/Java面试问题&amp;解答/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源</strong>，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</strong>💡</p>
<h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换"></a>什么是上下文切换</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如程序计数器，栈信息等。当出现如下情况的时候，线程会从占用CPU状态中退出。</p>
<ul>
<li>主动让出CPU，比如调用了<code>sleep()</code>、<code>wait()</code>等。</li>
<li>时间片用完，因为操作系统要防止一个线程或进程长时间占用CPU导致其他线程或进程饿死。</li>
<li>调用了阻塞类型的系统中断。比如请求IO，线程被阻塞。</li>
<li>被终止或结束运行。</li>
</ul>
<p>其中前三种都会发生线程切换，线程切换意味着要保存当前线程的上下文，留待线程下次占用CPU的时候恢复线程。并加载下一个将要占用CPU的线程上下文。这就是所谓的<strong>上下文切换</strong>。</p>
<p>上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果频繁切换就会造成整体效率低下。</p>
<h3 id="什么是线程死锁？如何避免死锁？"><a href="#什么是线程死锁？如何避免死锁？" class="headerlink" title="什么是线程死锁？如何避免死锁？"></a>什么是线程死锁？如何避免死锁？</h3><h4 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h4><p>多个线程同时阻塞，他们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p><strong>死锁产生的四个条件</strong>：</p>
<ul>
<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用</li>
<li><strong>请求与保持</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li><strong>不剥夺条件</strong>：进程已获得的资源，在未使用完之前，不能强行剥夺；</li>
<li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p><img src="/img/Java面试问题&amp;解答/2019-4死锁1.png" alt="线程死锁示意图 "></p>
<h4 id="如何预防和避免死锁"><a href="#如何预防和避免死锁" class="headerlink" title="如何预防和避免死锁"></a>如何预防和避免死锁</h4><p>预防死锁：破坏死锁的产生的必要条件即可。</p>
<ul>
<li><strong>破坏请求与保持条件</strong>：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong>：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong>：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放，</li>
</ul>
<p>避免死锁：</p>
<p>在资源分配时，借助于算法（比如<strong>银行家算法</strong>）对资源分配进行计算评估，时期进入安全状态。</p>
<h3 id="乐观锁和悲观锁了解吗？"><a href="#乐观锁和悲观锁了解吗？" class="headerlink" title="乐观锁和悲观锁了解吗？"></a>乐观锁和悲观锁了解吗？</h3><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停的执行，无需加锁也无需等待，只是在提交修改的时候区验证对应的资源（也就是数据）是否被其他线程修改。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，这样其他线程想拿这个资源就会阻塞直到锁被上一个持有者释放。也就是说：<strong>共享资源每次只给一个线程使用，其他线程阻塞，用完再把资源转让给其他线程。</strong></p>
<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<h3 id="说说sleep-方法和wait-方法的区别和共同点"><a href="#说说sleep-方法和wait-方法的区别和共同点" class="headerlink" title="说说sleep()方法和wait()方法的区别和共同点"></a>说说<code>sleep()</code>方法和<code>wait()</code>方法的区别和共同点</h3><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p>
<p><strong>区别</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>sleep()</code></th>
<th><code>wait()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>没有释放锁</td>
<td>释放了锁</td>
</tr>
<tr>
<td>通常用于线程间的交互/通信</td>
<td>通常被用于暂停执行</td>
</tr>
<tr>
<td>该方法执行完之后，线程会自动苏醒，也可以使用<code>wait(long timeout)</code>超时后线程会自动苏醒</td>
<td>方法被调用后，线程不会自动苏醒，需要别的线程调用同一对象上的<code>notify()</code>或者<code>notifyAll()</code>方法。</td>
</tr>
<tr>
<td>是<code>Thread</code>类的静态本地方法</td>
<td>是<code>object</code>类的本地方法。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="拓展1：为什么wait-方法不定义在Thread中？"><a href="#拓展1：为什么wait-方法不定义在Thread中？" class="headerlink" title="拓展1：为什么wait()方法不定义在Thread中？"></a>拓展1：为什么<code>wait()</code>方法不定义在<code>Thread</code>中？</h4><p><code>wait()</code>是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（<code>Object</code>）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入WAITING状态，自然是要操作对应的对象<code>Object</code>而非当前线程<code>Thread</code>。</p>
<h4 id="拓展2：为什么sleep-方法定义在Thread中？"><a href="#拓展2：为什么sleep-方法定义在Thread中？" class="headerlink" title="拓展2：为什么sleep()方法定义在Thread中？"></a>拓展2：为什么<code>sleep()</code>方法定义在<code>Thread</code>中？</h4><p>因为<code>sleep()</code>是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。</p>
<h3 id="Java线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程？❗"><a href="#Java线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程？❗" class="headerlink" title="Java线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程？❗"></a>Java线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程？❗</h3><h3 id="实现Runnable接口和Collable接口的区别"><a href="#实现Runnable接口和Collable接口的区别" class="headerlink" title="实现Runnable接口和Collable接口的区别"></a>实现<code>Runnable</code>接口和<code>Collable</code>接口的区别</h3><h3 id="讲一下JMM（Java内存模型）。volatile关键字解决了什么问题？说说synchronized关键字和volatile关键字的区别。"><a href="#讲一下JMM（Java内存模型）。volatile关键字解决了什么问题？说说synchronized关键字和volatile关键字的区别。" class="headerlink" title="讲一下JMM（Java内存模型）。volatile关键字解决了什么问题？说说synchronized关键字和volatile关键字的区别。"></a>讲一下JMM（Java内存模型）。<code>volatile</code>关键字解决了什么问题？说说<code>synchronized</code>关键字和<code>volatile</code>关键字的区别。</h3><h3 id="AQS原理了解吗？AQS组件有哪些？"><a href="#AQS原理了解吗？AQS组件有哪些？" class="headerlink" title="AQS原理了解吗？AQS组件有哪些？"></a>AQS原理了解吗？AQS组件有哪些？</h3><h3 id="用过CountDownLatch吗？什么场景下用的？"><a href="#用过CountDownLatch吗？什么场景下用的？" class="headerlink" title="用过CountDownLatch吗？什么场景下用的？"></a>用过<code>CountDownLatch</code>吗？什么场景下用的？</h3><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h3 id="非关系型数据库和关系型数据库的区别？"><a href="#非关系型数据库和关系型数据库的区别？" class="headerlink" title="非关系型数据库和关系型数据库的区别？"></a>非关系型数据库和关系型数据库的区别？</h3><h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><p>事务需要遵循ACID四个特性</p>
<ul>
<li>A（atomicity）<strong>原子性</strong>：是指整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都成功，整个事务的执行才算成功。</li>
<li>C（consistency）<strong>一致性</strong>：一致性指事务将数据库从一种状态转变成另一种一致的状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</li>
<li>I（isolation）<strong>隔离性</strong>：要求每个读写事务的对象与其他事务的操作对象能相互分离，即该事务提交对其他事务都不可见，通常使用锁来实现。</li>
<li>D（durability）<strong>持久性</strong>：事务一旦提交，其结果就是永久性的，即使发生宕机，数据库也能将数据恢复。保证了事务系统的高可靠性，而不是高可用性。</li>
</ul>
<h3 id="MySQL事务隔离级别？默认是什么级别？"><a href="#MySQL事务隔离级别？默认是什么级别？" class="headerlink" title="MySQL事务隔离级别？默认是什么级别？"></a>MySQL事务隔离级别？默认是什么级别？</h3><p>SQL定义了四种隔离级别：</p>
<ul>
<li>读未提交RU（READ UNCOMMITTED）</li>
<li>读提叫RC（READ COMMITTED）</li>
<li>可重复读RR（REPEATABLE READ）。InnoDB存储引擎默认的支持隔离级别</li>
<li>串行化（SERIALIZABLE）</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">读未提交RU</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">读提交RC</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">可能</td>
<td style="text-align:center">可能</td>
</tr>
<tr>
<td style="text-align:center">可重复读RR</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
</tr>
<tr>
<td style="text-align:center">串行化</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
<td style="text-align:center">不可能</td>
</tr>
</tbody>
</table>
</div>
<p>MySQL中，InnoDB存储引擎默认的隔离级别是可重复读RR。</p>
<h3 id="乐观锁和悲观锁的区别"><a href="#乐观锁和悲观锁的区别" class="headerlink" title="乐观锁和悲观锁的区别"></a>乐观锁和悲观锁的区别</h3><h4 id="乐观锁-1"><a href="#乐观锁-1" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停的执行，无需加锁也无需等待，只是在提交修改的时候区验证对应的资源（也就是数据）是否被其他线程修改。</p>
<h4 id="悲观锁-1"><a href="#悲观锁-1" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题（比如共享数据被修改），所以每次在获取资源操作的时候都会上锁，这样其他线程想拿这个资源就会阻塞直到锁被上一个持有者释放。也就是说：<strong>共享资源每次只给一个线程使用，其他线程阻塞，用完再把资源转让给其他线程。</strong></p>
<p>像 Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p>
<p>使用场景不同</p>
<ul>
<li>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。</li>
<li>乐观锁通常多用于写比较少的情况下（多读场景，竞争比较少），这样可以避免频繁枷锁影响性能。</li>
</ul>
<h3 id="MySQL数据库两种存储引擎的区别"><a href="#MySQL数据库两种存储引擎的区别" class="headerlink" title="MySQL数据库两种存储引擎的区别"></a>MySQL数据库两种存储引擎的区别</h3><p>MyISAM和InnoDB的数据结构都是B+树。B+树的非叶子结点不存储数据，只有叶子结点才会存储数据。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">区别</th>
<th style="text-align:center">MyISAM</th>
<th style="text-align:center">InnoDB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">结构</td>
<td style="text-align:center">每个MyISAM在磁盘上存储成三个文件（扩展名指出文件类型）。<code>.frm</code>文件存储表定义，也就是存储结构的信息。<code>.MYD</code>文件存放数据文件，<code>.MYI</code>存放索引文件。</td>
<td style="text-align:center">表空间数据文件和他的日志文件。没有了<code>myd</code>和<code>myi</code>，只有<code>.idb</code>放了索引位置以及表的信息位置。</td>
</tr>
<tr>
<td style="text-align:center">事务</td>
<td style="text-align:center">强调的是性能，不提供事务支持</td>
<td style="text-align:center">提供事务支持事务，外部键等高级数据库功能。</td>
</tr>
<tr>
<td style="text-align:center">CRUD</td>
<td style="text-align:center">查询很合适</td>
<td style="text-align:center">增加或更新更合适，删除的时候，就是一行一行的删除。</td>
</tr>
<tr>
<td style="text-align:center">表的具体行数</td>
<td style="text-align:center"><code>select count(*) from table</code>，可以很好的读取</td>
<td style="text-align:center">不保存表的具体行数，要扫描一遍整个表来计算有多少行</td>
</tr>
<tr>
<td style="text-align:center">AUTO_INCREMENT</td>
<td style="text-align:center">可以和其他字段一起建立联合索引</td>
<td style="text-align:center">必须包含只有该字段的索引</td>
</tr>
<tr>
<td style="text-align:center">全文索引</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">外键</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">锁</td>
<td style="text-align:center">表锁</td>
<td style="text-align:center">提供行锁（执行一个SQL语句时MySQL不能确定要扫描的范围，同样会锁全表，例如：<code>update table set num=1 where name like &quot;%aaa%&quot;</code>）</td>
</tr>
<tr>
<td style="text-align:center">索引查询方法</td>
<td style="text-align:center">会先根据索引查找到<strong>数据地址</strong>，再根据地址查询到具体的数据。并且主键索引和辅助索引没有区别。</td>
<td style="text-align:center">主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；</td>
</tr>
<tr>
<td style="text-align:center">B+树叶子结点存储内容</td>
<td style="text-align:center">叶子结点存放的是地址</td>
<td style="text-align:center">叶子结点的数据区域存储的是数据记录。辅助索引存储的是主键值。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><h3 id="为什么索引能够提高查询速度？"><a href="#为什么索引能够提高查询速度？" class="headerlink" title="为什么索引能够提高查询速度？"></a>为什么索引能够提高查询速度？</h3><blockquote>
<p>索引：数据库索引，是数据库管理系统（DBMS）中一个排序的数据结构，以协助快速查询、更新数据库表中数据。</p>
</blockquote>
<p>使用索引进行查询时，只需要在索引里面去检索这条数据就行了，因为它是一种特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，就可以拿到数据了。</p>
<h3 id="聚集索引和非聚集索引的区别？非聚集索引一定回表查询码？"><a href="#聚集索引和非聚集索引的区别？非聚集索引一定回表查询码？" class="headerlink" title="聚集索引和非聚集索引的区别？非聚集索引一定回表查询码？"></a>聚集索引和非聚集索引的区别？非聚集索引一定回表查询码？</h3><h4 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h4><blockquote>
<p>聚集索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB中的主键索引就属于聚集索引。</p>
</blockquote>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>查询速度非常快</strong>：B+树本身就是一颗多叉平衡树，叶子结点都是有序的，定位到索引的结点，就相当于定位到了数据。相比于非聚集索引，聚集索引少了一次读取数据的IO操作。</li>
<li><strong>对排序查找和范围查找优化</strong>：聚集索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：</li>
<li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，</li>
</ul>
<h4 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h4><blockquote>
<p>非聚集索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引（辅助索引）就属于非聚集索引。MySQL的MyISAM引擎，不管主键还是非主键，使用的都是非聚集索引。</p>
</blockquote>
<p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>
<p><strong>优点</strong>：</p>
<p>更新代价比聚集索引要小。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：</li>
<li><strong>可能会二次查询（回表）</strong>：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<h4 id="非聚集索引一定回表查询吗？"><a href="#非聚集索引一定回表查询吗？" class="headerlink" title="非聚集索引一定回表查询吗？"></a>非聚集索引一定回表查询吗？</h4><p><strong>非聚集索引不一定回表查询。</strong></p>
<p>当SQL查询的字段恰好建立了索引，则会直接查找返回即可，无需回表查询。</p>
<h3 id="为什么不对表中的每一列创建一个索引呢？（使用索引一定能提高查询性能吗？）"><a href="#为什么不对表中的每一列创建一个索引呢？（使用索引一定能提高查询性能吗？）" class="headerlink" title="为什么不对表中的每一列创建一个索引呢？（使用索引一定能提高查询性能吗？）"></a>为什么不对表中的每一列创建一个索引呢？（使用索引一定能提高查询性能吗？）</h3><p><strong>索引的缺点</strong>：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL的执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p><strong>使用索引也不一定能提高查询效率</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的，但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大的提升。</p>
<h3 id="索引底层的数据结构了解吗？Hash索引和B-数索引优劣分析"><a href="#索引底层的数据结构了解吗？Hash索引和B-数索引优劣分析" class="headerlink" title="索引底层的数据结构了解吗？Hash索引和B+数索引优劣分析"></a>索引底层的数据结构了解吗？Hash索引和B+数索引优劣分析</h3><p>MySQL索引底层数据结构是<strong>B+树</strong>。</p>
<ul>
<li>B+树只有叶子结点存放key和data，其他内节点只存放key。</li>
<li>B+树的叶子结点有一条引用链只想与它相邻的叶子结点。</li>
<li>B+树的检索效率很稳定，任何查找都是从根节点到叶子结点的过程，叶子结点的顺序检索很明显。</li>
<li>B+树的范围查询，只需要对链表进行遍历即可。</li>
</ul>
<p>虽然MySQL中，MyISAM引擎和InnoDB引擎都是使用B+树作为索引结构，但是两者的实现方式不太一样。</p>
<ul>
<li>MyISAM引擎中：B+树的叶节点的data域存放的是<strong>数据记录的地址</strong>。（<strong>非聚集索引</strong>）</li>
<li>InnoDB引擎中：B+树的叶节点的Data域保存了<strong>完整的数据记录</strong>。这个索引的key是数据表的主键。（<strong>聚集索引</strong>）不同的是使用辅助索引查找时，需要先取出主键的值，然后再走一遍主索引。</li>
</ul>
<h3 id="B-树做索引比红黑树好在哪里？"><a href="#B-树做索引比红黑树好在哪里？" class="headerlink" title="B+树做索引比红黑树好在哪里？"></a>B+树做索引比红黑树好在哪里？</h3><p><strong>红黑树的缺点</strong>：和AVL树（自平衡二叉查找树）不同，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为<strong>红黑树的平衡性相对较弱</strong>，可能会导致树的高度教高，这可能会导致一些数据需要进行多次磁盘IO操作才能查询到。</p>
<p><strong>红黑树的优点</strong>：红黑树的插入和删除操作效率大大提高了，因为红黑树再插入和删除节点时只需要进行O(1)次数的旋转和变色操作，即可保持基本平衡状态，而不需要向AVL树一样进行O(logn)次数的旋转操作。</p>
<h3 id="最左前缀匹配原则了解吗？"><a href="#最左前缀匹配原则了解吗？" class="headerlink" title="最左前缀匹配原则了解吗？"></a>最左前缀匹配原则了解吗？</h3><p>最左匹配原则指的是：在使用联合索引时，MySQL会根据联合索引中的字段顺序，从左到右依次到查询中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如<code>&gt;</code>、<code>&lt;</code>）才会停止匹配。对于<code>&gt;=</code>、<code>&lt;=</code>、<code>between</code>、<code>like</code><strong>前缀匹配</strong>的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多的数据。</p>
<h3 id="什么是覆盖索引"><a href="#什么是覆盖索引" class="headerlink" title="什么是覆盖索引"></a>什么是覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引</strong>。</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<h2 id="MySQL进阶"><a href="#MySQL进阶" class="headerlink" title="MySQL进阶"></a>MySQL进阶</h2><h3 id="一条SQL语句在MySQL中如何执行的？"><a href="#一条SQL语句在MySQL中如何执行的？" class="headerlink" title="一条SQL语句在MySQL中如何执行的？"></a>一条SQL语句在MySQL中如何执行的？</h3><h3 id="explain命令了解吗？"><a href="#explain命令了解吗？" class="headerlink" title="explain命令了解吗？"></a><code>explain</code>命令了解吗？</h3><p>通过<code>explain</code>的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、那些索引可以被命中、那些索引实际会命中、每个数据表有多少行记录被查询等信息。</p>
<p>需要注意的是<code>explain</code>语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>
<p><code>explain</code>执行计划支持<code>select</code>、<code>delete</code>、<code>insert</code>、<code>replace</code>以及<code>update</code>语句。我们一般多用于分析<code>select</code>查询语句，使用起来非常简单，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> 查询语句;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> dept_emp <span class="keyword">WHERE</span> emp_no <span class="keyword">IN</span> (<span class="keyword">SELECT</span> emp_no <span class="keyword">FROM</span> dept_emp <span class="keyword">GROUP</span> <span class="keyword">BY</span> emp_no <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(emp_no)<span class="operator">&gt;</span><span class="number">1</span>);</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>    <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys   <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>     <span class="operator">|</span> dept_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">ALL</span>   <span class="operator">|</span> <span class="keyword">NULL</span>            <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">331143</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> SUBQUERY    <span class="operator">|</span> dept_emp <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">PRIMARY</span>,dept_no <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">16</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">331143</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，执行计划结果中共有12列，各列代表的含义总结如下表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>select查询的序列标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>select关键字对应的查询类型</td>
</tr>
<tr>
<td>table</td>
<td>用到的表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为NULL</td>
</tr>
<tr>
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>所选的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody>
</table>
</div>
<h3 id="简单说一下SQL调优思路"><a href="#简单说一下SQL调优思路" class="headerlink" title="简单说一下SQL调优思路"></a>简单说一下SQL调优思路</h3><h3 id="简单说一下大表优化的思路"><a href="#简单说一下大表优化的思路" class="headerlink" title="简单说一下大表优化的思路"></a>简单说一下大表优化的思路</h3><h3 id="分库分表了解吗？为什么要分库分表？有哪些常见的分库分表工具？（sharding-jdbc、TSharding、MyCAT…）"><a href="#分库分表了解吗？为什么要分库分表？有哪些常见的分库分表工具？（sharding-jdbc、TSharding、MyCAT…）" class="headerlink" title="分库分表了解吗？为什么要分库分表？有哪些常见的分库分表工具？（sharding-jdbc、TSharding、MyCAT…）"></a>分库分表了解吗？为什么要分库分表？有哪些常见的分库分表工具？（<code>sharding-jdbc</code>、<code>TSharding</code>、<code>MyCAT</code>…）</h3><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="分布式缓存常见的技术选型方案有哪些？说一下Redis和Memcached的区别和共同点"><a href="#分布式缓存常见的技术选型方案有哪些？说一下Redis和Memcached的区别和共同点" class="headerlink" title="分布式缓存常见的技术选型方案有哪些？说一下Redis和Memcached的区别和共同点"></a>分布式缓存常见的技术选型方案有哪些？说一下Redis和Memcached的区别和共同点</h3><h3 id="说一下有缓存情况下查询数据和修改数据的流程"><a href="#说一下有缓存情况下查询数据和修改数据的流程" class="headerlink" title="说一下有缓存情况下查询数据和修改数据的流程"></a>说一下有缓存情况下查询数据和修改数据的流程</h3><h3 id="Redis有哪些数据结构？SDS了解吗？"><a href="#Redis有哪些数据结构？SDS了解吗？" class="headerlink" title="Redis有哪些数据结构？SDS了解吗？"></a>Redis有哪些数据结构？SDS了解吗？</h3><h3 id="Redis内存满了怎么办？"><a href="#Redis内存满了怎么办？" class="headerlink" title="Redis内存满了怎么办？"></a>Redis内存满了怎么办？</h3><h3 id="Redis内存淘汰算法除了LRU还有哪些？"><a href="#Redis内存淘汰算法除了LRU还有哪些？" class="headerlink" title="Redis内存淘汰算法除了LRU还有哪些？"></a>Redis内存淘汰算法除了LRU还有哪些？</h3><h3 id="Redis给缓存数据设置过期时间有啥用？Redis是如何判断数据是否过期的呢？"><a href="#Redis给缓存数据设置过期时间有啥用？Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis给缓存数据设置过期时间有啥用？Redis是如何判断数据是否过期的呢？"></a>Redis给缓存数据设置过期时间有啥用？Redis是如何判断数据是否过期的呢？</h3><h3 id="Redis事务了解吗？（Redis可以通过MULTI、EXEC、DISCARD、WATCH等命令来实现事务功能）"><a href="#Redis事务了解吗？（Redis可以通过MULTI、EXEC、DISCARD、WATCH等命令来实现事务功能）" class="headerlink" title="Redis事务了解吗？（Redis可以通过MULTI、EXEC、DISCARD、WATCH等命令来实现事务功能）"></a>Redis事务了解吗？（Redis可以通过<code>MULTI</code>、<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>等命令来实现事务功能）</h3><h3 id="Redis批量操作的方式有哪些？"><a href="#Redis批量操作的方式有哪些？" class="headerlink" title="Redis批量操作的方式有哪些？"></a>Redis批量操作的方式有哪些？</h3><h3 id="缓存穿透和缓存雪崩问题了解吗？有哪些解决办法？"><a href="#缓存穿透和缓存雪崩问题了解吗？有哪些解决办法？" class="headerlink" title="缓存穿透和缓存雪崩问题了解吗？有哪些解决办法？"></a>缓存穿透和缓存雪崩问题了解吗？有哪些解决办法？</h3><h3 id="如何基于Redis实现分布式锁？"><a href="#如何基于Redis实现分布式锁？" class="headerlink" title="如何基于Redis实现分布式锁？"></a>如何基于Redis实现分布式锁？</h3><h3 id="什么是Sentinel？有什么用？"><a href="#什么是Sentinel？有什么用？" class="headerlink" title="什么是Sentinel？有什么用？"></a>什么是Sentinel？有什么用？</h3><h3 id="Sentinel如何检测节点是否下线？主观下线与客观下线的区别？"><a href="#Sentinel如何检测节点是否下线？主观下线与客观下线的区别？" class="headerlink" title="Sentinel如何检测节点是否下线？主观下线与客观下线的区别？"></a>Sentinel如何检测节点是否下线？主观下线与客观下线的区别？</h3><h3 id="Sentinel是如何实现故障转移的？"><a href="#Sentinel是如何实现故障转移的？" class="headerlink" title="Sentinel是如何实现故障转移的？"></a>Sentinel是如何实现故障转移的？</h3><h3 id="Sentinel是如何选择出新的master（选举机制）？"><a href="#Sentinel是如何选择出新的master（选举机制）？" class="headerlink" title="Sentinel是如何选择出新的master（选举机制）？"></a>Sentinel是如何选择出新的master（选举机制）？</h3><h3 id="如何从Sentinel集群中选择出Leader？"><a href="#如何从Sentinel集群中选择出Leader？" class="headerlink" title="如何从Sentinel集群中选择出Leader？"></a>如何从Sentinel集群中选择出Leader？</h3><h3 id="Sentinel可以防止脑裂吗？"><a href="#Sentinel可以防止脑裂吗？" class="headerlink" title="Sentinel可以防止脑裂吗？"></a>Sentinel可以防止脑裂吗？</h3><h3 id="为什么需要Redis-Cluster？解决了什么问题？有什么优势？"><a href="#为什么需要Redis-Cluster？解决了什么问题？有什么优势？" class="headerlink" title="为什么需要Redis Cluster？解决了什么问题？有什么优势？"></a>为什么需要Redis Cluster？解决了什么问题？有什么优势？</h3><h3 id="Redis-Cluster是如何分片的？"><a href="#Redis-Cluster是如何分片的？" class="headerlink" title="Redis Cluster是如何分片的？"></a>Redis Cluster是如何分片的？</h3><h3 id="为什么Redis-Cluster的哈希槽时16384个？"><a href="#为什么Redis-Cluster的哈希槽时16384个？" class="headerlink" title="为什么Redis Cluster的哈希槽时16384个？"></a>为什么Redis Cluster的哈希槽时16384个？</h3><h3 id="如何确定给定key的应该分布到哪个哈希槽中？"><a href="#如何确定给定key的应该分布到哪个哈希槽中？" class="headerlink" title="如何确定给定key的应该分布到哪个哈希槽中？"></a>如何确定给定key的应该分布到哪个哈希槽中？</h3><h3 id="Redis-Cluster支持重新分配哈希槽吗？"><a href="#Redis-Cluster支持重新分配哈希槽吗？" class="headerlink" title="Redis Cluster支持重新分配哈希槽吗？"></a>Redis Cluster支持重新分配哈希槽吗？</h3><h3 id="Redis-Cluster扩容缩容期间可以提供服务吗？"><a href="#Redis-Cluster扩容缩容期间可以提供服务吗？" class="headerlink" title="Redis Cluster扩容缩容期间可以提供服务吗？"></a>Redis Cluster扩容缩容期间可以提供服务吗？</h3><h3 id="Redis-Cluster中的节点是怎么进行通信的？"><a href="#Redis-Cluster中的节点是怎么进行通信的？" class="headerlink" title="Redis Cluster中的节点是怎么进行通信的？"></a>Redis Cluster中的节点是怎么进行通信的？</h3><h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><h3 id="项目中用ES做了什么？ES可以帮助我们做什么？"><a href="#项目中用ES做了什么？ES可以帮助我们做什么？" class="headerlink" title="项目中用ES做了什么？ES可以帮助我们做什么？"></a>项目中用ES做了什么？ES可以帮助我们做什么？</h3><h3 id="Lucene是什么？为什么不直接用Lucene？"><a href="#Lucene是什么？为什么不直接用Lucene？" class="headerlink" title="Lucene是什么？为什么不直接用Lucene？"></a>Lucene是什么？为什么不直接用Lucene？</h3><h3 id="为什么用ES不用MySQL？（两者应用场景不同）"><a href="#为什么用ES不用MySQL？（两者应用场景不同）" class="headerlink" title="为什么用ES不用MySQL？（两者应用场景不同）"></a>为什么用ES不用MySQL？（两者应用场景不同）</h3><h3 id="为什么用ES不用Hbase？（两者应用场景不同）"><a href="#为什么用ES不用Hbase？（两者应用场景不同）" class="headerlink" title="为什么用ES不用Hbase？（两者应用场景不同）"></a>为什么用ES不用Hbase？（两者应用场景不同）</h3><h3 id="为什么ES检索比较快？倒排索引和正排索引是什么？倒排索引由什么组成？两者区别是什么？"><a href="#为什么ES检索比较快？倒排索引和正排索引是什么？倒排索引由什么组成？两者区别是什么？" class="headerlink" title="为什么ES检索比较快？倒排索引和正排索引是什么？倒排索引由什么组成？两者区别是什么？"></a>为什么ES检索比较快？倒排索引和正排索引是什么？倒排索引由什么组成？两者区别是什么？</h3><h3 id="分词器什么用？项目用的是什么分词器？如果我们要基于拼音搜索应该如何做？"><a href="#分词器什么用？项目用的是什么分词器？如果我们要基于拼音搜索应该如何做？" class="headerlink" title="分词器什么用？项目用的是什么分词器？如果我们要基于拼音搜索应该如何做？"></a>分词器什么用？项目用的是什么分词器？如果我们要基于拼音搜索应该如何做？</h3><h3 id="项目中ES和MySQL的数据是如何进行同步的？"><a href="#项目中ES和MySQL的数据是如何进行同步的？" class="headerlink" title="项目中ES和MySQL的数据是如何进行同步的？"></a>项目中ES和MySQL的数据是如何进行同步的？</h3><h3 id="ES集群中的数据是如何被分配的（分片）？自定义路由有什么好处？"><a href="#ES集群中的数据是如何被分配的（分片）？自定义路由有什么好处？" class="headerlink" title="ES集群中的数据是如何被分配的（分片）？自定义路由有什么好处？"></a>ES集群中的数据是如何被分配的（分片）？自定义路由有什么好处？</h3><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="网络分层模型"><a href="#网络分层模型" class="headerlink" title="网络分层模型"></a>网络分层模型</h2><h3 id="OSI与TCP-IP各层的结构与功能"><a href="#OSI与TCP-IP各层的结构与功能" class="headerlink" title="OSI与TCP/IP各层的结构与功能"></a>OSI与TCP/IP各层的结构与功能</h3><h4 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h4><blockquote>
<p><strong>OSI七层模型</strong>是国际标准化组织提出的一个网络分层模型。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>结构</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>为计算机用户提供服务</td>
</tr>
<tr>
<td>表示层</td>
<td>数据处理（编解码、加密解密、压缩解压缩）</td>
</tr>
<tr>
<td>会话层</td>
<td>管理（建立、维护、重连）应用程序之间的会话</td>
</tr>
<tr>
<td>传输层</td>
<td>为两台主机进程之间的通信提供通用的数据传输服务</td>
</tr>
<tr>
<td>网络层</td>
<td>路由和寻址（决定数据在网络的游走路径）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧编码和误差纠正控制</td>
</tr>
<tr>
<td>物理层</td>
<td>透明地传送比特流传输</td>
</tr>
</tbody>
</table>
</div>
<h4 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h4><blockquote>
<p><strong>TCP/IP四层模型</strong>是目前被广泛采用的一种模型。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>结构</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>由OSI七层模型中的应用层、表示层、会话层组成。功能也是三层功能之和</td>
</tr>
<tr>
<td>传输层</td>
<td>为两台主机进程之间的通信提供通用的数据传输服务</td>
</tr>
<tr>
<td>网络层</td>
<td>路由和寻址（决定数据在网络的游走路径）</td>
</tr>
<tr>
<td>网络接口层</td>
<td>由OSI七层模型中的数据链路层和物理层组成。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="为什么网络要分层？"><a href="#为什么网络要分层？" class="headerlink" title="为什么网络要分层？"></a>为什么网络要分层？</h3><p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p>分层原因：</p>
<ul>
<li><strong>各层之间相互独立</strong>：各层之间不需要关注其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了。</li>
<li><strong>提高了整体的灵活性</strong>：每一层都可以使用最合适的技术来实现，只需要保证提供的功能以及暴露的接口的规则没有改变就行了。</li>
<li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。</li>
</ul>
<h3 id="OSI与TCP-IP各层都有哪些协议？"><a href="#OSI与TCP-IP各层都有哪些协议？" class="headerlink" title="OSI与TCP/IP各层都有哪些协议？"></a>OSI与TCP/IP各层都有哪些协议？</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><img src="/img/Java面试问题&amp;解答/application-layer-protocol.png" alt="应用层常见协议"></p>
<ul>
<li>HTTP超文本传输协议：</li>
<li>SMTP简单邮件发送协议：</li>
<li>POP3/IMAP邮件接收协议：</li>
<li>FTP文件传输协议：</li>
<li>Telnet远程登陆协议：</li>
<li>SSH安全的网络传输协议：</li>
<li>RTP实施传输协议：</li>
<li>DNS域名管理系统：</li>
</ul>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p><img src="/img/Java面试问题&amp;解答/transport-layer-protocol.png" alt="传输层常见协议"></p>
<ul>
<li><strong>TCP传输控制协议</strong>：提供<strong>面向连接</strong>的，<strong>可靠</strong>的数据传输服务。</li>
<li><strong>UDP用户数据协议</strong>：提供<strong>无连接</strong>的，<strong>尽最大努力</strong>的数据传输服务（不保证数据传输的可靠性）,简单高效。</li>
</ul>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p><img src="/img/Java面试问题&amp;解答/nerwork-layer-protocol-040eb203.png" alt="网络层常见协议"></p>
<ul>
<li>IP网际协议：</li>
<li>ARP地址解析协议：</li>
<li>ICMP互联网控制报文协议：</li>
<li>NAT网络地址转换协议：</li>
<li>OSPF开放式最短路径优先：</li>
<li>RIP路由信息协议：</li>
<li>BGP边界网关协议：</li>
</ul>
<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><h3 id="TCP的三次握手与四次挥手的内容？TCP为什么连接是三次握手而断开是四次握手？"><a href="#TCP的三次握手与四次挥手的内容？TCP为什么连接是三次握手而断开是四次握手？" class="headerlink" title="TCP的三次握手与四次挥手的内容？TCP为什么连接是三次握手而断开是四次握手？"></a>TCP的三次握手与四次挥手的内容？TCP为什么连接是三次握手而断开是四次握手？</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/img/Java面试问题&amp;解答/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解"></p>
<p>三次握手的目的是建立可靠的通信信道，最主要的目的就是<strong>双方确认自己与对方的发送和接收是正常的</strong>。</p>
<ol>
<li><p><strong>第一次握手</strong>：客户端发送带有SYN（SEQ=x）标志的数据包到服务端。然后客户端进入<strong>SYN_SEND</strong>状态，等待服务器的确认。</p>
</li>
<li><p><strong>第二次握手</strong>：服务端发送带有SYN+ACK（SEQ=y，ACK=x+1）标志的数据包到客户端，然后服务端进入<strong>SYN_RECV</strong>状态。</p>
<p><strong>传回ACK还要再传回SYN的原因</strong>：传回ACK只是为了告诉客户端从客户端到服务端的通信是正常的，回传SYN是为了建立并确定从服务端到客户端的通信是否正常。</p>
</li>
<li><p><strong>第三次握手</strong>：客户端发送带有ACK（ACK=y+1）标志的数据包到服务端。然后客户端和服务端都进入<strong>ESTABLISHED</strong>状态，完成TCP三次握手。</p>
</li>
</ol>
<p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><img src="/img/Java面试问题&amp;解答/tcp-waves-four-times.png" alt="TCP 四次挥手图解"></p>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ol>
<li><strong>第一次挥手</strong>：客户端发送一个FIN（SEQ=x）标志的数据包到服务端，用来关闭客户端到服务器的数据传送。然后客户端进入<strong>FIN-WAIT-1</strong>状态。</li>
<li><strong>第二次挥手</strong>：服务器收到这个FIN（SEQ=x）标志的数据包，它发送一个ACK（ACK=x+1）标志的数据包到客户端。然后此时服务端进入<strong>CLOSE-WAIT</strong>状态。客户端进入<strong>FIN-WAIT-2</strong>状态。</li>
<li><strong>第三次挥手</strong>：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包到客户端请求关闭连接，然后，服务端进入 <strong>LAST-ACK</strong> 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK=y+1)标志的数据包到服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 <strong>CLOSE</strong> 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h4 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="为什么要四次挥手？"></a>为什么要四次挥手？</h4><p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<h3 id="TCP与UDP的区别及使用场景"><a href="#TCP与UDP的区别及使用场景" class="headerlink" title="TCP与UDP的区别及使用场景"></a>TCP与UDP的区别及使用场景</h3><h4 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是，在传递数据之前，会有三次握手来建立连接，而且数据传递时，有确认、窗口、重传、拥塞控制机制。可以保证数据无差错、不丢失、不重复、并且按序到达。</td>
<td>否，远地主机在收到UDP保温后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报字段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20~60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否，只支持点对点通信</td>
<td>是，支持一对一、一对多、多对一、多对多；</td>
</tr>
</tbody>
</table>
</div>
<h4 id="TCP和UDP的使用场景"><a href="#TCP和UDP的使用场景" class="headerlink" title="TCP和UDP的使用场景"></a>TCP和UDP的使用场景</h4><ul>
<li><strong>UDP一般用于即时通信</strong>：比如语音、视频、直播等等。这些场景对传输数据的准确性要求不是特别高。</li>
<li><strong>TCP用于对传输准确性要求特别高的场景</strong>：比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h3 id="TCP是如何保证传输的可靠性？❗"><a href="#TCP是如何保证传输的可靠性？❗" class="headerlink" title="TCP是如何保证传输的可靠性？❗"></a>TCP是如何保证传输的可靠性？❗</h3><ul>
<li><strong>基于数据块传输</strong>：应用数据被分割成TCP认为最适合发送的数据块，再传输到网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：</li>
<li><strong>校验和</strong>：</li>
<li><strong>超时重传</strong>：</li>
<li><strong>流量控制</strong>：</li>
<li><strong>拥塞控制</strong>：当网络拥塞是，减少数据的发送。</li>
</ul>
<h3 id="HTTP基于TCP还是UDP？"><a href="#HTTP基于TCP还是UDP？" class="headerlink" title="HTTP基于TCP还是UDP？"></a>HTTP基于TCP还是UDP？</h3><p>HTTP 是应用层协议，它以 <strong>TCP（传输层）</strong>作为底层协议。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="HTTP状态码有哪些？"><a href="#HTTP状态码有哪些？" class="headerlink" title="HTTP状态码有哪些？"></a>HTTP状态码有哪些？</h3><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td>1XX</td>
<td>信息性状态码</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>成功状态码</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>重定向状态码</td>
<td>需要进行附加操作已完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>客户端错误状态码</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>服务器错误状态码</td>
<td>服务器处理请求出错</td>
</tr>
</tbody>
</table>
</div>
<h4 id="3XX-重定向状态码"><a href="#3XX-重定向状态码" class="headerlink" title="3XX 重定向状态码"></a>3XX 重定向状态码</h4><ul>
<li><strong>301 Moved Permanently</strong>：资源被永久重定向了，比如网站的网址更换了。</li>
<li><strong>302 Found</strong>：资源被临时重定向了。</li>
</ul>
<h4 id="4XX-客户端错误状态码"><a href="#4XX-客户端错误状态码" class="headerlink" title="4XX 客户端错误状态码"></a>4XX 客户端错误状态码</h4><ul>
<li><strong>400 Bad Request</strong>：发送的HTTP请求存在问题，比如参数不合法、请求方法错误等。</li>
<li><strong>401 Unauthorized</strong>：未认证却请求需要认证之后才能访问的资源。</li>
<li><strong>403 Forbidden</strong>：直接拒绝HTTP请求，不处理，一般针对非法请求。</li>
<li><strong>404 Not Found</strong>：你请求的资源未在服务端找到。</li>
<li><strong>409 Conflict</strong>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li>
</ul>
<h4 id="5XX-服务端错误状态码"><a href="#5XX-服务端错误状态码" class="headerlink" title="5XX 服务端错误状态码"></a>5XX 服务端错误状态码</h4><ul>
<li><strong>500 Internal Server Error</strong>：服务端出问题了（通常是服务端出Bug了）。</li>
<li><strong>502 Bad Gateway</strong>：我们的网关将请求转发到服务器，但是服务端返回的确是一个错误的相应。</li>
</ul>
<h3 id="一次完整的HTTP请求所经过的步骤"><a href="#一次完整的HTTP请求所经过的步骤" class="headerlink" title="一次完整的HTTP请求所经过的步骤"></a>一次完整的HTTP请求所经过的步骤</h3><ol>
<li><strong>DNS解析</strong>：浏览器向DNS服务器请求解析该URL中的域名所对应的<strong>IP地址</strong>。（通过URL得到IP地址）</li>
<li><strong>TCP连接</strong>：根据解析出IP地址与Web服务器的HTTP端口（默认为80）建立一个<strong>TCP套接字连接</strong>。</li>
<li><strong>发送HTTP请求</strong>：</li>
<li><strong>服务器处理请求并返回HTTP报文</strong></li>
<li><strong>浏览器解析渲染页面</strong></li>
<li><strong>连接结束</strong></li>
</ol>
<h3 id="HTTP协议了解吗？HTTP是基于TCP还是UDP的？"><a href="#HTTP协议了解吗？HTTP是基于TCP还是UDP的？" class="headerlink" title="HTTP协议了解吗？HTTP是基于TCP还是UDP的？"></a>HTTP协议了解吗？HTTP是基于TCP还是UDP的？</h3><blockquote>
<p>HTTP协议，全称超文本传输协议。因此，HTTP协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息。具体来说，<strong>主要是来规范浏览器和服务器端的行为</strong>。</p>
<p>HTTP是一个<strong>无状态</strong>协议。也就是说服务器不维护任何有关客户端过去所发请求的消息。</p>
</blockquote>
<p>HTTP 是应用层协议，它以 <strong>TCP（传输层）</strong>作为底层协议。</p>
<h3 id="HTTP报文的内容简单说一下！HTTP请求报文和响应报文中有哪些数据？"><a href="#HTTP报文的内容简单说一下！HTTP请求报文和响应报文中有哪些数据？" class="headerlink" title="HTTP报文的内容简单说一下！HTTP请求报文和响应报文中有哪些数据？"></a>HTTP报文的内容简单说一下！HTTP请求报文和响应报文中有哪些数据？</h3><blockquote>
<p>HTTP报文是面向文本的，因此在报文中的每一个字段都是一些ASCII码串。</p>
</blockquote>
<h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><blockquote>
<p>HTTP请求报文由3部分组成：请求行 + 请求头 + 请求体。</p>
</blockquote>
<p><img src="/img/Java面试问题&amp;解答/format,png" alt="image-20211224161037961"></p>
<h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><blockquote>
<p>HTTP响应报文由3部分组成：响应行 + 响应头 + 响应体。</p>
</blockquote>
<p><img src="/img/Java面试问题&amp;解答/format2,png" alt="image-20211224161004923"></p>
<h3 id="HTTP和HTTPS的区别了解吗？"><a href="#HTTP和HTTPS的区别了解吗？" class="headerlink" title="HTTP和HTTPS的区别了解吗？"></a>HTTP和HTTPS的区别了解吗？</h3><ul>
<li><strong>端口号</strong>：HTTP默认是80，HTTPS默认是443。</li>
<li><strong>URL前缀</strong>：HTTP的URL前缀是<code>http://</code>，HTTPS的URL前缀是<code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
<li><strong>SEO（搜索引擎优化）</strong></li>
</ul>
<h3 id="HTTP-1-0和HTTP-1-1有什么区别？"><a href="#HTTP-1-0和HTTP-1-1有什么区别？" class="headerlink" title="HTTP/1.0和HTTP/1.1有什么区别？"></a>HTTP/1.0和HTTP/1.1有什么区别？</h3><p><img src="/img/Java面试问题&amp;解答/http1.0-vs-http1.1.png" alt="HTTP/1.0 和 HTTP/1.1 对比"></p>
<ul>
<li><strong>连接方式</strong>：HTTP/1.0为短连接，HTTP/1.1支持长连接。</li>
<li><strong>状态响应码</strong>：HTTP/1.1中新加入了大量的状态码。</li>
<li><strong>缓存机制</strong>：在HTTP/1.0中主要使用Header里的if-Modified-Since，Expires来作为缓存判断的标准。HTTP/1.1则引入了更多的缓存控制策略，例如：Entity tag，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽</strong>：HTTP/1.0 中，存在一些浪费带宽的现象。HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host头（Host Header）处理</strong>：HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。</li>
</ul>
<h3 id="HTTP-1-1和HTTP-2-0有什么区别？"><a href="#HTTP-1-1和HTTP-2-0有什么区别？" class="headerlink" title="HTTP/1.1和HTTP/2.0有什么区别？"></a>HTTP/1.1和HTTP/2.0有什么区别？</h3><p><img src="/img/Java面试问题&amp;解答/http1.1-vs-http2.0.png" alt="HTTP/1.0 和 HTTP/1.1 对比"></p>
<ul>
<li><strong>IO多路复用</strong></li>
<li><strong>二进制帧</strong></li>
<li><strong>头部压缩</strong></li>
<li><strong>服务器推送</strong></li>
</ul>
<h3 id="HTTP-2-0和HTTP-3-0有什么区别？"><a href="#HTTP-2-0和HTTP-3-0有什么区别？" class="headerlink" title="HTTP/2.0和HTTP/3.0有什么区别？"></a>HTTP/2.0和HTTP/3.0有什么区别？</h3><p><img src="/img/Java面试问题&amp;解答/http2.0-vs-http3.0.png" alt="HTTP/2.0 和 HTTP/3.0 对比"></p>
<h3 id="HTTP长连接和短连接了解吗？"><a href="#HTTP长连接和短连接了解吗？" class="headerlink" title="HTTP长连接和短连接了解吗？"></a>HTTP长连接和短连接了解吗？</h3><h3 id="Cookie和Seesion的关系"><a href="#Cookie和Seesion的关系" class="headerlink" title="Cookie和Seesion的关系"></a>Cookie和Seesion的关系</h3><h3 id="URI和URL的区别是什么？"><a href="#URI和URL的区别是什么？" class="headerlink" title="URI和URL的区别是什么？"></a>URI和URL的区别是什么？</h3><ul>
<li>URI是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL是统一资源定位符，可以提供该资源的路径。它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h2><h3 id="PING命令的作用是什么？"><a href="#PING命令的作用是什么？" class="headerlink" title="PING命令的作用是什么？"></a>PING命令的作用是什么？</h3><blockquote>
<p>PING命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p>
</blockquote>
<p>PING命令的输出结果通常包括以下几部分：</p>
<ul>
<li><strong>请求报文信息</strong>：序列号，TTL（Time To Live）值。</li>
<li><strong>目标主机的域名或IP地址</strong>：输出结果的第一行。</li>
<li><strong>往返时间RTT</strong>：从发送请求报文到接收到响应报文的总时间，用来衡量网络连接的延迟。</li>
<li><strong>统计结果</strong>：包括发送的ICMP请求数据包数量、接收到的ICMP响应数据包数量、丢包率、往返时间的最小、平均、最大和标准偏差值。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; ping www.baidu.com <span class="comment"># 发送请求数据包到 www.baidu.com</span></span><br><span class="line"></span><br><span class="line">正在 Ping www.baidu.com [180.101.50.188] 具有 32 字节的数据:</span><br><span class="line">来自 180.101.50.188 的回复: 字节=32 时间=3ms TTL=51</span><br><span class="line">来自 180.101.50.188 的回复: 字节=32 时间=3ms TTL=51</span><br><span class="line">来自 180.101.50.188 的回复: 字节=32 时间=3ms TTL=51</span><br><span class="line">来自 180.101.50.188 的回复: 字节=32 时间=3ms TTL=51</span><br><span class="line"></span><br><span class="line">180.101.50.188 的 Ping 统计信息:</span><br><span class="line">    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，</span><br><span class="line">往返行程的估计时间(以毫秒为单位):</span><br><span class="line">    最短 = 3ms，最长 = 3ms，平均 = 3ms</span><br></pre></td></tr></table></figure>
<h3 id="PING命令的工作原理是什么？"><a href="#PING命令的工作原理是什么？" class="headerlink" title="PING命令的工作原理是什么？"></a>PING命令的工作原理是什么？</h3><p>PING是基于网络层的ICMP（互联网控制报文协议），其主要原理就是通过在网络上发送和接收ICMP报文实现的。</p>
<p>ICMP报文包含了类型字段，用于标识ICMP报文类型。ICMP报文的类型有很多种，大致可以分为两类：</p>
<ul>
<li><strong>查询报文类型</strong>：向目标主机发送请求并期望得到响应。</li>
<li><strong>差错报文类型</strong>：向源主机发送错误信息，用于报告网络中的错误情况。</li>
</ul>
<p>PING用到的ICMP Echo Request（类型为8）和ICMP Echo Reply（类型为0）属于查询报文类型。</p>
<ul>
<li>PING命令会向目标主机发送ICMP Echo Request；</li>
<li>如果两个主机的连通性正常，目标主机会返回一个对应的ICMP Echo Reply。</li>
</ul>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><h3 id="IP协议的作用是什么？"><a href="#IP协议的作用是什么？" class="headerlink" title="IP协议的作用是什么？"></a>IP协议的作用是什么？</h3><blockquote>
<p>IP（网际协议）是TCP/IP协议中最重要的协议之一，属于网络层协议。</p>
</blockquote>
<p>主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>
<p>目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</p>
<h3 id="什么是IP地址？IP寻址如何工作？"><a href="#什么是IP地址？IP寻址如何工作？" class="headerlink" title="什么是IP地址？IP寻址如何工作？"></a>什么是IP地址？IP寻址如何工作？</h3><h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><p>每个连入互联网的设备或域（如计算机、路由器、服务器等）都被分配一个<strong>IP地址</strong>，作为唯一标识符。每个IP地址都是一个字符序列。如 192.168.1.1(IPv4)。</p>
<h4 id="IP寻址"><a href="#IP寻址" class="headerlink" title="IP寻址"></a>IP寻址</h4><p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。</p>
<p>网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p>
<h3 id="IPv4和IPv6有什么区别？❗"><a href="#IPv4和IPv6有什么区别？❗" class="headerlink" title="IPv4和IPv6有什么区别？❗"></a>IPv4和IPv6有什么区别？❗</h3><p>IPv4是目前广泛使用的IP地址版本，其格式是由四组由点分隔的数字组成。大约由42亿个可用的IP地址。</p>
<p>IPv6 地址使用更复杂的格式，该格式使用由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv6 使用 128 位互联网地址，这意味着越有 2^128（3 开头的 39 位数字，恐怖如斯） 个可用 IP 地址。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h3 id="进程和线程的区别？"><a href="#进程和线程的区别？" class="headerlink" title="进程和线程的区别？"></a>进程和线程的区别？</h3><ul>
<li><strong>进程</strong>：是指计算机中正在运行的一个程序实例。</li>
<li><strong>线程</strong>：也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且专享进程的资源比如内存空间、文件句柄、网络连接等。</li>
</ul>
<p>区别：</p>
<p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区（JDK1.8之后的元空间）资源</strong>。<strong>但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</p>
<p>总结：</p>
<ul>
<li>线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。</li>
<li>线程和进程最大的不同在于基本上<strong>各进程是独立的，而各线程则不一定</strong>，因为同一进程中的线程极有可能会相互影响。</li>
<li><strong>线程执行开销小，但不利于资源的管理和保护</strong>；而进程正相反。</li>
</ul>
<h3 id="进程有哪几种状态？"><a href="#进程有哪几种状态？" class="headerlink" title="进程有哪几种状态？"></a>进程有哪几种状态？</h3><p>进程大致分为5种状态：</p>
<ul>
<li><strong>创建状态（new）</strong>：进程正在被创建，尚未到就绪状态。</li>
<li><strong>就绪状态（ready）</strong>：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源（处理器分配的时间片）即可运行。</li>
<li><strong>运行状态（running）</strong>：进程正在处理器上运行（单核CPU下任意时刻只有一个进程处于运行状态）。</li>
<li><strong>阻塞状态（waiting）</strong>：又称为等待状态，进程正在等待某一时间而暂定运行如等待某资源为可用或等待IO操作完成。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态（terminated）</strong>：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<p><img src="/img/Java面试问题&amp;解答/state-transition-of-process.png" alt="进程状态图转换图"></p>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><h3 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h3><ul>
<li><strong>互斥锁</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。例如：<code>synchronized</code>关键词和各种<code>Lock</code></li>
<li><strong>读写锁</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</li>
<li><strong>信号量</strong>：允许同一时刻多个线程访问统一资源，但是需要控制统一时刻访问此资源的最大线程数量。</li>
<li><strong>屏障</strong>：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。</li>
<li><strong>事件</strong>：Wait/Notify，通过通知操作的方式来保持多线程同步，还可以方便实现多线程优先级的比较操作。</li>
</ul>
<h3 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h3><blockquote>
<p><strong>PCB（Process Control Block）</strong> 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB。你可以将 PCB 视为进程的大脑。</p>
</blockquote>
<h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><p><img src="/img/Java面试问题&amp;解答/scheduling-algorithms-of-process.png" alt="常见进程调度算法"></p>
<ul>
<li><strong>先到先服务调度算法FCFS</strong>：从就绪队列中选择一个<strong>最先进入该队列的进程</strong>为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先调度算法SJF</strong>：从就绪队列中选出一个<strong>估计运行时间最短的进程</strong>为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法RR</strong>：时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。<strong>每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间</strong>。</li>
<li><strong>多级反馈队列调度算法MFQ</strong>：多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度算法Priority</strong>：<strong>为每个进程分配优先级，首先执行具有最高优先级的进程</strong>，依此类推。</li>
</ul>
<h3 id="什么是死锁？死锁的四个必要条件？解决死锁的方法"><a href="#什么是死锁？死锁的四个必要条件？解决死锁的方法" class="headerlink" title="什么是死锁？死锁的四个必要条件？解决死锁的方法"></a>什么是死锁？死锁的四个必要条件？解决死锁的方法</h3><blockquote>
<p>多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，<strong>因此程序不可能正常终止</strong></p>
</blockquote>
<h4 id="四个必要条件"><a href="#四个必要条件" class="headerlink" title="四个必要条件"></a>四个必要条件</h4><ul>
<li><strong>互斥</strong>：资源是非共享的，一次只能有一个进程可以使用。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占</li>
<li><strong>循环等待</strong>：</li>
</ul>
<p><strong>注意 ⚠️</strong>：这四个条件是产生死锁的 <strong>必要条件</strong> ，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。</p>
<h3 id="常见的内存管理机制"><a href="#常见的内存管理机制" class="headerlink" title="常见的内存管理机制"></a>常见的内存管理机制</h3><h3 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h3><h3 id="分段机制和分页机制的区别和共同点"><a href="#分段机制和分页机制的区别和共同点" class="headerlink" title="分段机制和分页机制的区别和共同点"></a>分段机制和分页机制的区别和共同点</h3><h3 id="分段机制和分页机制下的地址翻译过程分别是怎样的"><a href="#分段机制和分页机制下的地址翻译过程分别是怎样的" class="headerlink" title="分段机制和分页机制下的地址翻译过程分别是怎样的"></a>分段机制和分页机制下的地址翻译过程分别是怎样的</h3><h3 id="单级页表有什么问题？为什么需要多级页表？"><a href="#单级页表有什么问题？为什么需要多级页表？" class="headerlink" title="单级页表有什么问题？为什么需要多级页表？"></a>单级页表有什么问题？为什么需要多级页表？</h3><h3 id="TLB有什么用？使用TLB之后的地址翻译流程是怎样的？"><a href="#TLB有什么用？使用TLB之后的地址翻译流程是怎样的？" class="headerlink" title="TLB有什么用？使用TLB之后的地址翻译流程是怎样的？"></a>TLB有什么用？使用TLB之后的地址翻译流程是怎样的？</h3><h3 id="页缺失，常见的页面置换算法有哪些？"><a href="#页缺失，常见的页面置换算法有哪些？" class="headerlink" title="页缺失，常见的页面置换算法有哪些？"></a>页缺失，常见的页面置换算法有哪些？</h3><h3 id="硬链接和软链接有什么区别？"><a href="#硬链接和软链接有什么区别？" class="headerlink" title="硬链接和软链接有什么区别？"></a>硬链接和软链接有什么区别？</h3><h3 id="常见的磁盘调度算法有哪些？"><a href="#常见的磁盘调度算法有哪些？" class="headerlink" title="常见的磁盘调度算法有哪些？"></a>常见的磁盘调度算法有哪些？</h3><h1 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="算法和数据结构"></a>算法和数据结构</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="LRU算法了解吗？你能实现一个吗？"><a href="#LRU算法了解吗？你能实现一个吗？" class="headerlink" title="LRU算法了解吗？你能实现一个吗？"></a>LRU算法了解吗？你能实现一个吗？</h3><p>LRU算法又称最近最少使用算法，它的基本思想是长期不被使用的数据，在未来被用到的几率也不大，所以当新的数据进来时我们可以优先把这些数据替换掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 键和值</span></span><br><span class="line">        <span class="type">int</span> k, v;</span><br><span class="line">        <span class="comment">// 左右节点</span></span><br><span class="line">        Node l, r;</span><br><span class="line">        Node(<span class="type">int</span> _k, <span class="type">int</span> _v) &#123;</span><br><span class="line">            k = _k;</span><br><span class="line">            v = _v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    Node head, tail; <span class="comment">// 头节点和尾节点</span></span><br><span class="line">    Map&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        n = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">Node</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        head.r = tail;</span><br><span class="line">        tail.l = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            refresh(node);</span><br><span class="line">            <span class="keyword">return</span> node.v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key)) &#123;</span><br><span class="line">            node = map.get(key);</span><br><span class="line">            node.v = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(map.size() == n) &#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">del</span> <span class="operator">=</span> tail.l;</span><br><span class="line">                map.remove(del.k);</span><br><span class="line">                delete(del);</span><br><span class="line">            &#125;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">Node</span>(key, value);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">        refresh(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">// refresh 操作分两步：</span></span><br><span class="line">    <span class="comment">// 1. 先将当前节点从双向链表种删除</span></span><br><span class="line">    <span class="comment">// 2. 将当前节点添加到双向链表头部</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        delete(node);</span><br><span class="line">        node.r = head.r;</span><br><span class="line">        node.l = head;</span><br><span class="line">        head.r.l = node;</span><br><span class="line">        head.r = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// delete 操作：将当前节点从双向链表中移除</span></span><br><span class="line">    <span class="comment">// 由于我们预先建立 head 和 tail 两位哨兵，因此如果 node.l 不为空，则代表了 node 本身存在于双向链表（不是新节点）</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.l != <span class="literal">null</span>) &#123;</span><br><span class="line">         	<span class="type">Node</span> <span class="variable">left</span> <span class="operator">=</span> node.l;</span><br><span class="line">            left.r = node.r;</span><br><span class="line">            node.r.l = left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="写排序算法（快排、堆排）"><a href="#写排序算法（快排、堆排）" class="headerlink" title="写排序算法（快排、堆排）"></a>写排序算法（快排、堆排）</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++; <span class="keyword">while</span>(a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span>(a[j] &gt; x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    quickSort(a, l, j);</span><br><span class="line">    quickSort(a, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(a, l, mid);</span><br><span class="line">    mergeSort(a, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt; a[j]) tmp[k ++] = a[j ++];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++] = a[i ++];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++] = a[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[k ++] = a[j ++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++) a[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用数组实现一个栈"><a href="#使用数组实现一个栈" class="headerlink" title="使用数组实现一个栈"></a>使用数组实现一个栈</h3><h3 id="使用数组实现一个队列"><a href="#使用数组实现一个队列" class="headerlink" title="使用数组实现一个队列"></a>使用数组实现一个队列</h3><h3 id="实现一个链表、反转链表"><a href="#实现一个链表、反转链表" class="headerlink" title="实现一个链表、反转链表"></a>实现一个链表、反转链表</h3><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h3><h3 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h3><h3 id="队列的分类、应用场景"><a href="#队列的分类、应用场景" class="headerlink" title="队列的分类、应用场景"></a>队列的分类、应用场景</h3><h3 id="红黑树的特点、红黑树-vs-二叉查找树"><a href="#红黑树的特点、红黑树-vs-二叉查找树" class="headerlink" title="红黑树的特点、红黑树 vs 二叉查找树"></a>红黑树的特点、红黑树 vs 二叉查找树</h3><h3 id="哈希表、哈希表应用场景"><a href="#哈希表、哈希表应用场景" class="headerlink" title="哈希表、哈希表应用场景"></a>哈希表、哈希表应用场景</h3><h3 id="布隆过滤器了解吗？"><a href="#布隆过滤器了解吗？" class="headerlink" title="布隆过滤器了解吗？"></a>布隆过滤器了解吗？</h3><h1 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h1><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="何为设计模式？有哪些常见的设计模式？"><a href="#何为设计模式？有哪些常见的设计模式？" class="headerlink" title="何为设计模式？有哪些常见的设计模式？"></a>何为设计模式？有哪些常见的设计模式？</h3><h3 id="单例模式了解吗？说一下单例模式的使用场景。手写一个单例模式的实现。"><a href="#单例模式了解吗？说一下单例模式的使用场景。手写一个单例模式的实现。" class="headerlink" title="单例模式了解吗？说一下单例模式的使用场景。手写一个单例模式的实现。"></a>单例模式了解吗？说一下单例模式的使用场景。手写一个单例模式的实现。</h3><h3 id="观察者模式了解吗？说一下观察者模式的使用场景。"><a href="#观察者模式了解吗？说一下观察者模式的使用场景。" class="headerlink" title="观察者模式了解吗？说一下观察者模式的使用场景。"></a>观察者模式了解吗？说一下观察者模式的使用场景。</h3><h3 id="工厂模式了解吗？说一下工厂模式的使用场景。"><a href="#工厂模式了解吗？说一下工厂模式的使用场景。" class="headerlink" title="工厂模式了解吗？说一下工厂模式的使用场景。"></a>工厂模式了解吗？说一下工厂模式的使用场景。</h3><h3 id="责任链模式了解吗？哪些开源项目（Netty、MyBatis-…）中用到了责任链模式？怎么用的？"><a href="#责任链模式了解吗？哪些开源项目（Netty、MyBatis-…）中用到了责任链模式？怎么用的？" class="headerlink" title="责任链模式了解吗？哪些开源项目（Netty、MyBatis …）中用到了责任链模式？怎么用的？"></a>责任链模式了解吗？哪些开源项目（Netty、MyBatis …）中用到了责任链模式？怎么用的？</h3><h3 id="SOLID原则了解吗？简单谈谈自己对于单一职责和开闭原则的理解。"><a href="#SOLID原则了解吗？简单谈谈自己对于单一职责和开闭原则的理解。" class="headerlink" title="SOLID原则了解吗？简单谈谈自己对于单一职责和开闭原则的理解。"></a>SOLID原则了解吗？简单谈谈自己对于单一职责和开闭原则的理解。</h3><h3 id="阅读Spring源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？"><a href="#阅读Spring源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？" class="headerlink" title="阅读Spring源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？"></a>阅读Spring源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？</h3><h2 id="常见框架-Spring"><a href="#常见框架-Spring" class="headerlink" title="常见框架 - Spring"></a>常见框架 - Spring</h2><h3 id="什么是Spring框架？"><a href="#什么是Spring框架？" class="headerlink" title="什么是Spring框架？"></a>什么是Spring框架？</h3><h3 id="列举一些重要的Spring模块？"><a href="#列举一些重要的Spring模块？" class="headerlink" title="列举一些重要的Spring模块？"></a>列举一些重要的Spring模块？</h3><h3 id="谈谈自己对于Spring-IOC和AOP的理解"><a href="#谈谈自己对于Spring-IOC和AOP的理解" class="headerlink" title="谈谈自己对于Spring IOC和AOP的理解"></a>谈谈自己对于Spring IOC和AOP的理解</h3><h3 id="Spring-Bean-的生命周期说一下"><a href="#Spring-Bean-的生命周期说一下" class="headerlink" title="Spring Bean 的生命周期说一下"></a>Spring Bean 的生命周期说一下</h3><h3 id="Spring种的bean的作用域有哪些？"><a href="#Spring种的bean的作用域有哪些？" class="headerlink" title="Spring种的bean的作用域有哪些？"></a>Spring种的bean的作用域有哪些？</h3><h3 id="拦截器和过滤器了解吗？"><a href="#拦截器和过滤器了解吗？" class="headerlink" title="拦截器和过滤器了解吗？"></a>拦截器和过滤器了解吗？</h3><h3 id="Spring-动态代理默认用哪一种？"><a href="#Spring-动态代理默认用哪一种？" class="headerlink" title="Spring 动态代理默认用哪一种？"></a>Spring 动态代理默认用哪一种？</h3><h3 id="hibernate-和-mybatis-区别"><a href="#hibernate-和-mybatis-区别" class="headerlink" title="hibernate 和 mybatis 区别"></a>hibernate 和 mybatis 区别</h3><h3 id="Spring-Boot-和-Spring-的区别"><a href="#Spring-Boot-和-Spring-的区别" class="headerlink" title="Spring Boot 和 Spring 的区别"></a>Spring Boot 和 Spring 的区别</h3><h3 id="说出使用Spring-Boot的主要优点"><a href="#说出使用Spring-Boot的主要优点" class="headerlink" title="说出使用Spring Boot的主要优点"></a>说出使用Spring Boot的主要优点</h3><h3 id="什么是Spring-Boot-Starter？"><a href="#什么是Spring-Boot-Starter？" class="headerlink" title="什么是Spring Boot Starter？"></a>什么是Spring Boot Starter？</h3><h3 id="介绍一下-SpringBootApplication注解"><a href="#介绍一下-SpringBootApplication注解" class="headerlink" title="介绍一下@SpringBootApplication注解"></a>介绍一下<code>@SpringBootApplication</code>注解</h3><h3 id="Spring-Boot-的自动配置是如何实现的？"><a href="#Spring-Boot-的自动配置是如何实现的？" class="headerlink" title="Spring Boot 的自动配置是如何实现的？"></a>Spring Boot 的自动配置是如何实现的？</h3><h3 id="Spring-Boot支持哪些嵌入式web容器？"><a href="#Spring-Boot支持哪些嵌入式web容器？" class="headerlink" title="Spring Boot支持哪些嵌入式web容器？"></a>Spring Boot支持哪些嵌入式web容器？</h3><h2 id="常见框架-Netty"><a href="#常见框架-Netty" class="headerlink" title="常见框架 - Netty"></a>常见框架 - Netty</h2>
    </div>

    
    
    <div class="post-widgets">
    <div
      class="social-share"
      
        data-sites="weibo,qq,wechat,tencent,douban,qzone,linkedin,diandian,facebook,twitter,google"
      
      
        data-wechat-qrcode-title="share.title"
      
      
        data-wechat-qrcode-helper="share.prompt"
      
    >
    </div>
  </div>
  <script src="https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js"></script><script src="//sdk.jinrishici.com/v2/browser/jinrishici.js"></script>
<script>
  jinrishici.load((result) => {
    let jrsc = document.getElementById('jrsc');
    const data = result.data;
    let author = data.origin.author;
    let title = '《' + data.origin.title + '》';
    let content = data.content.substr(0, data.content.length - 1);
    let dynasty = data.origin.dynasty.substr(0, data.origin.dynasty.length - 1);
    jrsc.innerText = content + ' @ ' + dynasty + '·' + author + title;
  });
</script>
<div style="text-align: center"><span id="jrsc" >正在加载今日诗词....</span></div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Atopos·
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://example.com/2022/07/05/TODO/Java%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98&%E8%A7%A3%E7%AD%94/" title="Java面试问题&amp;解答">http://example.com/2022/07/05/TODO/Java面试问题&解答/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JAVA/" rel="tag"># JAVA</a>
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/04/Ubuntu/07drawCFG/" rel="prev" title="LLVM CFG控制流图可视化">
      <i class="fa fa-chevron-left"></i> LLVM CFG控制流图可视化
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/21/Ubuntu/08InstallAnconda/" rel="next" title="Ubuntu16.04 下Anaconda的安装与使用">
      Ubuntu16.04 下Anaconda的安装与使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java"><span class="nav-number">1.</span> <span class="nav-text">Java</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E9%9B%86%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%90%84%E8%87%AA%E5%8D%A0%E7%94%A8%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%EF%BC%9F"><span class="nav-number">1.1.1.</span> <span class="nav-text">Java中的集中基本数据类是什么？对应的包装类型是什么？各自占用多少字节？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.2.</span> <span class="nav-text">String、StringBuilder、StringBuffer的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String-s1-new-String-quot-abc-quot-%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-number">1.1.3.</span> <span class="nav-text">String s1 &#x3D; new String(&quot;abc&quot;);这段代码创建了几个字符串对象？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.4.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode%E5%92%8Cequals%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.1.5.</span> <span class="nav-text">hashCode和equals的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">1.1.6.</span> <span class="nav-text">包装类型的缓存机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.7.</span> <span class="nav-text">自动装箱与拆箱了解吗？原理是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-number">1.1.8.</span> <span class="nav-text">深拷贝和浅拷贝的区别了解吗？什么是引用拷贝？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9Java%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E2%9D%97"><span class="nav-number">1.1.9.</span> <span class="nav-text">谈谈对Java注解的理解，解决了什么问题？❗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Exception%E5%92%8CError%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.10.</span> <span class="nav-text">Exception和Error有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%8F%8D%E5%B0%84%EF%BC%9F%E5%8F%8D%E5%B0%84%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E7%90%86%E8%A7%A3%E5%8F%8D%E5%B0%84%E7%9A%84%EF%BC%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E5%8F%8D%E5%B0%84%EF%BC%89%EF%BC%9F%E2%9D%97"><span class="nav-number">1.1.11.</span> <span class="nav-text">Java反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？❗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E6%B3%9B%E5%9E%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%9F%E2%9D%97"><span class="nav-number">1.1.12.</span> <span class="nav-text">Java泛型了解吗？什么是类型擦除？介绍一下常用的通配符？❗</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%E6%9C%BA%E5%88%B6"><span class="nav-number">1.1.12.1.</span> <span class="nav-text">泛型擦除机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">1.1.12.2.</span> <span class="nav-text">通配符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%92%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%9B%E5%9E%8BT%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.12.2.1.</span> <span class="nav-text">通配符?和常用的泛型T有什么区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8A%E8%BE%B9%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6extends"><span class="nav-number">1.1.12.2.2.</span> <span class="nav-text">上边界通配符extends</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8B%E8%BE%B9%E7%95%8C%E9%80%9A%E9%85%8D%E7%AC%A6super"><span class="nav-number">1.1.12.2.3.</span> <span class="nav-text">下边界通配符super</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#extends-xxx%E5%92%8C-super-xxx%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.12.2.4.</span> <span class="nav-text">? extends xxx和? super xxx的区别？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">1.1.13.</span> <span class="nav-text">内部类了解吗？匿名内部类了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BIO%E3%80%81NIO%E3%80%81AIO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.1.14.</span> <span class="nav-text">BIO、NIO、AIO有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="nav-number">1.2.</span> <span class="nav-text">Java集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4List%E3%80%81Set%E3%80%81Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%89%E8%80%85%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="nav-number">1.2.1.</span> <span class="nav-text">说说List、Set、Map三者的区别？三者底层的数据结构？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="nav-number">1.2.2.</span> <span class="nav-text">有哪些集合是线程不安全的？怎么解决呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83HashSet%E3%80%81LinkedHashSet%E3%80%81TreeSet%E4%B8%89%E8%80%85%E7%9A%84%E5%BC%82%E5%90%8C"><span class="nav-number">1.2.3.</span> <span class="nav-text">比较HashSet、LinkedHashSet、TreeSet三者的异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FHashMap%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9FHashMap%E5%92%8CTreeMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.4.</span> <span class="nav-text">HashMap和HashTable的区别？HashMap和HashSet的区别？HashMap和TreeMap的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">HashMap和HashTable的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%92%8CHashSet%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">HashMap和HashSet的区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E5%92%8CTreeMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">HashMap和TreeMap的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.2.5.</span> <span class="nav-text">HashMap的底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8%E4%B9%8B%E5%89%8D"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">JDK1.8之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8%E4%B9%8B%E5%90%8E"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">JDK1.8之后</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9%EF%BC%9F"><span class="nav-number">1.2.6.</span> <span class="nav-text">HashMap的长度为什么是2的幂次方？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">1.2.7.</span> <span class="nav-text">ConcurrentHashMap和HashTable的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E5%BA%95%E5%B1%82%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-number">1.2.8.</span> <span class="nav-text">ConcurrentHashMap线程安全的具体实现方式&#x2F;底层具体实现？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8%E4%B9%8B%E5%89%8D-1"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">JDK1.8之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK1-8%E4%B9%8B%E5%90%8E-1"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">JDK1.8之后</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E2%9D%97"><span class="nav-number">1.3.</span> <span class="nav-text">JVM❗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.1.</span> <span class="nav-text">JVM内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">程序计数器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">Java虚拟机栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">方法区</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0"><span class="nav-number">1.3.2.</span> <span class="nav-text">JVM调优参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">堆内存相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E5%A0%86%E5%86%85%E5%AD%98-Xms%E5%92%8C-Xmx"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">显示指定堆内存-Xms和-Xmx</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E6%B0%B8%E4%B9%85%E4%BB%A3-%E5%85%83%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">显示指定永久代&#x2F;元空间的大小</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9B%B8%E5%85%B3"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">垃圾收集相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">垃圾回收器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#GC%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95"><span class="nav-number">1.3.2.2.2.</span> <span class="nav-text">GC日志记录</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%9F%E4%BD%95%E6%97%B6%E7%B1%BB%E5%8A%A0%E8%BD%BD%EF%BC%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="nav-number">1.3.3.</span> <span class="nav-text">什么是类加载？何时类加载？类加载流程？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">类的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">类加载流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD"><span class="nav-number">1.3.3.2.1.</span> <span class="nav-text">加载</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81"><span class="nav-number">1.3.3.2.2.</span> <span class="nav-text">验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%87%86%E5%A4%87"><span class="nav-number">1.3.3.2.3.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%A3%E6%9E%90"><span class="nav-number">1.3.3.2.4.</span> <span class="nav-text">解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.3.3.2.5.</span> <span class="nav-text">初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%9F%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="nav-number">1.3.4.</span> <span class="nav-text">知道哪些类加载器？类加载器之间的关系？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E7%BB%93%E5%90%88Tomcat%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%88Tomcat%E5%A6%82%E4%BD%95%E6%89%93%E7%A0%B4%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%EF%BC%9F%EF%BC%89%E2%9D%97"><span class="nav-number">1.3.5.</span> <span class="nav-text">类加载器的双亲委派了解吗？结合Tomcat说一下双亲委派（Tomcat如何打破双亲委托机制？）❗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%EF%BC%9F"><span class="nav-number">1.3.6.</span> <span class="nav-text">为什么需要双亲委派？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">1.3.7.</span> <span class="nav-text">Java内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E4%B8%AD%E5%AD%98%E6%94%BE%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%EF%BC%9F%E5%A0%86%E4%B8%AD%E5%91%A2%EF%BC%9F"><span class="nav-number">1.3.8.</span> <span class="nav-text">栈中存放什么数据？堆中呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E6%94%BE%E5%9C%A8%E5%93%AA%E4%B8%AA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="nav-number">1.3.9.</span> <span class="nav-text">大对象放在哪个内存区域？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%8C%BA%E5%A6%82%E4%BD%95%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="nav-number">1.3.10.</span> <span class="nav-text">堆区如何分类？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="nav-number">1.3.11.</span> <span class="nav-text">垃圾回收有哪些算法？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.11.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.11.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.11.3.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%F0%9F%92%A1"><span class="nav-number">1.3.11.4.</span> <span class="nav-text">分代收集算法💡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E7%9A%84%E5%85%A8%E9%83%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">1.3.12.</span> <span class="nav-text">GC的全部流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E4%BA%A1%E5%AF%B9%E8%B1%A1%E5%88%A4%E6%96%AD"><span class="nav-number">1.3.12.1.</span> <span class="nav-text">死亡对象判断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">1.3.12.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">1.3.12.1.2.</span> <span class="nav-text">可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">1.3.12.2.</span> <span class="nav-text">垃圾回收</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GC%E4%B8%AD%E8%80%81%E5%B9%B4%E4%BB%A3%E7%94%A8%E4%BB%80%E4%B9%88%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-number">1.3.13.</span> <span class="nav-text">GC中老年代用什么回收方法？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%F0%9F%92%A1"><span class="nav-number">1.4.1.</span> <span class="nav-text">线程和进程的区别💡</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">进程和线程的关系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-number">1.4.2.</span> <span class="nav-text">什么是上下文切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-number">1.4.3.</span> <span class="nav-text">什么是线程死锁？如何避免死锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">线程死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">如何预防和避免死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">1.4.4.</span> <span class="nav-text">乐观锁和悲观锁了解吗？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">悲观锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4sleep-%E6%96%B9%E6%B3%95%E5%92%8Cwait-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">1.4.5.</span> <span class="nav-text">说说sleep()方法和wait()方法的区别和共同点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E5%B1%951%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88wait-%E6%96%B9%E6%B3%95%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%9C%A8Thread%E4%B8%AD%EF%BC%9F"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">拓展1：为什么wait()方法不定义在Thread中？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%93%E5%B1%952%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88sleep-%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E5%9C%A8Thread%E4%B8%AD%EF%BC%9F"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">拓展2：为什么sleep()方法定义在Thread中？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8F%82%E6%95%B0%EF%BC%9F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F%E6%96%B0%E7%BA%BF%E7%A8%8B%E6%B7%BB%E5%8A%A0%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F%E2%9D%97"><span class="nav-number">1.4.6.</span> <span class="nav-text">Java线程池有哪些参数？阻塞队列有几种？拒绝策略有几种？新线程添加的流程？❗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E5%92%8CCollable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.4.7.</span> <span class="nav-text">实现Runnable接口和Collable接口的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BJMM%EF%BC%88Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%89%E3%80%82volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E8%AF%B4%E8%AF%B4synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="nav-number">1.4.8.</span> <span class="nav-text">讲一下JMM（Java内存模型）。volatile关键字解决了什么问题？说说synchronized关键字和volatile关键字的区别。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9FAQS%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">1.4.9.</span> <span class="nav-text">AQS原理了解吗？AQS组件有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%BF%87CountDownLatch%E5%90%97%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">1.4.10.</span> <span class="nav-text">用过CountDownLatch吗？什么场景下用的？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">2.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.</span> <span class="nav-text">MySQL基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.1.1.</span> <span class="nav-text">非关系型数据库和关系型数据库的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.2.</span> <span class="nav-text">事务的四大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9F%E9%BB%98%E8%AE%A4%E6%98%AF%E4%BB%80%E4%B9%88%E7%BA%A7%E5%88%AB%EF%BC%9F"><span class="nav-number">2.1.3.</span> <span class="nav-text">MySQL事务隔离级别？默认是什么级别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.4.</span> <span class="nav-text">乐观锁和悲观锁的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-1"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">乐观锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E9%94%81-1"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">悲观锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.1.5.</span> <span class="nav-text">MySQL数据库两种存储引擎的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.</span> <span class="nav-text">MySQL索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E8%83%BD%E5%A4%9F%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E9%80%9F%E5%BA%A6%EF%BC%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">为什么索引能够提高查询速度？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E7%A0%81%EF%BC%9F"><span class="nav-number">2.2.2.</span> <span class="nav-text">聚集索引和非聚集索引的区别？非聚集索引一定回表查询码？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">非聚集索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%E5%90%97%EF%BC%9F"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">非聚集索引一定回表查询吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%AF%B9%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E5%88%97%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%B4%A2%E5%BC%95%E5%91%A2%EF%BC%9F%EF%BC%88%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E4%B8%80%E5%AE%9A%E8%83%BD%E6%8F%90%E9%AB%98%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E5%90%97%EF%BC%9F%EF%BC%89"><span class="nav-number">2.2.3.</span> <span class="nav-text">为什么不对表中的每一列创建一个索引呢？（使用索引一定能提高查询性能吗？）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9FHash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%95%B0%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8A%A3%E5%88%86%E6%9E%90"><span class="nav-number">2.2.4.</span> <span class="nav-text">索引底层的数据结构了解吗？Hash索引和B+数索引优劣分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%E5%81%9A%E7%B4%A2%E5%BC%95%E6%AF%94%E7%BA%A2%E9%BB%91%E6%A0%91%E5%A5%BD%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="nav-number">2.2.5.</span> <span class="nav-text">B+树做索引比红黑树好在哪里？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">2.2.6.</span> <span class="nav-text">最左前缀匹配原则了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.7.</span> <span class="nav-text">什么是覆盖索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MySQL%E8%BF%9B%E9%98%B6"><span class="nav-number">2.3.</span> <span class="nav-text">MySQL进阶</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">2.3.1.</span> <span class="nav-text">一条SQL语句在MySQL中如何执行的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explain%E5%91%BD%E4%BB%A4%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">2.3.2.</span> <span class="nav-text">explain命令了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8BSQL%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF"><span class="nav-number">2.3.3.</span> <span class="nav-text">简单说一下SQL调优思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%A4%A7%E8%A1%A8%E4%BC%98%E5%8C%96%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-number">2.3.4.</span> <span class="nav-text">简单说一下大表优化的思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B7%A5%E5%85%B7%EF%BC%9F%EF%BC%88sharding-jdbc%E3%80%81TSharding%E3%80%81MyCAT%E2%80%A6%EF%BC%89"><span class="nav-number">2.3.5.</span> <span class="nav-text">分库分表了解吗？为什么要分库分表？有哪些常见的分库分表工具？（sharding-jdbc、TSharding、MyCAT…）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">2.4.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8BRedis%E5%92%8CMemcached%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">2.4.1.</span> <span class="nav-text">分布式缓存常见的技术选型方案有哪些？说一下Redis和Memcached的区别和共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%9C%89%E7%BC%93%E5%AD%98%E6%83%85%E5%86%B5%E4%B8%8B%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="nav-number">2.4.2.</span> <span class="nav-text">说一下有缓存情况下查询数据和修改数据的流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9FSDS%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">2.4.3.</span> <span class="nav-text">Redis有哪些数据结构？SDS了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">2.4.4.</span> <span class="nav-text">Redis内存满了怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%E9%99%A4%E4%BA%86LRU%E8%BF%98%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.4.5.</span> <span class="nav-text">Redis内存淘汰算法除了LRU还有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E7%94%A8%EF%BC%9FRedis%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">2.4.6.</span> <span class="nav-text">Redis给缓存数据设置过期时间有啥用？Redis是如何判断数据是否过期的呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%EF%BC%88Redis%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87MULTI%E3%80%81EXEC%E3%80%81DISCARD%E3%80%81WATCH%E7%AD%89%E5%91%BD%E4%BB%A4%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E5%8A%9F%E8%83%BD%EF%BC%89"><span class="nav-number">2.4.7.</span> <span class="nav-text">Redis事务了解吗？（Redis可以通过MULTI、EXEC、DISCARD、WATCH等命令来实现事务功能）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">2.4.8.</span> <span class="nav-text">Redis批量操作的方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%92%8C%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="nav-number">2.4.9.</span> <span class="nav-text">缓存穿透和缓存雪崩问题了解吗？有哪些解决办法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="nav-number">2.4.10.</span> <span class="nav-text">如何基于Redis实现分布式锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSentinel%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">2.4.11.</span> <span class="nav-text">什么是Sentinel？有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E8%8A%82%E7%82%B9%E6%98%AF%E5%90%A6%E4%B8%8B%E7%BA%BF%EF%BC%9F%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">2.4.12.</span> <span class="nav-text">Sentinel如何检测节点是否下线？主观下线与客观下线的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%E7%9A%84%EF%BC%9F"><span class="nav-number">2.4.13.</span> <span class="nav-text">Sentinel是如何实现故障转移的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%87%BA%E6%96%B0%E7%9A%84master%EF%BC%88%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6%EF%BC%89%EF%BC%9F"><span class="nav-number">2.4.14.</span> <span class="nav-text">Sentinel是如何选择出新的master（选举机制）？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BB%8ESentinel%E9%9B%86%E7%BE%A4%E4%B8%AD%E9%80%89%E6%8B%A9%E5%87%BALeader%EF%BC%9F"><span class="nav-number">2.4.15.</span> <span class="nav-text">如何从Sentinel集群中选择出Leader？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sentinel%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E8%84%91%E8%A3%82%E5%90%97%EF%BC%9F"><span class="nav-number">2.4.16.</span> <span class="nav-text">Sentinel可以防止脑裂吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Redis-Cluster%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-number">2.4.17.</span> <span class="nav-text">为什么需要Redis Cluster？解决了什么问题？有什么优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Cluster%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E7%89%87%E7%9A%84%EF%BC%9F"><span class="nav-number">2.4.18.</span> <span class="nav-text">Redis Cluster是如何分片的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88Redis-Cluster%E7%9A%84%E5%93%88%E5%B8%8C%E6%A7%BD%E6%97%B616384%E4%B8%AA%EF%BC%9F"><span class="nav-number">2.4.19.</span> <span class="nav-text">为什么Redis Cluster的哈希槽时16384个？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E7%BB%99%E5%AE%9Akey%E7%9A%84%E5%BA%94%E8%AF%A5%E5%88%86%E5%B8%83%E5%88%B0%E5%93%AA%E4%B8%AA%E5%93%88%E5%B8%8C%E6%A7%BD%E4%B8%AD%EF%BC%9F"><span class="nav-number">2.4.20.</span> <span class="nav-text">如何确定给定key的应该分布到哪个哈希槽中？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Cluster%E6%94%AF%E6%8C%81%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E5%93%88%E5%B8%8C%E6%A7%BD%E5%90%97%EF%BC%9F"><span class="nav-number">2.4.21.</span> <span class="nav-text">Redis Cluster支持重新分配哈希槽吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Cluster%E6%89%A9%E5%AE%B9%E7%BC%A9%E5%AE%B9%E6%9C%9F%E9%97%B4%E5%8F%AF%E4%BB%A5%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E5%90%97%EF%BC%9F"><span class="nav-number">2.4.22.</span> <span class="nav-text">Redis Cluster扩容缩容期间可以提供服务吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Cluster%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="nav-number">2.4.23.</span> <span class="nav-text">Redis Cluster中的节点是怎么进行通信的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ES"><span class="nav-number">2.5.</span> <span class="nav-text">ES</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8ES%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9FES%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E5%81%9A%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.5.1.</span> <span class="nav-text">项目中用ES做了什么？ES可以帮助我们做什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lucene%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8Lucene%EF%BC%9F"><span class="nav-number">2.5.2.</span> <span class="nav-text">Lucene是什么？为什么不直接用Lucene？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8ES%E4%B8%8D%E7%94%A8MySQL%EF%BC%9F%EF%BC%88%E4%B8%A4%E8%80%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8D%E5%90%8C%EF%BC%89"><span class="nav-number">2.5.3.</span> <span class="nav-text">为什么用ES不用MySQL？（两者应用场景不同）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8ES%E4%B8%8D%E7%94%A8Hbase%EF%BC%9F%EF%BC%88%E4%B8%A4%E8%80%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8D%E5%90%8C%EF%BC%89"><span class="nav-number">2.5.4.</span> <span class="nav-text">为什么用ES不用Hbase？（两者应用场景不同）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88ES%E6%A3%80%E7%B4%A2%E6%AF%94%E8%BE%83%E5%BF%AB%EF%BC%9F%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E5%92%8C%E6%AD%A3%E6%8E%92%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95%E7%94%B1%E4%BB%80%E4%B9%88%E7%BB%84%E6%88%90%EF%BC%9F%E4%B8%A4%E8%80%85%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.5.5.</span> <span class="nav-text">为什么ES检索比较快？倒排索引和正排索引是什么？倒排索引由什么组成？两者区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E8%AF%8D%E5%99%A8%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E9%A1%B9%E7%9B%AE%E7%94%A8%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E5%88%86%E8%AF%8D%E5%99%A8%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E5%9F%BA%E4%BA%8E%E6%8B%BC%E9%9F%B3%E6%90%9C%E7%B4%A2%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="nav-number">2.5.6.</span> <span class="nav-text">分词器什么用？项目用的是什么分词器？如果我们要基于拼音搜索应该如何做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B9%E7%9B%AE%E4%B8%ADES%E5%92%8CMySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="nav-number">2.5.7.</span> <span class="nav-text">项目中ES和MySQL的数据是如何进行同步的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES%E9%9B%86%E7%BE%A4%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E5%88%86%E9%85%8D%E7%9A%84%EF%BC%88%E5%88%86%E7%89%87%EF%BC%89%EF%BC%9F%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="nav-number">2.5.8.</span> <span class="nav-text">ES集群中的数据是如何被分配的（分片）？自定义路由有什么好处？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C"><span class="nav-number">3.</span> <span class="nav-text">网络</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">网络分层模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI%E4%B8%8ETCP-IP%E5%90%84%E5%B1%82%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="nav-number">3.1.1.</span> <span class="nav-text">OSI与TCP&#x2F;IP各层的结构与功能</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">OSI七层模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">TCP&#x2F;IP四层模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82%EF%BC%9F"><span class="nav-number">3.1.2.</span> <span class="nav-text">为什么网络要分层？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI%E4%B8%8ETCP-IP%E5%90%84%E5%B1%82%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="nav-number">3.1.3.</span> <span class="nav-text">OSI与TCP&#x2F;IP各层都有哪些协议？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">应用层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="nav-number">3.1.3.2.</span> <span class="nav-text">传输层</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="nav-number">3.1.3.3.</span> <span class="nav-text">网络层</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E4%B8%8EUDP"><span class="nav-number">3.2.</span> <span class="nav-text">TCP与UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9FTCP%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%80%8C%E6%96%AD%E5%BC%80%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">3.2.1.</span> <span class="nav-text">TCP的三次握手与四次挥手的内容？TCP为什么连接是三次握手而断开是四次握手？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">四次挥手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">为什么要四次挥手？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.2.2.</span> <span class="nav-text">TCP与UDP的区别及使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">TCP与UDP的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">TCP和UDP的使用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F%E2%9D%97"><span class="nav-number">3.2.3.</span> <span class="nav-text">TCP是如何保证传输的可靠性？❗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%9F%BA%E4%BA%8ETCP%E8%BF%98%E6%98%AFUDP%EF%BC%9F"><span class="nav-number">3.2.4.</span> <span class="nav-text">HTTP基于TCP还是UDP？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">3.3.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">3.3.1.</span> <span class="nav-text">HTTP状态码有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3XX-%E9%87%8D%E5%AE%9A%E5%90%91%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">3XX 重定向状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4XX-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.3.1.2.</span> <span class="nav-text">4XX 客户端错误状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5XX-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">3.3.1.3.</span> <span class="nav-text">5XX 服务端错误状态码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84HTTP%E8%AF%B7%E6%B1%82%E6%89%80%E7%BB%8F%E8%BF%87%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.2.</span> <span class="nav-text">一次完整的HTTP请求所经过的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9FHTTP%E6%98%AF%E5%9F%BA%E4%BA%8ETCP%E8%BF%98%E6%98%AFUDP%E7%9A%84%EF%BC%9F"><span class="nav-number">3.3.3.</span> <span class="nav-text">HTTP协议了解吗？HTTP是基于TCP还是UDP的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E6%8A%A5%E6%96%87%E7%9A%84%E5%86%85%E5%AE%B9%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%EF%BC%81HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">3.3.4.</span> <span class="nav-text">HTTP报文的内容简单说一下！HTTP请求报文和响应报文中有哪些数据？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">HTTP请求报文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">HTTP响应报文</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">3.3.5.</span> <span class="nav-text">HTTP和HTTPS的区别了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-0%E5%92%8CHTTP-1-1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.3.6.</span> <span class="nav-text">HTTP&#x2F;1.0和HTTP&#x2F;1.1有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-1-1%E5%92%8CHTTP-2-0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.3.7.</span> <span class="nav-text">HTTP&#x2F;1.1和HTTP&#x2F;2.0有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-2-0%E5%92%8CHTTP-3-0%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.3.8.</span> <span class="nav-text">HTTP&#x2F;2.0和HTTP&#x2F;3.0有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">3.3.9.</span> <span class="nav-text">HTTP长连接和短连接了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cookie%E5%92%8CSeesion%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">3.3.10.</span> <span class="nav-text">Cookie和Seesion的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.3.11.</span> <span class="nav-text">URI和URL的区别是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PING"><span class="nav-number">3.4.</span> <span class="nav-text">PING</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PING%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.4.1.</span> <span class="nav-text">PING命令的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PING%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.4.2.</span> <span class="nav-text">PING命令的工作原理是什么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP"><span class="nav-number">3.5.</span> <span class="nav-text">IP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">3.5.1.</span> <span class="nav-text">IP协议的作用是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFIP%E5%9C%B0%E5%9D%80%EF%BC%9FIP%E5%AF%BB%E5%9D%80%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="nav-number">3.5.2.</span> <span class="nav-text">什么是IP地址？IP寻址如何工作？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80"><span class="nav-number">3.5.2.1.</span> <span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IP%E5%AF%BB%E5%9D%80"><span class="nav-number">3.5.2.2.</span> <span class="nav-text">IP寻址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPv4%E5%92%8CIPv6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E2%9D%97"><span class="nav-number">3.5.3.</span> <span class="nav-text">IPv4和IPv6有什么区别？❗</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.</span> <span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.0.1.</span> <span class="nav-text">进程和线程的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-number">4.0.2.</span> <span class="nav-text">进程有哪几种状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="nav-number">4.0.3.</span> <span class="nav-text">进程间的通信方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">4.0.4.</span> <span class="nav-text">线程间的同步方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB"><span class="nav-number">4.0.5.</span> <span class="nav-text">PCB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">4.0.6.</span> <span class="nav-text">进程的调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9F%E8%A7%A3%E5%86%B3%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">4.0.7.</span> <span class="nav-text">什么是死锁？死锁的四个必要条件？解决死锁的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.0.7.1.</span> <span class="nav-text">四个必要条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">4.0.8.</span> <span class="nav-text">常见的内存管理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="nav-number">4.0.9.</span> <span class="nav-text">内存碎片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">4.0.10.</span> <span class="nav-text">分段机制和分页机制的区别和共同点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E5%92%8C%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E4%B8%8B%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E8%BF%87%E7%A8%8B%E5%88%86%E5%88%AB%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="nav-number">4.0.11.</span> <span class="nav-text">分段机制和分页机制下的地址翻译过程分别是怎样的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%EF%BC%9F"><span class="nav-number">4.0.12.</span> <span class="nav-text">单级页表有什么问题？为什么需要多级页表？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TLB%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E4%BD%BF%E7%94%A8TLB%E4%B9%8B%E5%90%8E%E7%9A%84%E5%9C%B0%E5%9D%80%E7%BF%BB%E8%AF%91%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">4.0.13.</span> <span class="nav-text">TLB有什么用？使用TLB之后的地址翻译流程是怎样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E7%BC%BA%E5%A4%B1%EF%BC%8C%E5%B8%B8%E8%A7%81%E7%9A%84%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">4.0.14.</span> <span class="nav-text">页缺失，常见的页面置换算法有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">4.0.15.</span> <span class="nav-text">硬链接和软链接有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">4.0.16.</span> <span class="nav-text">常见的磁盘调度算法有哪些？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">算法和数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LRU%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E4%BD%A0%E8%83%BD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%90%97%EF%BC%9F"><span class="nav-number">5.1.1.</span> <span class="nav-text">LRU算法了解吗？你能实现一个吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%BF%AB%E6%8E%92%E3%80%81%E5%A0%86%E6%8E%92%EF%BC%89"><span class="nav-number">5.1.2.</span> <span class="nav-text">写排序算法（快排、堆排）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">5.1.2.2.</span> <span class="nav-text">归并排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%88"><span class="nav-number">5.1.3.</span> <span class="nav-text">使用数组实现一个栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97"><span class="nav-number">5.1.4.</span> <span class="nav-text">使用数组实现一个队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E3%80%81%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">5.1.5.</span> <span class="nav-text">实现一个链表、反转链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">5.2.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-vs-%E9%93%BE%E8%A1%A8"><span class="nav-number">5.2.1.</span> <span class="nav-text">数组 vs 链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.2.2.</span> <span class="nav-text">栈的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%88%86%E7%B1%BB%E3%80%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.2.3.</span> <span class="nav-text">队列的分类、应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91-vs-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">5.2.4.</span> <span class="nav-text">红黑树的特点、红黑树 vs 二叉查找树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.2.5.</span> <span class="nav-text">哈希表、哈希表应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">5.2.6.</span> <span class="nav-text">布隆过滤器了解吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1"><span class="nav-number">6.</span> <span class="nav-text">系统设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.1.</span> <span class="nav-text">设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E4%B8%BA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">6.1.1.</span> <span class="nav-text">何为设计模式？有哪些常见的设计模式？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="nav-number">6.1.2.</span> <span class="nav-text">单例模式了解吗？说一下单例模式的使用场景。手写一个单例模式的实现。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82"><span class="nav-number">6.1.3.</span> <span class="nav-text">观察者模式了解吗？说一下观察者模式的使用场景。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%82"><span class="nav-number">6.1.4.</span> <span class="nav-text">工厂模式了解吗？说一下工厂模式的使用场景。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%88Netty%E3%80%81MyBatis-%E2%80%A6%EF%BC%89%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84%EF%BC%9F"><span class="nav-number">6.1.5.</span> <span class="nav-text">责任链模式了解吗？哪些开源项目（Netty、MyBatis …）中用到了责任链模式？怎么用的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SOLID%E5%8E%9F%E5%88%99%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E7%AE%80%E5%8D%95%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%92%8C%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E7%9A%84%E7%90%86%E8%A7%A3%E3%80%82"><span class="nav-number">6.1.6.</span> <span class="nav-text">SOLID原则了解吗？简单谈谈自己对于单一职责和开闭原则的理解。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%85%E8%AF%BBSpring%E6%BA%90%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%80%E8%AE%A9%E4%BD%A0%E5%BD%B1%E5%93%8D%E6%B7%B1%E5%88%BB%EF%BC%9F%E8%83%BD%E7%AE%80%E5%8D%95%E8%AE%B2%E8%AE%B2%E5%90%97%EF%BC%9F"><span class="nav-number">6.1.7.</span> <span class="nav-text">阅读Spring源码的时候什么设计模式最让你影响深刻？能简单讲讲吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%A1%86%E6%9E%B6-Spring"><span class="nav-number">6.2.</span> <span class="nav-text">常见框架 - Spring</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring%E6%A1%86%E6%9E%B6%EF%BC%9F"><span class="nav-number">6.2.1.</span> <span class="nav-text">什么是Spring框架？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E4%B8%BE%E4%B8%80%E4%BA%9B%E9%87%8D%E8%A6%81%E7%9A%84Spring%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="nav-number">6.2.2.</span> <span class="nav-text">列举一些重要的Spring模块？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8ESpring-IOC%E5%92%8CAOP%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">6.2.3.</span> <span class="nav-text">谈谈自己对于Spring IOC和AOP的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="nav-number">6.2.4.</span> <span class="nav-text">Spring Bean 的生命周期说一下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring%E7%A7%8D%E7%9A%84bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">6.2.5.</span> <span class="nav-text">Spring种的bean的作用域有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="nav-number">6.2.6.</span> <span class="nav-text">拦截器和过滤器了解吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%BB%98%E8%AE%A4%E7%94%A8%E5%93%AA%E4%B8%80%E7%A7%8D%EF%BC%9F"><span class="nav-number">6.2.7.</span> <span class="nav-text">Spring 动态代理默认用哪一种？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hibernate-%E5%92%8C-mybatis-%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.8.</span> <span class="nav-text">hibernate 和 mybatis 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-%E5%92%8C-Spring-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">6.2.9.</span> <span class="nav-text">Spring Boot 和 Spring 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E5%87%BA%E4%BD%BF%E7%94%A8Spring-Boot%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9"><span class="nav-number">6.2.10.</span> <span class="nav-text">说出使用Spring Boot的主要优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSpring-Boot-Starter%EF%BC%9F"><span class="nav-number">6.2.11.</span> <span class="nav-text">什么是Spring Boot Starter？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-SpringBootApplication%E6%B3%A8%E8%A7%A3"><span class="nav-number">6.2.12.</span> <span class="nav-text">介绍一下@SpringBootApplication注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot-%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="nav-number">6.2.13.</span> <span class="nav-text">Spring Boot 的自动配置是如何实现的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-Boot%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%B5%8C%E5%85%A5%E5%BC%8Fweb%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="nav-number">6.2.14.</span> <span class="nav-text">Spring Boot支持哪些嵌入式web容器？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%A1%86%E6%9E%B6-Netty"><span class="nav-number">6.3.</span> <span class="nav-text">常见框架 - Netty</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Atopos·"
      src="/./img/head.jpg">
  <p class="site-author-name" itemprop="name">Atopos·</p>
  <div class="site-description" itemprop="description">看得懂的书,请仔细看;看不懂的书,请硬着头皮看!</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/aaaatopos" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;aaaatopos" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/xzt2520@163.com" title="E-Mail → xzt2520@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Atopos·</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="https://lib.baomitu.com/canvas-nest.js/1.0.1/canvas-nest.js"></script>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
